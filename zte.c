/*
  USB Driver for GSM modems

  Copyright (C) 2005  Matthias Urlichs <smurf@smurf.noris.de>

  This driver is free software; you can redistribute it and/or modify
  it under the terms of Version 2 of the GNU General Public License as
  published by the Free Software Foundation.

  Portions copied from the Keyspan driver by Hugh Blemings <hugh@blemings.org>

  History: see the git log.

  Work sponsored by: Sigos GmbH, Germany <info@sigos.de>

  This driver exists because the "normal" serial driver doesn't work too well
  with GSM modems. Issues:
  - data loss -- one single Receive URB is not nearly enough
  - nonstandard flow (zte devices) control
  - controlling the baud rate doesn't make sense

  This driver is named "zte" because the most common device it's
  used for is a PC-Card (with an internal OHCI-USB interface, behind
  which the GSM interface sits), made by zte Inc.

  Some of the "one port" devices actually exhibit multiple USB instances
  on the USB bus. This is not a bug, these ports are used for different
  device features.
*/
#define DRIVER_VERSION "v3.26"
#define DRIVER_AUTHOR "Matthias Urlichs <smurf@smurf.noris.de>"
#define DRIVER_DESC "USB Driver for GSM modems"
//add by zhaoming-------start
#if ! defined(LINUX_VERSION_CODE)  
#include <linux/version.h>
#endif

#ifndef KERNEL_VERSION
#define KERNEL_VERSION(a,b,c) ((a)*65536+(b)*256+(c))
#endif
//add by zhaoming-------stop

#define TPLink_VENDOR_ID		0x07D1
#define QUALCOMM_VENDOR_ID			0x05C6

#define ZTE_USB_DEVICE_ID_MATCH_INT_CLASS_AND_SUBCLASS_INFO(vend,cl, sc) \
         .match_flags = (USB_DEVICE_ID_MATCH_VENDOR)  \
              | (USB_DEVICE_ID_MATCH_INT_CLASS  \
		| USB_DEVICE_ID_MATCH_INT_SUBCLASS), \
         .idVendor = (vend), \
         .bInterfaceClass = (cl), \
         .bInterfaceSubClass = (sc) 

#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)//use 2.6.18 sourcecode

#include <linux/kernel.h>
#include <linux/jiffies.h>
#include <linux/errno.h>
#include <linux/tty.h>
#include <linux/tty_flip.h>
#include <linux/module.h>
#include <linux/usb.h>
#include <linux/usb/serial.h>

/* Function prototypes */
static int  zte_open(struct usb_serial_port *port, struct file *filp);
static void zte_close(struct usb_serial_port *port, struct file *filp);
static int  zte_startup(struct usb_serial *serial);
static void zte_shutdown(struct usb_serial *serial);
static void zte_rx_throttle(struct usb_serial_port *port);
static void zte_rx_unthrottle(struct usb_serial_port *port);
static int  zte_write_room(struct usb_serial_port *port);

static void zte_instat_callback(struct urb *urb, struct pt_regs *regs);

static int zte_write(struct usb_serial_port *port,
			const unsigned char *buf, int count);

static int  zte_chars_in_buffer(struct usb_serial_port *port);
static int  zte_ioctl(struct usb_serial_port *port, struct file *file,
			unsigned int cmd, unsigned long arg);
static void zte_set_termios(struct usb_serial_port *port,
				struct termios *old);
static void zte_break_ctl(struct usb_serial_port *port, int break_state);
static int  zte_tiocmget(struct usb_serial_port *port, struct file *file);
static int  zte_tiocmset(struct usb_serial_port *port, struct file *file,
				unsigned int set, unsigned int clear);
static int  zte_send_setup(struct usb_serial_port *port);

/* Vendor and product IDs */
#define zte_VENDOR_ID			0x19d2


static struct usb_device_id zte_ids[] = {

    { USB_DEVICE(zte_VENDOR_ID, 0x0001 ) },/*zte*/
    { USB_DEVICE(zte_VENDOR_ID, 0x0002 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0003 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0004 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0005 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0006 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0007 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0008 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0009 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0010 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0011 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0012 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0013 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0014 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0015 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0016 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0017 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0018 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0019 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0020 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0021 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0022 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0023 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0024 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0025 ) },
 //	 { USB_DEVICE(zte_VENDOR_ID, 0x0026 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0027 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0028 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0029 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0030 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0031 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0032 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0033 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0034 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0035 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0036 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0037 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0038 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0039 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0040 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0041 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0042 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0043 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0044 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0045 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0046 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0047 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0048 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0049 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0050 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0051 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0052 ) },
 //	 { USB_DEVICE(zte_VENDOR_ID, 0x0053 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0054 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0055 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0056 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0057 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0058 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0059 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0060 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0061 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0062 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0063 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0064 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0065 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0066 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0067 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0068 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0069 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0070 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0071 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0072 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0073 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0074 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0075 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0076 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0077 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0078 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0079 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0080 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0081 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0082 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0083 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0084 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0085 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0086 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0087 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0088 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0089 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0090 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0091 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0092 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0093 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0094 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0095 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0096 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0097 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0098 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0099 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0104 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0105 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0106 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0108 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0117 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0118 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0121 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0122 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0123 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0124 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0125 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0126 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0128 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0130 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0133 ) },	   
    { USB_DEVICE(zte_VENDOR_ID, 0x0141 ) }, 
    { USB_DEVICE(zte_VENDOR_ID, 0x0144 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0145 ) }, 
    { USB_DEVICE(zte_VENDOR_ID, 0x0147 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0148 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0151 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0152 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0153 ) },
    //{ USB_DEVICE(zte_VENDOR_ID, 0x0154 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0155 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0156 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0157 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0158 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0159 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0160 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0161 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0162 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0164 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0165 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0168 ) },	   
    { USB_DEVICE(zte_VENDOR_ID, 0x0170 ) }, 
    { USB_DEVICE(zte_VENDOR_ID, 0x0176 ) },	   
    { USB_DEVICE(zte_VENDOR_ID, 0x0178 ) }, 	   
    { USB_DEVICE(zte_VENDOR_ID, 0x1008 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1010 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1012 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1057 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1058 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1059 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1060 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1061 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1062 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1063 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1064 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1065 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1066 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1067 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1068 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1069 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1070 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1071 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1072 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1073 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1074 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1075 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1076 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1077 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1078 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1079 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1080 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1081 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1082 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1083 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1084 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1085 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1086 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1087 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1088 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1089 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1090 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1091 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1092 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1093 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1094 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1095 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1096 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1097 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1098 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1099 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1100 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1101 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1102 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1103 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1104 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1105 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1106 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1107 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1108 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1109 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1110 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1111 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1112 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1113 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1114 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1115 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1116 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1117 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1118 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1119 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1120 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1121 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1122 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1123 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1124 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1125 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1126 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1127 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1128 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1129 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1130 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1131 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1132 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1133 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1134 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1135 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1136 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1137 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1138 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1139 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1140 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1141 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1142 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1143 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1144 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1145 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1146 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1147 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1148 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1149 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1150 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1151 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1152 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1153 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1154 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1155 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1156 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1157 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1158 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1159 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1160 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1161 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1162 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1163 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1164 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1165 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1166 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1167 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1168 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1169 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1170 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1244 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1245 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1246 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1247 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1248 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1249 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1250 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1251 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1252 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1253 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1254 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1255 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1256 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1257 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1258 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1259 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1260 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1261 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1262 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1263 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1264 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1265 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1266 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1267 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1268 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1269 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1270 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1271 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1272 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1273 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1274 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1275 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1276 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1277 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1278 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1279 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1280 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1281 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1282 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1283 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1284 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1285 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x1286 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1287 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1288 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1289 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1290 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1291 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1292 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1293 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1294 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1295 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1296 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1297 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1298 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1299 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1300 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1401 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1402 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1403 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1404 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1405 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1406 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1407 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1408 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1409 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1410 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1411 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1412 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1413 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1414 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1415 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1416 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1417 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1418 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1419 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1420 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1421 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1422 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1423 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1424 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1425 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1426 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1427 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1428 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1429 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1430 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1431 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1432 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1433 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1434 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1435 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1436 ) },   
	{ USB_DEVICE(zte_VENDOR_ID, 0x1437 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1438 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1439 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1440 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1441 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1442 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1443 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1444 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1445 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1446 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1447 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1448 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1449 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1450 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1451 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1452 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1453 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1454 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1455 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1456 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1457 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1458 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1459 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1460 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1461 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1462 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1463 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1464 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1465 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1466 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1467 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1468 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1469 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1470 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1471 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1472 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1473 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1474 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1475 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1476 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1477 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1478 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1479 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1480 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1481 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1482 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1483 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1484 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1485 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1486 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1487 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1488 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1489 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1490 ) },	 
	{ USB_DEVICE(zte_VENDOR_ID, 0x1491 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1492 ) },	 
	{ USB_DEVICE(zte_VENDOR_ID, 0x1493 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1494 ) },	 
	{ USB_DEVICE(zte_VENDOR_ID, 0x1495 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1496 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1497 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1498 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1499 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1500 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1501 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1502 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1503 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1504 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1505 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1506 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1507 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1508 ) },	 
	{ USB_DEVICE(zte_VENDOR_ID, 0x1509 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1510 ) },	   
	{ USB_DEVICE(zte_VENDOR_ID, 0x2002 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x2003 ) },	 
	{ USB_DEVICE(zte_VENDOR_ID, 0xFFEC ) },

    { USB_DEVICE(TPLink_VENDOR_ID, 0x7E11 ) },/*TPLink */
    { USB_DEVICE(QUALCOMM_VENDOR_ID, 0x9001 ) },/*QUALCOMM*/
    { USB_DEVICE(QUALCOMM_VENDOR_ID, 0x9002 ) },

		{ } /* Terminating entry */
	};


static struct usb_device_id zte_ids1[] = {

    { USB_DEVICE(zte_VENDOR_ID, 0x0001 ) },/*zte*/
    { USB_DEVICE(zte_VENDOR_ID, 0x0002 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0003 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0004 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0005 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0006 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0007 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0008 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0009 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0010 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0011 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0012 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0013 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0014 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0015 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0016 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0017 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0018 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0019 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0020 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0021 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0022 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0023 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0024 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0025 ) },
 //	 { USB_DEVICE(zte_VENDOR_ID, 0x0026 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0027 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0028 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0029 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0030 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0031 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0032 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0033 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0034 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0035 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0036 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0037 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0038 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0039 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0040 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0041 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0042 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0043 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0044 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0045 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0046 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0047 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0048 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0049 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0050 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0051 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0052 ) },
 //	 { USB_DEVICE(zte_VENDOR_ID, 0x0053 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0054 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0055 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0056 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0057 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0058 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0059 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0060 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0061 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0062 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0063 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0064 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0065 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0066 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0067 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0068 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0069 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0070 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0071 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0072 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0073 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0074 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0075 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0076 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0077 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0078 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0079 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0080 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0081 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0082 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0083 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0084 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0085 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0086 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0087 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0088 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0089 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0090 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0091 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0092 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0093 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0094 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0095 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0096 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0097 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0098 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0099 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0104 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0105 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0106 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0108 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0117 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0118 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0121 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0122 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0123 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0124 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0125 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0126 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0128 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0130 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0133 ) },	   
    { USB_DEVICE(zte_VENDOR_ID, 0x0141 ) }, 
    { USB_DEVICE(zte_VENDOR_ID, 0x0144 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0145 ) }, 
    { USB_DEVICE(zte_VENDOR_ID, 0x0147 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0148 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0151 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0152 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0153 ) },
    //{ USB_DEVICE(zte_VENDOR_ID, 0x0154 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0155 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0156 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0157 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0158 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0159 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0160 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0161 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0162 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0164 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0165 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0168 ) },	   
    { USB_DEVICE(zte_VENDOR_ID, 0x0170 ) }, 
    { USB_DEVICE(zte_VENDOR_ID, 0x0176 ) },	   
    { USB_DEVICE(zte_VENDOR_ID, 0x0178 ) }, 	   
    { USB_DEVICE(zte_VENDOR_ID, 0x1008 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1010 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1012 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1057 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1058 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1059 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1060 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1061 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1062 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1063 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1064 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1065 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1066 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1067 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1068 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1069 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1070 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1071 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1072 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1073 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1074 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1075 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1076 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1077 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1078 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1079 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1080 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1081 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1082 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1083 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1084 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1085 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1086 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1087 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1088 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1089 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1090 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1091 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1092 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1093 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1094 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1095 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1096 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1097 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1098 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1099 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1100 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1101 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1102 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1103 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1104 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1105 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1106 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1107 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1108 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1109 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1110 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1111 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1112 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1113 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1114 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1115 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1116 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1117 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1118 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1119 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1120 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1121 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1122 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1123 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1124 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1125 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1126 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1127 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1128 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1129 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1130 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1131 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1132 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1133 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1134 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1135 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1136 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1137 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1138 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1139 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1140 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1141 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1142 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1143 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1144 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1145 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1146 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1147 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1148 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1149 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1150 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1151 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1152 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1153 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1154 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1155 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1156 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1157 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1158 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1159 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1160 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1161 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1162 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1163 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1164 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1165 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1166 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1167 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1168 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1169 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1170 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1244 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1245 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1246 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1247 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1248 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1249 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1250 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1251 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1252 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1253 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1254 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1255 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1256 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1257 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1258 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1259 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1260 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1261 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1262 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1263 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1264 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1265 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1266 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1267 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1268 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1269 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1270 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1271 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1272 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1273 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1274 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1275 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1276 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1277 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1278 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1279 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1280 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1281 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1282 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1283 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1284 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1285 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x1286 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1287 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1288 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1289 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1290 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1291 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1292 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1293 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1294 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1295 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1296 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1297 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1298 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1299 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1300 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1401 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1402 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1403 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1404 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1405 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1406 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1407 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1408 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1409 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1410 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1411 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1412 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1413 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1414 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1415 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1416 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1417 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1418 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1419 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1420 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1421 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1422 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1423 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1424 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1425 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1426 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1427 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1428 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1429 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1430 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1431 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1432 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1433 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1434 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1435 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1436 ) },   
	{ USB_DEVICE(zte_VENDOR_ID, 0x1437 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1438 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1439 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1440 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1441 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1442 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1443 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1444 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1445 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1446 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1447 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1448 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1449 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1450 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1451 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1452 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1453 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1454 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1455 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1456 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1457 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1458 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1459 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1460 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1461 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1462 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1463 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1464 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1465 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1466 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1467 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1468 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1469 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1470 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1471 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1472 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1473 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1474 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1475 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1476 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1477 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1478 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1479 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1480 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1481 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1482 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1483 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1484 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1485 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1486 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1487 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1488 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1489 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1490 ) },	 
	{ USB_DEVICE(zte_VENDOR_ID, 0x1491 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1492 ) },	 
	{ USB_DEVICE(zte_VENDOR_ID, 0x1493 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1494 ) },	 
	{ USB_DEVICE(zte_VENDOR_ID, 0x1495 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1496 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1497 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1498 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1499 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1500 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1501 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1502 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1503 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1504 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1505 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1506 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1507 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1508 ) },	 
	{ USB_DEVICE(zte_VENDOR_ID, 0x1509 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1510 ) },	   
	{ USB_DEVICE(zte_VENDOR_ID, 0x2002 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x2003 ) },	 
	{ USB_DEVICE(zte_VENDOR_ID, 0xFFEC ) },

    { USB_DEVICE(TPLink_VENDOR_ID, 0x7E11 ) },/*TPLink */
    { USB_DEVICE(QUALCOMM_VENDOR_ID, 0x9001 ) },/*QUALCOMM*/
    { USB_DEVICE(QUALCOMM_VENDOR_ID, 0x9002 ) },

		{ } /* Terminating entry */
	};

MODULE_DEVICE_TABLE(usb, zte_ids);

static struct usb_driver zte_driver = {
	.name       = "zte",
	.probe      = usb_serial_probe,
	.disconnect = usb_serial_disconnect,
	.id_table   = zte_ids,
	.no_dynamic_id = 	1,
};

/* The card has three separate interfaces, which the serial driver
 * recognizes separately, thus num_port=1.
 */

static struct usb_serial_driver zte_1port_device = {
	.driver = {
		.owner =	THIS_MODULE,
		.name =		"zte1",
	},
	.description       = "GSM modem (1-port)",
	.id_table          = zte_ids1,
	.num_interrupt_in  = NUM_DONT_CARE,
	.num_bulk_in       = NUM_DONT_CARE,
	.num_bulk_out      = NUM_DONT_CARE,
	.num_ports         = 1,
	.open              = zte_open,
	.close             = zte_close,
	.write             = zte_write,
	.write_room        = zte_write_room,
	.chars_in_buffer   = zte_chars_in_buffer,
	.throttle          = zte_rx_throttle,
	.unthrottle        = zte_rx_unthrottle,
	.ioctl             = zte_ioctl,
	.set_termios       = zte_set_termios,
	.break_ctl         = zte_break_ctl,
	.tiocmget          = zte_tiocmget,
	.tiocmset          = zte_tiocmset,
	.attach            = zte_startup,
	.shutdown          = zte_shutdown,
	.read_int_callback = zte_instat_callback,
};

#ifdef CONFIG_USB_DEBUG
static int debug;
#else
#define debug 0
#endif

/* per port private data */

#define N_IN_URB 4
#define N_OUT_URB 1
#define IN_BUFLEN 4096
#define OUT_BUFLEN 128

struct zte_port_private {
	/* Input endpoints and buffer for this port */
	struct urb *in_urbs[N_IN_URB];
	char in_buffer[N_IN_URB][IN_BUFLEN];
	/* Output endpoints and buffer for this port */
	struct urb *out_urbs[N_OUT_URB];
	char out_buffer[N_OUT_URB][OUT_BUFLEN];

	/* Settings for the port */
	int rts_state;	/* Handshaking pins (outputs) */
	int dtr_state;
	int cts_state;	/* Handshaking pins (inputs) */
	int dsr_state;
	int dcd_state;
	int ri_state;

	unsigned long tx_start_time[N_OUT_URB];
};

/* Functions used by new usb-serial code. */
static int __init zte_init(void)
{
	int retval;
	retval = usb_serial_register(&zte_1port_device);
	if (retval)
		goto failed_1port_device_register;
	retval = usb_register(&zte_driver);
	if (retval)
		goto failed_driver_register;

	info(DRIVER_DESC ": " DRIVER_VERSION);

	return 0;

failed_driver_register:
	usb_serial_deregister (&zte_1port_device);
failed_1port_device_register:
	return retval;
}

static void __exit zte_exit(void)
{
	usb_deregister (&zte_driver);
	usb_serial_deregister (&zte_1port_device);
}

module_init(zte_init);
module_exit(zte_exit);

static void zte_rx_throttle(struct usb_serial_port *port)
{
	dbg("%s", __FUNCTION__);
}

static void zte_rx_unthrottle(struct usb_serial_port *port)
{
	dbg("%s", __FUNCTION__);
}

static void zte_break_ctl(struct usb_serial_port *port, int break_state)
{
	/* Unfortunately, I don't know how to send a break */
	dbg("%s", __FUNCTION__);
}

static void zte_set_termios(struct usb_serial_port *port,
			struct termios *old_termios)
{
	dbg("%s", __FUNCTION__);

	zte_send_setup(port);
}

static int zte_tiocmget(struct usb_serial_port *port, struct file *file)
{
	unsigned int value;
	struct zte_port_private *portdata;

	portdata = usb_get_serial_port_data(port);

	value = ((portdata->rts_state) ? TIOCM_RTS : 0) |
		((portdata->dtr_state) ? TIOCM_DTR : 0) |
		((portdata->cts_state) ? TIOCM_CTS : 0) |
		((portdata->dsr_state) ? TIOCM_DSR : 0) |
		((portdata->dcd_state) ? TIOCM_CAR : 0) |
		((portdata->ri_state) ? TIOCM_RNG : 0);

	return value;
}

static int zte_tiocmset(struct usb_serial_port *port, struct file *file,
			unsigned int set, unsigned int clear)
{
	struct zte_port_private *portdata;

	portdata = usb_get_serial_port_data(port);

	if (set & TIOCM_RTS)
		portdata->rts_state = 1;
	if (set & TIOCM_DTR)
		portdata->dtr_state = 1;

	if (clear & TIOCM_RTS)
		portdata->rts_state = 0;
	if (clear & TIOCM_DTR)
		portdata->dtr_state = 0;
	return zte_send_setup(port);
}

static int zte_ioctl(struct usb_serial_port *port, struct file *file,
			unsigned int cmd, unsigned long arg)
{
	return -ENOIOCTLCMD;
}

/* Write */
static int zte_write(struct usb_serial_port *port,
			const unsigned char *buf, int count)
{
	struct zte_port_private *portdata;
	int i;
	int left, todo;
	struct urb *this_urb = NULL; /* spurious */
	int err;

	portdata = usb_get_serial_port_data(port);

	dbg("%s: write (%d chars)", __FUNCTION__, count);

	i = 0;
	left = count;
	for (i=0; left > 0 && i < N_OUT_URB; i++) {
		todo = left;
		if (todo > OUT_BUFLEN)
			todo = OUT_BUFLEN;

		this_urb = portdata->out_urbs[i];
		if (this_urb->status == -EINPROGRESS) {
			if (time_before(jiffies,
					portdata->tx_start_time[i] + 10 * HZ))
				continue;
			usb_unlink_urb(this_urb);
			continue;
		}
		if (this_urb->status != 0)
			dbg("usb_write %p failed (err=%d)",
				this_urb, this_urb->status);

		dbg("%s: endpoint %d buf %d", __FUNCTION__,
			usb_pipeendpoint(this_urb->pipe), i);

		/* send the data */
		memcpy (this_urb->transfer_buffer, buf, todo);
		this_urb->transfer_buffer_length = todo;

		this_urb->dev = port->serial->dev;
		err = usb_submit_urb(this_urb, GFP_ATOMIC);
		if (err) {
			dbg("usb_submit_urb %p (write bulk) failed "
				"(%d, has %d)", this_urb,
				err, this_urb->status);
			continue;
		}
		portdata->tx_start_time[i] = jiffies;
		buf += todo;
		left -= todo;
	}

	count -= left;
	dbg("%s: wrote (did %d)", __FUNCTION__, count);
	return count;
}

static void zte_indat_callback(struct urb *urb, struct pt_regs *regs)
{
	int err;
	int endpoint;
	struct usb_serial_port *port;
	struct tty_struct *tty;
	unsigned char *data = urb->transfer_buffer;

	dbg("%s: %p", __FUNCTION__, urb);

	endpoint = usb_pipeendpoint(urb->pipe);
	port = (struct usb_serial_port *) urb->context;

	if (urb->status) {
		dbg("%s: nonzero status: %d on endpoint %02x.",
		    __FUNCTION__, urb->status, endpoint);
	} else {
		tty = port->tty;
		if (urb->actual_length) {
			tty_buffer_request_room(tty, urb->actual_length);
			tty_insert_flip_string(tty, data, urb->actual_length);
			tty_flip_buffer_push(tty);
		} else {
			dbg("%s: empty read urb received", __FUNCTION__);
		}

		/* Resubmit urb so we continue receiving */
		if (port->open_count && urb->status != -ESHUTDOWN) {
			err = usb_submit_urb(urb, GFP_ATOMIC);
			if (err)
				printk(KERN_ERR "%s: resubmit read urb failed. "
					"(%d)", __FUNCTION__, err);
		}
	}
	return;
}

static void zte_outdat_callback(struct urb *urb, struct pt_regs *regs)
{
	struct usb_serial_port *port;

	dbg("%s", __FUNCTION__);

	port = (struct usb_serial_port *) urb->context;

	usb_serial_port_softint(port);
}

static void zte_instat_callback(struct urb *urb, struct pt_regs *regs)
{
	int err;
	struct usb_serial_port *port = (struct usb_serial_port *) urb->context;
	struct zte_port_private *portdata = usb_get_serial_port_data(port);
	struct usb_serial *serial = port->serial;

	dbg("%s", __FUNCTION__);
	dbg("%s: urb %p port %p has data %p", __FUNCTION__,urb,port,portdata);

	if (urb->status == 0) {
		struct usb_ctrlrequest *req_pkt =
				(struct usb_ctrlrequest *)urb->transfer_buffer;

		if (!req_pkt) {
			dbg("%s: NULL req_pkt\n", __FUNCTION__);
			return;
		}
		if ((req_pkt->bRequestType == 0xA1) &&
				(req_pkt->bRequest == 0x20)) {
			int old_dcd_state;
			unsigned char signals = *((unsigned char *)
					urb->transfer_buffer +
					sizeof(struct usb_ctrlrequest));

			dbg("%s: signal x%x", __FUNCTION__, signals);

			old_dcd_state = portdata->dcd_state;
			portdata->cts_state = 1;
			portdata->dcd_state = ((signals & 0x01) ? 1 : 0);
			portdata->dsr_state = ((signals & 0x02) ? 1 : 0);
			portdata->ri_state = ((signals & 0x08) ? 1 : 0);

			if (port->tty && !C_CLOCAL(port->tty) &&
					old_dcd_state && !portdata->dcd_state)
				tty_hangup(port->tty);
		} else {
			dbg("%s: type %x req %x", __FUNCTION__,
				req_pkt->bRequestType,req_pkt->bRequest);
		}
	} else
		dbg("%s: error %d", __FUNCTION__, urb->status);

	/* Resubmit urb so we continue receiving IRQ data */
	if (urb->status != -ESHUTDOWN) {
		urb->dev = serial->dev;
		err = usb_submit_urb(urb, GFP_ATOMIC);
		if (err)
			dbg("%s: resubmit intr urb failed. (%d)",
				__FUNCTION__, err);
	}
}

static int zte_write_room(struct usb_serial_port *port)
{
	struct zte_port_private *portdata;
	int i;
	int data_len = 0;
	struct urb *this_urb;


	portdata = usb_get_serial_port_data(port);

	for (i=0; i < N_OUT_URB; i++) {
		this_urb = portdata->out_urbs[i];
		if (this_urb && this_urb->status != -EINPROGRESS)
			data_len += OUT_BUFLEN;
	}

	dbg("%s: %d", __FUNCTION__, data_len);
	return data_len;
}

static int zte_chars_in_buffer(struct usb_serial_port *port)
{
	struct zte_port_private *portdata;
	int i;
	int data_len = 0;
	struct urb *this_urb;

	portdata = usb_get_serial_port_data(port);

	for (i=0; i < N_OUT_URB; i++) {
		this_urb = portdata->out_urbs[i];
		if (this_urb && this_urb->status == -EINPROGRESS)
			data_len += this_urb->transfer_buffer_length;
	}
	dbg("%s: %d", __FUNCTION__, data_len);
	return data_len;
}

static int zte_open(struct usb_serial_port *port, struct file *filp)
{
	struct zte_port_private *portdata;
	struct usb_serial *serial = port->serial;
	int i, err;
	struct urb *urb;

	portdata = usb_get_serial_port_data(port);

	dbg("%s", __FUNCTION__);

	/* Set some sane defaults */
	portdata->rts_state = 1;
	portdata->dtr_state = 1;

	/* Reset low level data toggle and start reading from endpoints */
	for (i = 0; i < N_IN_URB; i++) {
		urb = portdata->in_urbs[i];
		if (! urb)
			continue;
		if (urb->dev != serial->dev) {
			dbg("%s: dev %p != %p", __FUNCTION__,
				urb->dev, serial->dev);
			continue;
		}

		/*
		 * make sure endpoint data toggle is synchronized with the
		 * device
		 */
		usb_clear_halt(urb->dev, urb->pipe);

		err = usb_submit_urb(urb, GFP_KERNEL);
		if (err) {
			dbg("%s: submit urb %d failed (%d) %d",
				__FUNCTION__, i, err,
				urb->transfer_buffer_length);
		}
	}

	/* Reset low level data toggle on out endpoints */
	for (i = 0; i < N_OUT_URB; i++) {
		urb = portdata->out_urbs[i];
		if (! urb)
			continue;
		urb->dev = serial->dev;
		/* usb_settoggle(urb->dev, usb_pipeendpoint(urb->pipe),
				usb_pipeout(urb->pipe), 0); */
	}

	port->tty->low_latency = 1;

	zte_send_setup(port);

	return (0);
}

static inline void stop_urb(struct urb *urb)
{
	if (urb && urb->status == -EINPROGRESS)
		usb_kill_urb(urb);
}

static void zte_close(struct usb_serial_port *port, struct file *filp)
{
	int i;
	struct usb_serial *serial = port->serial;
	struct zte_port_private *portdata;

	dbg("%s", __FUNCTION__);
	portdata = usb_get_serial_port_data(port);

	portdata->rts_state = 0;
	portdata->dtr_state = 0;

	if (serial->dev) {
		zte_send_setup(port);

		/* Stop reading/writing urbs */
		for (i = 0; i < N_IN_URB; i++)
			stop_urb(portdata->in_urbs[i]);
		for (i = 0; i < N_OUT_URB; i++)
			stop_urb(portdata->out_urbs[i]);
	}
	port->tty = NULL;
}

/* Helper functions used by zte_setup_urbs */
static struct urb *zte_setup_urb(struct usb_serial *serial, int endpoint,
		int dir, void *ctx, char *buf, int len,
		void (*callback)(struct urb *, struct pt_regs *regs))
{
	struct urb *urb;

	if (endpoint == -1)
		return NULL;		/* endpoint not needed */

	urb = usb_alloc_urb(0, GFP_KERNEL);		/* No ISO */
	if (urb == NULL) {
		dbg("%s: alloc for endpoint %d failed.", __FUNCTION__, endpoint);
		return NULL;
	}

		/* Fill URB using supplied data. */
	usb_fill_bulk_urb(urb, serial->dev,
		      usb_sndbulkpipe(serial->dev, endpoint) | dir,
		      buf, len, callback, ctx);

	return urb;
}

/* Setup urbs */
static void zte_setup_urbs(struct usb_serial *serial)
{
	int i,j;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;

	dbg("%s", __FUNCTION__);

	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);

	/* Do indat endpoints first */
		for (j = 0; j < N_IN_URB; ++j) {
			portdata->in_urbs[j] = zte_setup_urb (serial,
                  	port->bulk_in_endpointAddress, USB_DIR_IN, port,
                  	portdata->in_buffer[j], IN_BUFLEN, zte_indat_callback);
		}

		/* outdat endpoints */
		for (j = 0; j < N_OUT_URB; ++j) {
			portdata->out_urbs[j] = zte_setup_urb (serial,
                  	port->bulk_out_endpointAddress, USB_DIR_OUT, port,
                  	portdata->out_buffer[j], OUT_BUFLEN, zte_outdat_callback);
		}
	}
}

static int zte_send_setup(struct usb_serial_port *port)
{
	struct usb_serial *serial = port->serial;
	struct zte_port_private *portdata;

	dbg("%s", __FUNCTION__);

	portdata = usb_get_serial_port_data(port);

	if (port->tty) {
		int val = 0;
		if (portdata->dtr_state)
			val |= 0x01;
		if (portdata->rts_state)
			val |= 0x02;

		return usb_control_msg(serial->dev,
				usb_rcvctrlpipe(serial->dev, 0),
				0x22,0x21,val,0,NULL,0,USB_CTRL_SET_TIMEOUT);
	}

	return 0;
}

static int zte_startup(struct usb_serial *serial)
{
	int i, err;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;

	dbg("%s", __FUNCTION__);

	/* Now setup per port private data */
	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		portdata = kzalloc(sizeof(*portdata), GFP_KERNEL);
		if (!portdata) {
			dbg("%s: kmalloc for zte_port_private (%d) failed!.",
					__FUNCTION__, i);
			return (1);
		}

		usb_set_serial_port_data(port, portdata);

		if (! port->interrupt_in_urb)
			continue;
		err = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);
		if (err)
			dbg("%s: submit irq_in urb failed %d",
				__FUNCTION__, err);
	}

	zte_setup_urbs(serial);

	return (0);
}

static void zte_shutdown(struct usb_serial *serial)
{
	int i, j;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;

	dbg("%s", __FUNCTION__);

	/* Stop reading/writing urbs */
	for (i = 0; i < serial->num_ports; ++i) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);
		for (j = 0; j < N_IN_URB; j++)
			stop_urb(portdata->in_urbs[j]);
		for (j = 0; j < N_OUT_URB; j++)
			stop_urb(portdata->out_urbs[j]);
	}

	/* Now free them */
	for (i = 0; i < serial->num_ports; ++i) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);

		for (j = 0; j < N_IN_URB; j++) {
			if (portdata->in_urbs[j]) {
				usb_free_urb(portdata->in_urbs[j]);
				portdata->in_urbs[j] = NULL;
			}
		}
		for (j = 0; j < N_OUT_URB; j++) {
			if (portdata->out_urbs[j]) {
				usb_free_urb(portdata->out_urbs[j]);
				portdata->out_urbs[j] = NULL;
			}
		}
	}

	/* Now free per port private data */
	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		kfree(usb_get_serial_port_data(port));
	}
}

MODULE_AUTHOR(DRIVER_AUTHOR);
MODULE_DESCRIPTION(DRIVER_DESC);
MODULE_VERSION(DRIVER_VERSION);
MODULE_LICENSE("GPL");

#ifdef CONFIG_USB_DEBUG
module_param(debug, bool, S_IRUGO | S_IWUSR);
MODULE_PARM_DESC(debug, "Debug messages");
#endif


#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)//use 2.6.21 sourcecode
#include <linux/kernel.h>
#include <linux/jiffies.h>
#include <linux/errno.h>
#include <linux/tty.h>
#include <linux/tty_flip.h>
#include <linux/module.h>
#include <linux/usb.h>
#include <linux/usb/serial.h>

/* Function prototypes */
static int  zte_open(struct usb_serial_port *port, struct file *filp);
static void zte_close(struct usb_serial_port *port, struct file *filp);
static int  zte_startup(struct usb_serial *serial);
static void zte_shutdown(struct usb_serial *serial);
static void zte_rx_throttle(struct usb_serial_port *port);
static void zte_rx_unthrottle(struct usb_serial_port *port);
static int  zte_write_room(struct usb_serial_port *port);

static void zte_instat_callback(struct urb *urb);

static int zte_write(struct usb_serial_port *port,
			const unsigned char *buf, int count);

static int  zte_chars_in_buffer(struct usb_serial_port *port);
static int  zte_ioctl(struct usb_serial_port *port, struct file *file,
			unsigned int cmd, unsigned long arg);
static void zte_set_termios(struct usb_serial_port *port,
				struct ktermios *old);
static void zte_break_ctl(struct usb_serial_port *port, int break_state);
static int  zte_tiocmget(struct usb_serial_port *port, struct file *file);
static int  zte_tiocmset(struct usb_serial_port *port, struct file *file,
				unsigned int set, unsigned int clear);
static int  zte_send_setup(struct usb_serial_port *port);

/* Vendor and product IDs */
#define zte_VENDOR_ID			0x19d2

static struct usb_device_id zte_ids[] = {

    { USB_DEVICE(zte_VENDOR_ID, 0x0001 ) },/*zte*/
    { USB_DEVICE(zte_VENDOR_ID, 0x0002 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0003 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0004 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0005 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0006 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0007 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0008 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0009 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0010 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0011 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0012 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0013 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0014 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0015 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0016 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0017 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0018 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0019 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0020 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0021 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0022 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0023 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0024 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0025 ) },
 //	 { USB_DEVICE(zte_VENDOR_ID, 0x0026 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0027 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0028 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0029 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0030 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0031 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0032 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0033 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0034 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0035 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0036 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0037 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0038 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0039 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0040 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0041 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0042 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0043 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0044 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0045 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0046 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0047 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0048 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0049 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0050 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0051 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0052 ) },
 //	 { USB_DEVICE(zte_VENDOR_ID, 0x0053 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0054 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0055 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0056 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0057 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0058 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0059 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0060 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0061 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0062 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0063 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0064 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0065 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0066 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0067 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0068 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0069 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0070 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0071 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0072 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0073 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0074 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0075 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0076 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0077 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0078 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0079 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0080 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0081 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0082 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0083 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0084 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0085 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0086 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0087 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0088 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0089 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0090 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0091 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0092 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0093 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0094 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0095 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0096 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0097 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0098 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0099 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0104 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0105 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0106 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0108 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0117 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0118 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0121 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0122 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0123 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0124 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0125 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0126 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0128 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0130 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0133 ) },	   
    { USB_DEVICE(zte_VENDOR_ID, 0x0141 ) }, 
    { USB_DEVICE(zte_VENDOR_ID, 0x0144 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0145 ) }, 
    { USB_DEVICE(zte_VENDOR_ID, 0x0147 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0148 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0151 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0152 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0153 ) },
    //{ USB_DEVICE(zte_VENDOR_ID, 0x0154 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0155 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0156 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0157 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0158 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0159 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0160 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0161 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0162 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0164 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0165 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0168 ) },	   
    { USB_DEVICE(zte_VENDOR_ID, 0x0170 ) }, 
    { USB_DEVICE(zte_VENDOR_ID, 0x0176 ) },	   
    { USB_DEVICE(zte_VENDOR_ID, 0x0178 ) }, 	   
    { USB_DEVICE(zte_VENDOR_ID, 0x1008 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1010 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1012 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1057 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1058 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1059 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1060 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1061 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1062 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1063 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1064 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1065 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1066 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1067 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1068 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1069 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1070 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1071 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1072 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1073 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1074 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1075 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1076 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1077 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1078 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1079 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1080 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1081 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1082 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1083 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1084 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1085 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1086 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1087 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1088 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1089 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1090 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1091 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1092 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1093 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1094 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1095 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1096 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1097 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1098 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1099 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1100 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1101 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1102 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1103 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1104 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1105 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1106 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1107 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1108 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1109 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1110 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1111 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1112 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1113 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1114 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1115 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1116 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1117 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1118 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1119 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1120 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1121 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1122 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1123 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1124 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1125 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1126 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1127 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1128 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1129 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1130 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1131 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1132 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1133 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1134 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1135 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1136 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1137 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1138 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1139 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1140 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1141 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1142 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1143 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1144 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1145 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1146 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1147 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1148 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1149 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1150 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1151 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1152 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1153 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1154 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1155 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1156 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1157 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1158 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1159 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1160 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1161 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1162 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1163 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1164 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1165 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1166 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1167 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1168 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1169 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1170 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1244 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1245 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1246 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1247 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1248 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1249 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1250 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1251 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1252 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1253 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1254 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1255 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1256 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1257 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1258 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1259 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1260 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1261 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1262 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1263 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1264 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1265 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1266 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1267 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1268 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1269 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1270 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1271 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1272 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1273 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1274 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1275 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1276 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1277 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1278 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1279 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1280 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1281 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1282 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1283 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1284 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1285 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x1286 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1287 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1288 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1289 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1290 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1291 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1292 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1293 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1294 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1295 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1296 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1297 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1298 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1299 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1300 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1401 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1402 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1403 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1404 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1405 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1406 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1407 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1408 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1409 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1410 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1411 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1412 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1413 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1414 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1415 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1416 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1417 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1418 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1419 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1420 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1421 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1422 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1423 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1424 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1425 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1426 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1427 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1428 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1429 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1430 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1431 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1432 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1433 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1434 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1435 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1436 ) },   
	{ USB_DEVICE(zte_VENDOR_ID, 0x1437 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1438 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1439 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1440 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1441 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1442 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1443 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1444 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1445 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1446 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1447 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1448 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1449 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1450 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1451 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1452 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1453 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1454 ) },	

	{ USB_DEVICE(zte_VENDOR_ID, 0x1455 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1456 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1457 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1458 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1459 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1460 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1461 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1462 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1463 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1464 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1465 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1466 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1467 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1468 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1469 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1470 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1471 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1472 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1473 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1474 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1475 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1476 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1477 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1478 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1479 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1480 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1481 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1482 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1483 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1484 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1485 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1486 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1487 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1488 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1489 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1490 ) },	 
	{ USB_DEVICE(zte_VENDOR_ID, 0x1491 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1492 ) },	 
	{ USB_DEVICE(zte_VENDOR_ID, 0x1493 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1494 ) },	 
	{ USB_DEVICE(zte_VENDOR_ID, 0x1495 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1496 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1497 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1498 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1499 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1500 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1501 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1502 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1503 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1504 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1505 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1506 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1507 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1508 ) },	 
	{ USB_DEVICE(zte_VENDOR_ID, 0x1509 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1510 ) },	   
	{ USB_DEVICE(zte_VENDOR_ID, 0x2002 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x2003 ) },	 
	{ USB_DEVICE(zte_VENDOR_ID, 0xFFEC ) },

    { USB_DEVICE(TPLink_VENDOR_ID, 0x7E11 ) },/*TPLink */
    { USB_DEVICE(QUALCOMM_VENDOR_ID, 0x9001 ) },/*QUALCOMM*/
    { USB_DEVICE(QUALCOMM_VENDOR_ID, 0x9002 ) },

		{ } /* Terminating entry */
	};
MODULE_DEVICE_TABLE(usb, zte_ids);

static struct usb_driver zte_driver = {
	.name       = "zte",
	.probe      = usb_serial_probe,
	.disconnect = usb_serial_disconnect,
	.id_table   = zte_ids,
	.no_dynamic_id = 	1,
};

/* The card has three separate interfaces, which the serial driver
 * recognizes separately, thus num_port=1.
 */

static struct usb_serial_driver zte_1port_device = {
	.driver = {
		.owner =	THIS_MODULE,
		.name =		"zte1",
	},
	.description       = "GSM modem (1-port)",
	.usb_driver        = &zte_driver,
	.id_table          = zte_ids,
	.num_interrupt_in  = NUM_DONT_CARE,
	.num_bulk_in       = NUM_DONT_CARE,
	.num_bulk_out      = NUM_DONT_CARE,
	.num_ports         = 1,
	.open              = zte_open,
	.close             = zte_close,
	.write             = zte_write,
	.write_room        = zte_write_room,
	.chars_in_buffer   = zte_chars_in_buffer,
	.throttle          = zte_rx_throttle,
	.unthrottle        = zte_rx_unthrottle,
	.ioctl             = zte_ioctl,
	.set_termios       = zte_set_termios,
	.break_ctl         = zte_break_ctl,
	.tiocmget          = zte_tiocmget,
	.tiocmset          = zte_tiocmset,
	.attach            = zte_startup,
	.shutdown          = zte_shutdown,
	.read_int_callback = zte_instat_callback,
};

#ifdef CONFIG_USB_DEBUG
static int debug;
#else
#define debug 0
#endif

/* per port private data */

#define N_IN_URB 4
#define N_OUT_URB 1
#define IN_BUFLEN 4096
#define OUT_BUFLEN 128

struct zte_port_private {
	/* Input endpoints and buffer for this port */
	struct urb *in_urbs[N_IN_URB];
	char in_buffer[N_IN_URB][IN_BUFLEN];
	/* Output endpoints and buffer for this port */
	struct urb *out_urbs[N_OUT_URB];
	char out_buffer[N_OUT_URB][OUT_BUFLEN];

	/* Settings for the port */
	int rts_state;	/* Handshaking pins (outputs) */
	int dtr_state;
	int cts_state;	/* Handshaking pins (inputs) */
	int dsr_state;
	int dcd_state;
	int ri_state;

	unsigned long tx_start_time[N_OUT_URB];
};

/* Functions used by new usb-serial code. */
static int __init zte_init(void)
{
	int retval;
	retval = usb_serial_register(&zte_1port_device);
	if (retval)
		goto failed_1port_device_register;
	retval = usb_register(&zte_driver);
	if (retval)
		goto failed_driver_register;

	info(DRIVER_DESC ": " DRIVER_VERSION);

	return 0;

failed_driver_register:
	usb_serial_deregister (&zte_1port_device);
failed_1port_device_register:
	return retval;
}

static void __exit zte_exit(void)
{
	usb_deregister (&zte_driver);
	usb_serial_deregister (&zte_1port_device);
}

module_init(zte_init);
module_exit(zte_exit);

static void zte_rx_throttle(struct usb_serial_port *port)
{
	dbg("%s", __FUNCTION__);
}

static void zte_rx_unthrottle(struct usb_serial_port *port)
{
	dbg("%s", __FUNCTION__);
}

static void zte_break_ctl(struct usb_serial_port *port, int break_state)
{
	/* Unfortunately, I don't know how to send a break */
	dbg("%s", __FUNCTION__);
}

static void zte_set_termios(struct usb_serial_port *port,
			struct ktermios *old_termios)
{
	dbg("%s", __FUNCTION__);

	zte_send_setup(port);
}

static int zte_tiocmget(struct usb_serial_port *port, struct file *file)
{
	unsigned int value;
	struct zte_port_private *portdata;

	portdata = usb_get_serial_port_data(port);

	value = ((portdata->rts_state) ? TIOCM_RTS : 0) |
		((portdata->dtr_state) ? TIOCM_DTR : 0) |
		((portdata->cts_state) ? TIOCM_CTS : 0) |
		((portdata->dsr_state) ? TIOCM_DSR : 0) |
		((portdata->dcd_state) ? TIOCM_CAR : 0) |
		((portdata->ri_state) ? TIOCM_RNG : 0);

	return value;
}

static int zte_tiocmset(struct usb_serial_port *port, struct file *file,
			unsigned int set, unsigned int clear)
{
	struct zte_port_private *portdata;

	portdata = usb_get_serial_port_data(port);

	if (set & TIOCM_RTS)
		portdata->rts_state = 1;
	if (set & TIOCM_DTR)
		portdata->dtr_state = 1;

	if (clear & TIOCM_RTS)
		portdata->rts_state = 0;
	if (clear & TIOCM_DTR)
		portdata->dtr_state = 0;
	return zte_send_setup(port);
}

static int zte_ioctl(struct usb_serial_port *port, struct file *file,
			unsigned int cmd, unsigned long arg)
{
	return -ENOIOCTLCMD;
}

/* Write */
static int zte_write(struct usb_serial_port *port,
			const unsigned char *buf, int count)
{
	struct zte_port_private *portdata;
	int i;
	int left, todo;
	struct urb *this_urb = NULL; /* spurious */
	int err;

	portdata = usb_get_serial_port_data(port);

	dbg("%s: write (%d chars)", __FUNCTION__, count);

	i = 0;
	left = count;
	for (i=0; left > 0 && i < N_OUT_URB; i++) {
		todo = left;
		if (todo > OUT_BUFLEN)
			todo = OUT_BUFLEN;

		this_urb = portdata->out_urbs[i];
		if (this_urb->status == -EINPROGRESS) {
			if (time_before(jiffies,
					portdata->tx_start_time[i] + 10 * HZ))
				continue;
			usb_unlink_urb(this_urb);
			continue;
		}
		if (this_urb->status != 0)
			dbg("usb_write %p failed (err=%d)",
				this_urb, this_urb->status);

		dbg("%s: endpoint %d buf %d", __FUNCTION__,
			usb_pipeendpoint(this_urb->pipe), i);

		/* send the data */
		memcpy (this_urb->transfer_buffer, buf, todo);
		this_urb->transfer_buffer_length = todo;

		this_urb->dev = port->serial->dev;
		err = usb_submit_urb(this_urb, GFP_ATOMIC);
		if (err) {
			dbg("usb_submit_urb %p (write bulk) failed "
				"(%d, has %d)", this_urb,
				err, this_urb->status);
			continue;
		}
		portdata->tx_start_time[i] = jiffies;
		buf += todo;
		left -= todo;
	}

	count -= left;
	dbg("%s: wrote (did %d)", __FUNCTION__, count);
	return count;
}

static void zte_indat_callback(struct urb *urb)
{
	int err;
	int endpoint;
	struct usb_serial_port *port;
	struct tty_struct *tty;
	unsigned char *data = urb->transfer_buffer;

	dbg("%s: %p", __FUNCTION__, urb);

	endpoint = usb_pipeendpoint(urb->pipe);
	port = (struct usb_serial_port *) urb->context;

	if (urb->status) {
		dbg("%s: nonzero status: %d on endpoint %02x.",
		    __FUNCTION__, urb->status, endpoint);
	} else {
		tty = port->tty;
		if (urb->actual_length) {
			tty_buffer_request_room(tty, urb->actual_length);
			tty_insert_flip_string(tty, data, urb->actual_length);
			tty_flip_buffer_push(tty);
		} else {
			dbg("%s: empty read urb received", __FUNCTION__);
		}

		/* Resubmit urb so we continue receiving */
		if (port->open_count && urb->status != -ESHUTDOWN) {
			err = usb_submit_urb(urb, GFP_ATOMIC);
			if (err)
				printk(KERN_ERR "%s: resubmit read urb failed. "
					"(%d)", __FUNCTION__, err);
		}
	}
	return;
}

static void zte_outdat_callback(struct urb *urb)
{
	struct usb_serial_port *port;

	dbg("%s", __FUNCTION__);

	port = (struct usb_serial_port *) urb->context;

	usb_serial_port_softint(port);
}

static void zte_instat_callback(struct urb *urb)
{
	int err;
	struct usb_serial_port *port = (struct usb_serial_port *) urb->context;
	struct zte_port_private *portdata = usb_get_serial_port_data(port);
	struct usb_serial *serial = port->serial;

	dbg("%s", __FUNCTION__);
	dbg("%s: urb %p port %p has data %p", __FUNCTION__,urb,port,portdata);

	if (urb->status == 0) {
		struct usb_ctrlrequest *req_pkt =
				(struct usb_ctrlrequest *)urb->transfer_buffer;

		if (!req_pkt) {
			dbg("%s: NULL req_pkt\n", __FUNCTION__);
			return;
		}
		if ((req_pkt->bRequestType == 0xA1) &&
				(req_pkt->bRequest == 0x20)) {
			int old_dcd_state;
			unsigned char signals = *((unsigned char *)
					urb->transfer_buffer +
					sizeof(struct usb_ctrlrequest));

			dbg("%s: signal x%x", __FUNCTION__, signals);

			old_dcd_state = portdata->dcd_state;
			portdata->cts_state = 1;
			portdata->dcd_state = ((signals & 0x01) ? 1 : 0);
			portdata->dsr_state = ((signals & 0x02) ? 1 : 0);
			portdata->ri_state = ((signals & 0x08) ? 1 : 0);

			if (port->tty && !C_CLOCAL(port->tty) &&
					old_dcd_state && !portdata->dcd_state)
				tty_hangup(port->tty);
		} else {
			dbg("%s: type %x req %x", __FUNCTION__,
				req_pkt->bRequestType,req_pkt->bRequest);
		}
	} else
		dbg("%s: error %d", __FUNCTION__, urb->status);

	/* Resubmit urb so we continue receiving IRQ data */
	if (urb->status != -ESHUTDOWN) {
		urb->dev = serial->dev;
		err = usb_submit_urb(urb, GFP_ATOMIC);
		if (err)
			dbg("%s: resubmit intr urb failed. (%d)",
				__FUNCTION__, err);
	}
}

static int zte_write_room(struct usb_serial_port *port)
{
	struct zte_port_private *portdata;
	int i;
	int data_len = 0;
	struct urb *this_urb;

	portdata = usb_get_serial_port_data(port);

	for (i=0; i < N_OUT_URB; i++) {
		this_urb = portdata->out_urbs[i];
		if (this_urb && this_urb->status != -EINPROGRESS)
			data_len += OUT_BUFLEN;
	}

	dbg("%s: %d", __FUNCTION__, data_len);
	return data_len;
}

static int zte_chars_in_buffer(struct usb_serial_port *port)
{
	struct zte_port_private *portdata;
	int i;
	int data_len = 0;
	struct urb *this_urb;

	portdata = usb_get_serial_port_data(port);

	for (i=0; i < N_OUT_URB; i++) {
		this_urb = portdata->out_urbs[i];
		if (this_urb && this_urb->status == -EINPROGRESS)
			data_len += this_urb->transfer_buffer_length;
	}
	dbg("%s: %d", __FUNCTION__, data_len);
	return data_len;
}

static int zte_open(struct usb_serial_port *port, struct file *filp)
{
	struct zte_port_private *portdata;
	struct usb_serial *serial = port->serial;
	int i, err;
	struct urb *urb;

	portdata = usb_get_serial_port_data(port);

	dbg("%s", __FUNCTION__);

	/* Set some sane defaults */
	portdata->rts_state = 1;
	portdata->dtr_state = 1;

	/* Reset low level data toggle and start reading from endpoints */
	for (i = 0; i < N_IN_URB; i++) {
		urb = portdata->in_urbs[i];
		if (! urb)
			continue;
		if (urb->dev != serial->dev) {
			dbg("%s: dev %p != %p", __FUNCTION__,
				urb->dev, serial->dev);
			continue;
		}

		/*
		 * make sure endpoint data toggle is synchronized with the
		 * device
		 */
		usb_clear_halt(urb->dev, urb->pipe);

		err = usb_submit_urb(urb, GFP_KERNEL);
		if (err) {
			dbg("%s: submit urb %d failed (%d) %d",
				__FUNCTION__, i, err,
				urb->transfer_buffer_length);
		}
	}

	/* Reset low level data toggle on out endpoints */
	for (i = 0; i < N_OUT_URB; i++) {
		urb = portdata->out_urbs[i];
		if (! urb)
			continue;
		urb->dev = serial->dev;
		/* usb_settoggle(urb->dev, usb_pipeendpoint(urb->pipe),
				usb_pipeout(urb->pipe), 0); */
	}

	port->tty->low_latency = 1;

	zte_send_setup(port);

	return (0);
}

static inline void stop_urb(struct urb *urb)
{
	if (urb && urb->status == -EINPROGRESS)
		usb_kill_urb(urb);
}

static void zte_close(struct usb_serial_port *port, struct file *filp)
{
	int i;
	struct usb_serial *serial = port->serial;
	struct zte_port_private *portdata;

	dbg("%s", __FUNCTION__);
	portdata = usb_get_serial_port_data(port);

	portdata->rts_state = 0;
	portdata->dtr_state = 0;

	if (serial->dev) {
		zte_send_setup(port);

		/* Stop reading/writing urbs */
		for (i = 0; i < N_IN_URB; i++)
			stop_urb(portdata->in_urbs[i]);
		for (i = 0; i < N_OUT_URB; i++)
			stop_urb(portdata->out_urbs[i]);
	}
	port->tty = NULL;
}

/* Helper functions used by zte_setup_urbs */
static struct urb *zte_setup_urb(struct usb_serial *serial, int endpoint,
		int dir, void *ctx, char *buf, int len,
		void (*callback)(struct urb *))
{
	struct urb *urb;

	if (endpoint == -1)
		return NULL;		/* endpoint not needed */

	urb = usb_alloc_urb(0, GFP_KERNEL);		/* No ISO */
	if (urb == NULL) {
		dbg("%s: alloc for endpoint %d failed.", __FUNCTION__, endpoint);
		return NULL;
	}

		/* Fill URB using supplied data. */
	usb_fill_bulk_urb(urb, serial->dev,
		      usb_sndbulkpipe(serial->dev, endpoint) | dir,
		      buf, len, callback, ctx);

	return urb;
}

/* Setup urbs */
static void zte_setup_urbs(struct usb_serial *serial)
{
	int i,j;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;

	dbg("%s", __FUNCTION__);

	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);

	/* Do indat endpoints first */
		for (j = 0; j < N_IN_URB; ++j) {
			portdata->in_urbs[j] = zte_setup_urb (serial,
                  	port->bulk_in_endpointAddress, USB_DIR_IN, port,
                  	portdata->in_buffer[j], IN_BUFLEN, zte_indat_callback);
		}

		/* outdat endpoints */
		for (j = 0; j < N_OUT_URB; ++j) {
			portdata->out_urbs[j] = zte_setup_urb (serial,
                  	port->bulk_out_endpointAddress, USB_DIR_OUT, port,
                  	portdata->out_buffer[j], OUT_BUFLEN, zte_outdat_callback);
		}
	}
}

static int zte_send_setup(struct usb_serial_port *port)
{
	struct usb_serial *serial = port->serial;
	struct zte_port_private *portdata;

	dbg("%s", __FUNCTION__);

	if (port->number != 0)
		return 0;

	portdata = usb_get_serial_port_data(port);

	if (port->tty) {
		int val = 0;
		if (portdata->dtr_state)
			val |= 0x01;
		if (portdata->rts_state)
			val |= 0x02;

		return usb_control_msg(serial->dev,
				usb_rcvctrlpipe(serial->dev, 0),
				0x22,0x21,val,0,NULL,0,USB_CTRL_SET_TIMEOUT);
	}

	return 0;
}

static int zte_startup(struct usb_serial *serial)
{
	int i, err;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;

	dbg("%s", __FUNCTION__);

	/* Now setup per port private data */
	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		portdata = kzalloc(sizeof(*portdata), GFP_KERNEL);
		if (!portdata) {
			dbg("%s: kmalloc for zte_port_private (%d) failed!.",
					__FUNCTION__, i);
			return (1);
		}

		usb_set_serial_port_data(port, portdata);

		if (! port->interrupt_in_urb)
			continue;
		err = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);
		if (err)
			dbg("%s: submit irq_in urb failed %d",
				__FUNCTION__, err);
	}

	zte_setup_urbs(serial);

	return (0);
}

static void zte_shutdown(struct usb_serial *serial)
{
	int i, j;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;

	dbg("%s", __FUNCTION__);

	/* Stop reading/writing urbs */
	for (i = 0; i < serial->num_ports; ++i) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);
		for (j = 0; j < N_IN_URB; j++)
			stop_urb(portdata->in_urbs[j]);
		for (j = 0; j < N_OUT_URB; j++)
			stop_urb(portdata->out_urbs[j]);
	}

	/* Now free them */
	for (i = 0; i < serial->num_ports; ++i) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);

		for (j = 0; j < N_IN_URB; j++) {
			if (portdata->in_urbs[j]) {
				usb_free_urb(portdata->in_urbs[j]);
				portdata->in_urbs[j] = NULL;
			}
		}
		for (j = 0; j < N_OUT_URB; j++) {
			if (portdata->out_urbs[j]) {
				usb_free_urb(portdata->out_urbs[j]);
				portdata->out_urbs[j] = NULL;
			}
		}
	}

	/* Now free per port private data */
	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		kfree(usb_get_serial_port_data(port));
	}
}

MODULE_AUTHOR(DRIVER_AUTHOR);
MODULE_DESCRIPTION(DRIVER_DESC);
MODULE_VERSION(DRIVER_VERSION);
MODULE_LICENSE("GPL");

#ifdef CONFIG_USB_DEBUG
module_param(debug, bool, S_IRUGO | S_IWUSR);
MODULE_PARM_DESC(debug, "Debug messages");
#endif

#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)//use 2.6.22 sourcecode
#include <linux/kernel.h>
#include <linux/jiffies.h>
#include <linux/errno.h>
#include <linux/tty.h>
#include <linux/tty_flip.h>
#include <linux/module.h>
#include <linux/usb.h>
#include <linux/usb/serial.h>

/* Function prototypes */
static int  zte_open(struct usb_serial_port *port, struct file *filp);
static void zte_close(struct usb_serial_port *port, struct file *filp);
static int  zte_startup(struct usb_serial *serial);
static void zte_shutdown(struct usb_serial *serial);
static void zte_rx_throttle(struct usb_serial_port *port);
static void zte_rx_unthrottle(struct usb_serial_port *port);
static int  zte_write_room(struct usb_serial_port *port);

static void zte_instat_callback(struct urb *urb);

static int zte_write(struct usb_serial_port *port,
			const unsigned char *buf, int count);

static int  zte_chars_in_buffer(struct usb_serial_port *port);
static int  zte_ioctl(struct usb_serial_port *port, struct file *file,
			unsigned int cmd, unsigned long arg);
static void zte_set_termios(struct usb_serial_port *port,
				struct ktermios *old);
static void zte_break_ctl(struct usb_serial_port *port, int break_state);
static int  zte_tiocmget(struct usb_serial_port *port, struct file *file);
static int  zte_tiocmset(struct usb_serial_port *port, struct file *file,
				unsigned int set, unsigned int clear);
static int  zte_send_setup(struct usb_serial_port *port);

/* Vendor and product IDs */
#define zte_VENDOR_ID			0x19d2

static struct usb_device_id zte_ids[] = {

    { USB_DEVICE(zte_VENDOR_ID, 0x0001 ) },/*zte*/
    { USB_DEVICE(zte_VENDOR_ID, 0x0002 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0003 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0004 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0005 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0006 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0007 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0008 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0009 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0010 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0011 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0012 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0013 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0014 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0015 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0016 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0017 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0018 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0019 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0020 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0021 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0022 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0023 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0024 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0025 ) },
 //	 { USB_DEVICE(zte_VENDOR_ID, 0x0026 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0027 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0028 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0029 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0030 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0031 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0032 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0033 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0034 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0035 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0036 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0037 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0038 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0039 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0040 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0041 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0042 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0043 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0044 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0045 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0046 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0047 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0048 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0049 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0050 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0051 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0052 ) },
 //	 { USB_DEVICE(zte_VENDOR_ID, 0x0053 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0054 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0055 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0056 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0057 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0058 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0059 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0060 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0061 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0062 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0063 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0064 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0065 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0066 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0067 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0068 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0069 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0070 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0071 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0072 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0073 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0074 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0075 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0076 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0077 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0078 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0079 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0080 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0081 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0082 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0083 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0084 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0085 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0086 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0087 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0088 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0089 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0090 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0091 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0092 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0093 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0094 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0095 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0096 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0097 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0098 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0099 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0104 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0105 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0106 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0108 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0117 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0118 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0121 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0122 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0123 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0124 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0125 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0126 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0128 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0130 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0133 ) },	   
    { USB_DEVICE(zte_VENDOR_ID, 0x0141 ) }, 
    { USB_DEVICE(zte_VENDOR_ID, 0x0144 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0145 ) }, 
    { USB_DEVICE(zte_VENDOR_ID, 0x0147 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0148 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0151 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0152 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0153 ) },
    //{ USB_DEVICE(zte_VENDOR_ID, 0x0154 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0155 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0156 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0157 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0158 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0159 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0160 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0161 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0162 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0164 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0165 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x0168 ) },	   
    { USB_DEVICE(zte_VENDOR_ID, 0x0170 ) }, 
    { USB_DEVICE(zte_VENDOR_ID, 0x0176 ) },	   
    { USB_DEVICE(zte_VENDOR_ID, 0x0178 ) }, 	   
    { USB_DEVICE(zte_VENDOR_ID, 0x1008 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1010 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1012 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1057 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1058 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1059 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1060 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1061 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1062 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1063 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1064 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1065 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1066 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1067 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1068 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1069 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1070 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1071 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1072 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1073 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1074 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1075 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1076 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1077 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1078 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1079 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1080 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1081 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1082 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1083 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1084 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1085 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1086 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1087 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1088 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1089 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1090 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1091 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1092 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1093 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1094 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1095 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1096 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1097 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1098 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1099 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1100 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1101 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1102 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1103 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1104 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1105 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1106 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1107 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1108 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1109 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1110 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1111 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1112 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1113 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1114 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1115 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1116 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1117 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1118 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1119 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1120 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1121 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1122 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1123 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1124 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1125 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1126 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1127 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1128 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1129 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1130 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1131 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1132 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1133 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1134 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1135 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1136 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1137 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1138 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1139 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1140 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1141 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1142 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1143 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1144 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1145 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1146 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1147 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1148 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1149 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1150 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1151 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1152 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1153 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1154 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1155 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1156 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1157 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1158 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1159 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1160 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1161 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1162 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1163 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1164 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1165 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1166 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1167 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1168 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1169 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1170 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1244 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1245 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1246 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1247 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1248 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1249 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1250 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1251 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1252 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1253 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1254 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1255 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1256 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1257 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1258 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1259 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1260 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1261 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1262 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1263 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1264 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1265 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1266 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1267 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1268 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1269 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1270 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1271 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1272 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1273 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1274 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1275 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1276 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1277 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1278 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1279 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1280 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1281 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1282 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1283 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1284 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1285 ) },
    { USB_DEVICE(zte_VENDOR_ID, 0x1286 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1287 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1288 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1289 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1290 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1291 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1292 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1293 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1294 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1295 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1296 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1297 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1298 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1299 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1300 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1401 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1402 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1403 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1404 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1405 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1406 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1407 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1408 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1409 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1410 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1411 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1412 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1413 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1414 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1415 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1416 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1417 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1418 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1419 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1420 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1421 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1422 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1423 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1424 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1425 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1426 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1427 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1428 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1429 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1430 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1431 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1432 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1433 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1434 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1435 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1436 ) },   
	{ USB_DEVICE(zte_VENDOR_ID, 0x1437 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1438 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1439 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1440 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1441 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1442 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1443 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1444 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1445 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1446 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1447 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1448 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1449 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1450 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1451 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1452 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1453 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1454 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1455 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1456 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1457 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1458 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1459 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1460 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1461 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1462 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1463 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1464 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1465 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1466 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1467 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1468 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1469 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1470 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1471 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1472 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1473 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1474 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1475 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1476 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1477 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1478 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1479 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1480 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1481 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1482 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1483 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1484 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1485 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1486 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1487 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1488 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1489 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1490 ) },	 
	{ USB_DEVICE(zte_VENDOR_ID, 0x1491 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1492 ) },	 
	{ USB_DEVICE(zte_VENDOR_ID, 0x1493 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1494 ) },	 
	{ USB_DEVICE(zte_VENDOR_ID, 0x1495 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1496 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1497 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1498 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x1499 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1500 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1501 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1502 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1503 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1504 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1505 ) },	
	{ USB_DEVICE(zte_VENDOR_ID, 0x1506 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1507 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1508 ) },	 
	{ USB_DEVICE(zte_VENDOR_ID, 0x1509 ) },  
	{ USB_DEVICE(zte_VENDOR_ID, 0x1510 ) },	   
	{ USB_DEVICE(zte_VENDOR_ID, 0x2002 ) },
	{ USB_DEVICE(zte_VENDOR_ID, 0x2003 ) },	 
	{ USB_DEVICE(zte_VENDOR_ID, 0xFFEC ) },

    { USB_DEVICE(TPLink_VENDOR_ID, 0x7E11 ) },/*TPLink */
    { USB_DEVICE(QUALCOMM_VENDOR_ID, 0x9001 ) },/*QUALCOMM*/
    { USB_DEVICE(QUALCOMM_VENDOR_ID, 0x9002 ) },

		{ } /* Terminating entry */
	};
MODULE_DEVICE_TABLE(usb, zte_ids);

static struct usb_driver zte_driver = {
	.name       = "zte",
	.probe      = usb_serial_probe,
	.disconnect = usb_serial_disconnect,
	.id_table   = zte_ids,
	.no_dynamic_id = 	1,
};

/* The card has three separate interfaces, which the serial driver
 * recognizes separately, thus num_port=1.
 */

static struct usb_serial_driver zte_1port_device = {
	.driver = {
		.owner =	THIS_MODULE,
		.name =		"zte1",
	},
	.description       = "GSM modem (1-port)",
	.usb_driver        = &zte_driver,
	.id_table          = zte_ids,
	.num_interrupt_in  = NUM_DONT_CARE,
	.num_bulk_in       = NUM_DONT_CARE,
	.num_bulk_out      = NUM_DONT_CARE,
	.num_ports         = 1,
	.open              = zte_open,
	.close             = zte_close,
	.write             = zte_write,
	.write_room        = zte_write_room,
	.chars_in_buffer   = zte_chars_in_buffer,
	.throttle          = zte_rx_throttle,
	.unthrottle        = zte_rx_unthrottle,
	.ioctl             = zte_ioctl,
	.set_termios       = zte_set_termios,
	.break_ctl         = zte_break_ctl,
	.tiocmget          = zte_tiocmget,
	.tiocmset          = zte_tiocmset,
	.attach            = zte_startup,
	.shutdown          = zte_shutdown,
	.read_int_callback = zte_instat_callback,
};

#ifdef CONFIG_USB_DEBUG
static int debug;
#else
#define debug 0
#endif

/* per port private data */

#define N_IN_URB 4
#define N_OUT_URB 4
#define IN_BUFLEN 4096
#define OUT_BUFLEN 4096

struct zte_port_private {
	/* Input endpoints and buffer for this port */
	struct urb *in_urbs[N_IN_URB];
	char in_buffer[N_IN_URB][IN_BUFLEN];
	/* Output endpoints and buffer for this port */
	struct urb *out_urbs[N_OUT_URB];
	char out_buffer[N_OUT_URB][OUT_BUFLEN];

	/* Settings for the port */
	int rts_state;	/* Handshaking pins (outputs) */
	int dtr_state;
	int cts_state;	/* Handshaking pins (inputs) */
	int dsr_state;
	int dcd_state;
	int ri_state;

	unsigned long tx_start_time[N_OUT_URB];
};

/* Functions used by new usb-serial code. */
static int __init zte_init(void)
{
	int retval;
	retval = usb_serial_register(&zte_1port_device);
	if (retval)
		goto failed_1port_device_register;
	retval = usb_register(&zte_driver);
	if (retval)
		goto failed_driver_register;

	info(DRIVER_DESC ": " DRIVER_VERSION);

	return 0;

failed_driver_register:
	usb_serial_deregister (&zte_1port_device);
failed_1port_device_register:
	return retval;
}

static void __exit zte_exit(void)
{
	usb_deregister (&zte_driver);
	usb_serial_deregister (&zte_1port_device);
}

module_init(zte_init);
module_exit(zte_exit);

static void zte_rx_throttle(struct usb_serial_port *port)
{
	dbg("%s", __FUNCTION__);
}

static void zte_rx_unthrottle(struct usb_serial_port *port)
{
	dbg("%s", __FUNCTION__);
}

static void zte_break_ctl(struct usb_serial_port *port, int break_state)
{
	/* Unfortunately, I don't know how to send a break */
	dbg("%s", __FUNCTION__);
}

static void zte_set_termios(struct usb_serial_port *port,
			struct ktermios *old_termios)
{
	dbg("%s", __FUNCTION__);

	zte_send_setup(port);
}

static int zte_tiocmget(struct usb_serial_port *port, struct file *file)
{
	unsigned int value;
	struct zte_port_private *portdata;

	portdata = usb_get_serial_port_data(port);

	value = ((portdata->rts_state) ? TIOCM_RTS : 0) |
		((portdata->dtr_state) ? TIOCM_DTR : 0) |
		((portdata->cts_state) ? TIOCM_CTS : 0) |
		((portdata->dsr_state) ? TIOCM_DSR : 0) |
		((portdata->dcd_state) ? TIOCM_CAR : 0) |
		((portdata->ri_state) ? TIOCM_RNG : 0);

	return value;
}

static int zte_tiocmset(struct usb_serial_port *port, struct file *file,
			unsigned int set, unsigned int clear)
{
	struct zte_port_private *portdata;

	portdata = usb_get_serial_port_data(port);

	if (set & TIOCM_RTS)
		portdata->rts_state = 1;
	if (set & TIOCM_DTR)
		portdata->dtr_state = 1;

	if (clear & TIOCM_RTS)
		portdata->rts_state = 0;
	if (clear & TIOCM_DTR)
		portdata->dtr_state = 0;
	return zte_send_setup(port);
}

static int zte_ioctl(struct usb_serial_port *port, struct file *file,
			unsigned int cmd, unsigned long arg)
{
	return -ENOIOCTLCMD;
}

/* Write */
static int zte_write(struct usb_serial_port *port,
			const unsigned char *buf, int count)
{
	struct zte_port_private *portdata;
	int i;
	int left, todo;
	struct urb *this_urb = NULL; /* spurious */
	int err;

	portdata = usb_get_serial_port_data(port);

	dbg("%s: write (%d chars)", __FUNCTION__, count);

	i = 0;
	left = count;
	for (i=0; left > 0 && i < N_OUT_URB; i++) {
		todo = left;
		if (todo > OUT_BUFLEN)
			todo = OUT_BUFLEN;

		this_urb = portdata->out_urbs[i];
		if (this_urb->status == -EINPROGRESS) {
			if (time_before(jiffies,
					portdata->tx_start_time[i] + 10 * HZ))
				continue;
			usb_unlink_urb(this_urb);
			continue;
		}
		if (this_urb->status != 0)
			dbg("usb_write %p failed (err=%d)",
				this_urb, this_urb->status);

		dbg("%s: endpoint %d buf %d", __FUNCTION__,
			usb_pipeendpoint(this_urb->pipe), i);

		/* send the data */
		memcpy (this_urb->transfer_buffer, buf, todo);
		this_urb->transfer_buffer_length = todo;

		this_urb->dev = port->serial->dev;
		err = usb_submit_urb(this_urb, GFP_ATOMIC);
		if (err) {
			dbg("usb_submit_urb %p (write bulk) failed "
				"(%d, has %d)", this_urb,
				err, this_urb->status);
			continue;
		}
		portdata->tx_start_time[i] = jiffies;
		buf += todo;
		left -= todo;
	}

	count -= left;
	dbg("%s: wrote (did %d)", __FUNCTION__, count);
	return count;
}

static void zte_indat_callback(struct urb *urb)
{
	int err;
	int endpoint;
	struct usb_serial_port *port;
	struct tty_struct *tty;
	unsigned char *data = urb->transfer_buffer;

	dbg("%s: %p", __FUNCTION__, urb);

	endpoint = usb_pipeendpoint(urb->pipe);
	port = (struct usb_serial_port *) urb->context;

	if (urb->status) {
		dbg("%s: nonzero status: %d on endpoint %02x.",
		    __FUNCTION__, urb->status, endpoint);
	} else {
		tty = port->tty;
		if (urb->actual_length) {
			tty_buffer_request_room(tty, urb->actual_length);
			tty_insert_flip_string(tty, data, urb->actual_length);
			tty_flip_buffer_push(tty);
		} else {
			dbg("%s: empty read urb received", __FUNCTION__);
		}

		/* Resubmit urb so we continue receiving */
		if (port->open_count && urb->status != -ESHUTDOWN) {
			err = usb_submit_urb(urb, GFP_ATOMIC);
			if (err)
				printk(KERN_ERR "%s: resubmit read urb failed. "
					"(%d)", __FUNCTION__, err);
		}
	}
	return;
}

static void zte_outdat_callback(struct urb *urb)
{
	struct usb_serial_port *port;

	dbg("%s", __FUNCTION__);

	port = (struct usb_serial_port *) urb->context;

	usb_serial_port_softint(port);
}

static void zte_instat_callback(struct urb *urb)
{
	int err;
	struct usb_serial_port *port = (struct usb_serial_port *) urb->context;
	struct zte_port_private *portdata = usb_get_serial_port_data(port);
	struct usb_serial *serial = port->serial;

	dbg("%s", __FUNCTION__);
	dbg("%s: urb %p port %p has data %p", __FUNCTION__,urb,port,portdata);

	if (urb->status == 0) {
		struct usb_ctrlrequest *req_pkt =
				(struct usb_ctrlrequest *)urb->transfer_buffer;

		if (!req_pkt) {
			dbg("%s: NULL req_pkt\n", __FUNCTION__);
			return;
		}
		if ((req_pkt->bRequestType == 0xA1) &&
				(req_pkt->bRequest == 0x20)) {
			int old_dcd_state;
			unsigned char signals = *((unsigned char *)
					urb->transfer_buffer +
					sizeof(struct usb_ctrlrequest));

			dbg("%s: signal x%x", __FUNCTION__, signals);

			old_dcd_state = portdata->dcd_state;
			portdata->cts_state = 1;
			portdata->dcd_state = ((signals & 0x01) ? 1 : 0);
			portdata->dsr_state = ((signals & 0x02) ? 1 : 0);
			portdata->ri_state = ((signals & 0x08) ? 1 : 0);

			if (port->tty && !C_CLOCAL(port->tty) &&
					old_dcd_state && !portdata->dcd_state)
				tty_hangup(port->tty);
		} else {
			dbg("%s: type %x req %x", __FUNCTION__,
				req_pkt->bRequestType,req_pkt->bRequest);
		}
	} else
		dbg("%s: error %d", __FUNCTION__, urb->status);

	/* Resubmit urb so we continue receiving IRQ data */
	if (urb->status != -ESHUTDOWN) {
		urb->dev = serial->dev;
		err = usb_submit_urb(urb, GFP_ATOMIC);
		if (err)
			dbg("%s: resubmit intr urb failed. (%d)",
				__FUNCTION__, err);
	}
}

static int zte_write_room(struct usb_serial_port *port)
{
	struct zte_port_private *portdata;
	int i;
	int data_len = 0;
	struct urb *this_urb;

	portdata = usb_get_serial_port_data(port);

	for (i=0; i < N_OUT_URB; i++) {
		this_urb = portdata->out_urbs[i];
		if (this_urb && this_urb->status != -EINPROGRESS)
			data_len += OUT_BUFLEN;
	}

	dbg("%s: %d", __FUNCTION__, data_len);
	return data_len;
}

static int zte_chars_in_buffer(struct usb_serial_port *port)
{
	struct zte_port_private *portdata;
	int i;
	int data_len = 0;
	struct urb *this_urb;

	portdata = usb_get_serial_port_data(port);

	for (i=0; i < N_OUT_URB; i++) {
		this_urb = portdata->out_urbs[i];
		if (this_urb && this_urb->status == -EINPROGRESS)
			data_len += this_urb->transfer_buffer_length;
	}
	dbg("%s: %d", __FUNCTION__, data_len);
	return data_len;
}

static int zte_open(struct usb_serial_port *port, struct file *filp)
{
	struct zte_port_private *portdata;
	struct usb_serial *serial = port->serial;
	int i, err;
	struct urb *urb;

	portdata = usb_get_serial_port_data(port);

	dbg("%s", __FUNCTION__);

	/* Set some sane defaults */
	portdata->rts_state = 1;
	portdata->dtr_state = 1;

	/* Reset low level data toggle and start reading from endpoints */
	for (i = 0; i < N_IN_URB; i++) {
		urb = portdata->in_urbs[i];
		if (! urb)
			continue;
		if (urb->dev != serial->dev) {
			dbg("%s: dev %p != %p", __FUNCTION__,
				urb->dev, serial->dev);
			continue;
		}

		/*
		 * make sure endpoint data toggle is synchronized with the
		 * device
		 */
		usb_clear_halt(urb->dev, urb->pipe);

		err = usb_submit_urb(urb, GFP_KERNEL);
		if (err) {
			dbg("%s: submit urb %d failed (%d) %d",
				__FUNCTION__, i, err,
				urb->transfer_buffer_length);
		}
	}

	/* Reset low level data toggle on out endpoints */
	for (i = 0; i < N_OUT_URB; i++) {
		urb = portdata->out_urbs[i];
		if (! urb)
			continue;
		urb->dev = serial->dev;
		/* usb_settoggle(urb->dev, usb_pipeendpoint(urb->pipe),
				usb_pipeout(urb->pipe), 0); */
	}

	port->tty->low_latency = 1;

	zte_send_setup(port);

	return (0);
}

static void zte_close(struct usb_serial_port *port, struct file *filp)
{
	int i;
	struct usb_serial *serial = port->serial;
	struct zte_port_private *portdata;

	dbg("%s", __FUNCTION__);
	portdata = usb_get_serial_port_data(port);

	portdata->rts_state = 0;
	portdata->dtr_state = 0;

	if (serial->dev) {
		zte_send_setup(port);

		/* Stop reading/writing urbs */
		for (i = 0; i < N_IN_URB; i++)
			usb_kill_urb(portdata->in_urbs[i]);
		for (i = 0; i < N_OUT_URB; i++)
			usb_kill_urb(portdata->out_urbs[i]);
	}
	port->tty = NULL;
}

/* Helper functions used by zte_setup_urbs */
static struct urb *zte_setup_urb(struct usb_serial *serial, int endpoint,
		int dir, void *ctx, char *buf, int len,
		void (*callback)(struct urb *))
{
	struct urb *urb;

	if (endpoint == -1)
		return NULL;		/* endpoint not needed */

	urb = usb_alloc_urb(0, GFP_KERNEL);		/* No ISO */
	if (urb == NULL) {
		dbg("%s: alloc for endpoint %d failed.", __FUNCTION__, endpoint);
		return NULL;
	}

		/* Fill URB using supplied data. */
	usb_fill_bulk_urb(urb, serial->dev,
		      usb_sndbulkpipe(serial->dev, endpoint) | dir,
		      buf, len, callback, ctx);

	return urb;
}

/* Setup urbs */
static void zte_setup_urbs(struct usb_serial *serial)
{
	int i,j;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;

	dbg("%s", __FUNCTION__);

	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);

	/* Do indat endpoints first */
		for (j = 0; j < N_IN_URB; ++j) {
			portdata->in_urbs[j] = zte_setup_urb (serial,
                  	port->bulk_in_endpointAddress, USB_DIR_IN, port,
                  	portdata->in_buffer[j], IN_BUFLEN, zte_indat_callback);
		}

		/* outdat endpoints */
		for (j = 0; j < N_OUT_URB; ++j) {
			portdata->out_urbs[j] = zte_setup_urb (serial,
                  	port->bulk_out_endpointAddress, USB_DIR_OUT, port,
                  	portdata->out_buffer[j], OUT_BUFLEN, zte_outdat_callback);
		}
	}
}

static int zte_send_setup(struct usb_serial_port *port)
{
	struct usb_serial *serial = port->serial;
	struct zte_port_private *portdata;

	dbg("%s", __FUNCTION__);

	if (port->number != 0)
		return 0;

	portdata = usb_get_serial_port_data(port);

	if (port->tty) {
		int val = 0;
		if (portdata->dtr_state)
			val |= 0x01;
		if (portdata->rts_state)
			val |= 0x02;

		return usb_control_msg(serial->dev,
				usb_rcvctrlpipe(serial->dev, 0),
				0x22,0x21,val,0,NULL,0,USB_CTRL_SET_TIMEOUT);
	}

	return 0;
}

static int zte_startup(struct usb_serial *serial)
{
	int i, err;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;

	dbg("%s", __FUNCTION__);

	/* Now setup per port private data */
	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		portdata = kzalloc(sizeof(*portdata), GFP_KERNEL);
		if (!portdata) {
			dbg("%s: kmalloc for zte_port_private (%d) failed!.",
					__FUNCTION__, i);
			return (1);
		}

		usb_set_serial_port_data(port, portdata);

		if (! port->interrupt_in_urb)
			continue;
		err = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);
		if (err)
			dbg("%s: submit irq_in urb failed %d",
				__FUNCTION__, err);
	}

	zte_setup_urbs(serial);

	return (0);
}

static void zte_shutdown(struct usb_serial *serial)
{
	int i, j;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;

	dbg("%s", __FUNCTION__);

	/* Stop reading/writing urbs */
	for (i = 0; i < serial->num_ports; ++i) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);
		for (j = 0; j < N_IN_URB; j++)
			usb_kill_urb(portdata->in_urbs[j]);
		for (j = 0; j < N_OUT_URB; j++)
			usb_kill_urb(portdata->out_urbs[j]);
	}

	/* Now free them */
	for (i = 0; i < serial->num_ports; ++i) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);

		for (j = 0; j < N_IN_URB; j++) {
			if (portdata->in_urbs[j]) {
				usb_free_urb(portdata->in_urbs[j]);
				portdata->in_urbs[j] = NULL;
			}
		}
		for (j = 0; j < N_OUT_URB; j++) {
			if (portdata->out_urbs[j]) {
				usb_free_urb(portdata->out_urbs[j]);
				portdata->out_urbs[j] = NULL;
			}
		}
	}

	/* Now free per port private data */
	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		kfree(usb_get_serial_port_data(port));
	}
}

MODULE_AUTHOR(DRIVER_AUTHOR);
MODULE_DESCRIPTION(DRIVER_DESC);
MODULE_VERSION(DRIVER_VERSION);
MODULE_LICENSE("GPL");

#ifdef CONFIG_USB_DEBUG
module_param(debug, bool, S_IRUGO | S_IWUSR);
MODULE_PARM_DESC(debug, "Debug messages");
#endif

#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)//use 2.6.23 sourcecode

#include <linux/kernel.h>
#include <linux/jiffies.h>
#include <linux/errno.h>
#include <linux/tty.h>
#include <linux/tty_flip.h>
#include <linux/module.h>
#include <linux/bitops.h>
#include <linux/usb.h>
#include <linux/usb/serial.h>

/* Function prototypes */
static int  zte_open(struct usb_serial_port *port, struct file *filp);
static void zte_close(struct usb_serial_port *port, struct file *filp);
static int  zte_startup(struct usb_serial *serial);
static void zte_shutdown(struct usb_serial *serial);
static void zte_rx_throttle(struct usb_serial_port *port);
static void zte_rx_unthrottle(struct usb_serial_port *port);
static int  zte_write_room(struct usb_serial_port *port);

static void zte_instat_callback(struct urb *urb);

static int zte_write(struct usb_serial_port *port,
			const unsigned char *buf, int count);

static int  zte_chars_in_buffer(struct usb_serial_port *port);
static int  zte_ioctl(struct usb_serial_port *port, struct file *file,
			unsigned int cmd, unsigned long arg);
static void zte_set_termios(struct usb_serial_port *port,
				struct ktermios *old);
static void zte_break_ctl(struct usb_serial_port *port, int break_state);
static int  zte_tiocmget(struct usb_serial_port *port, struct file *file);
static int  zte_tiocmset(struct usb_serial_port *port, struct file *file,
				unsigned int set, unsigned int clear);
static int  zte_send_setup(struct usb_serial_port *port);

/* Vendor and product IDs */
#define zte_VENDOR_ID			0x19d2

static struct usb_device_id zte_ids[] = {
	   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0001, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0002, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0003, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0004, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0005, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0006, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0007, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0008, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0009, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0010, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0011, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0012, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0013, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0014, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0015, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0016, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0017, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0018, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0019, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0020, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0021, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0022, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0023, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0024, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0025, 0xff, 0xff, 0xff) },
    //   { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0026, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0027, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0028, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0029, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0030, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0031, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0032, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0033, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0034, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0035, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0036, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0037, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0038, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0039, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0040, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0041, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0042, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0043, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0044, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0045, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0046, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0047, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0048, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0049, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0050, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0051, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0052, 0xff, 0xff, 0xff) },
    //   { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0053, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0054, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0055, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0056, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0057, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0058, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0059, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0060, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0061, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0062, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0063, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0064, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0065, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0066, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0067, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0068, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0069, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0070, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0071, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0072, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0073, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0074, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0075, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0076, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0077, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0078, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0079, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0080, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0081, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0082, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0083, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0084, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0085, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0086, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0087, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0088, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0089, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0090, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0091, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0092, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0093, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0094, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0095, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0096, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0097, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0098, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0099, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0104, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0105, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0106, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0108, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0117, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0118, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0121, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0122, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0123, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0124, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0125, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0126, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0128, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0130, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0133, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0141, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0144, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0145, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0147, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0148, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0151, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0152, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0153, 0xff, 0xff, 0xff) },
    //{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0154, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0155, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0156, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0157, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0158, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0159, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0160, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0161, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0162, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0164, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0165, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0168, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0170, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0176, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0178, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1008, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1010, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1012, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1057, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1058, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1059, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1060, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1061, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1062, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1063, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1064, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1065, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1066, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1067, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1068, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1069, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1070, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1071, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1072, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1073, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1074, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1075, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1076, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1077, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1078, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1079, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1080, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1081, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1082, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1083, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1084, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1085, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1086, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1087, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1088, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1089, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1090, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1091, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1092, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1093, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1094, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1095, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1096, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1097, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1098, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1099, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1100, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1101, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1102, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1103, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1104, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1105, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1106, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1107, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1108, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1109, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1110, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1111, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1112, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1113, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1114, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1115, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1116, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1117, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1118, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1119, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1120, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1121, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1122, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1123, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1124, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1125, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1126, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1127, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1128, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1129, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1130, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1131, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1132, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1133, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1134, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1135, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1136, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1137, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1138, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1139, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1140, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1141, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1142, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1143, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1144, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1145, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1146, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1147, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1148, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1149, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1150, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1151, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1152, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1153, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1154, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1155, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1156, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1157, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1158, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1159, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1160, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1161, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1162, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1163, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1164, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1165, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1166, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1167, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1168, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1169, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1170, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1244, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1245, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1246, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1247, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1248, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1249, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1250, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1251, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1252, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1253, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1254, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1255, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1256, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1257, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1258, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1259, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1260, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1261, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1262, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1263, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1264, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1265, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1266, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1267, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1268, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1269, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1270, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1271, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1272, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1273, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1274, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1275, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1276, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1277, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1278, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1279, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1280, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1281, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1282, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1283, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1284, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1285, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1286, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1287, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1288, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1289, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1290, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1291, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1292, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1293, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1294, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1295, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1296, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1297, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1298, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1299, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1300, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1401, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1402, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1403, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1404, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1405, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1406, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1407, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1408, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1409, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1410, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1411, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1412, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1413, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1414, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1415, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1416, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1417, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1418, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1419, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1420, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1421, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1422, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1423, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1424, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1425, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1426, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1427, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1428, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1429, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1430, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1431, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1432, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1433, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1434, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1435, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1436, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1437, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1438, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1439, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1440, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1441, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1442, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1443, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1444, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1445, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1446, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1447, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1448, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1449, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1450, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1451, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1452, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1453, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1454, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1455, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1456, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1457, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1458, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1459, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1460, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1461, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1462, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1463, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1464, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1465, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1466, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1467, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1468, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1469, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1470, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1471, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1472, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1473, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1474, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1475, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1476, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1477, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1478, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1479, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1480, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1481, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1482, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1483, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1484, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1485, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1486, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1487, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1488, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1489, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1490, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1491, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1492, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1493, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1494, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1495, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1496, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1497, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1498, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1499, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1500, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1501, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1502, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1503, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1504, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1505, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1506, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1507, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1508, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1509, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1510, 0xff, 0xff, 0xff) },       
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x2002, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x2003, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0xFFEC, 0xff, 0xff, 0xff) },

    { USB_DEVICE_AND_INTERFACE_INFO(TPLink_VENDOR_ID, 0x7E11, 0xff, 0xff, 0xff) },/*TPLink*/
    { USB_DEVICE_AND_INTERFACE_INFO(QUALCOMM_VENDOR_ID, 0x9001, 0xff, 0xff, 0xff) },/*QUALCOMM_VENDOR_ID*/
    { USB_DEVICE_AND_INTERFACE_INFO(QUALCOMM_VENDOR_ID, 0x9002, 0xff, 0xff, 0xff) },

	{ } /* Terminating entry */
};
MODULE_DEVICE_TABLE(usb, zte_ids);

static struct usb_driver zte_driver = {
	.name       = "zte",
	.probe      = usb_serial_probe,
	.disconnect = usb_serial_disconnect,
	.id_table   = zte_ids,
	.no_dynamic_id = 	1,
};

/* The card has three separate interfaces, which the serial driver
 * recognizes separately, thus num_port=1.
 */

static struct usb_serial_driver zte_1port_device = {
	.driver = {
		.owner =	THIS_MODULE,
		.name =		"zte1",
	},
	.description       = "GSM modem (1-port)",
	.usb_driver        = &zte_driver,
	.id_table          = zte_ids,
	.num_interrupt_in  = NUM_DONT_CARE,
	.num_bulk_in       = NUM_DONT_CARE,
	.num_bulk_out      = NUM_DONT_CARE,
	.num_ports         = 1,
	.open              = zte_open,
	.close             = zte_close,
	.write             = zte_write,
	.write_room        = zte_write_room,
	.chars_in_buffer   = zte_chars_in_buffer,
	.throttle          = zte_rx_throttle,
	.unthrottle        = zte_rx_unthrottle,
	.ioctl             = zte_ioctl,
	.set_termios       = zte_set_termios,
	.break_ctl         = zte_break_ctl,
	.tiocmget          = zte_tiocmget,
	.tiocmset          = zte_tiocmset,
	.attach            = zte_startup,
	.shutdown          = zte_shutdown,
	.read_int_callback = zte_instat_callback,
};

#ifdef CONFIG_USB_DEBUG
static int debug;
#else
#define debug 0
#endif

/* per port private data */

#define N_IN_URB 4
#define N_OUT_URB 4
#define IN_BUFLEN 4096
#define OUT_BUFLEN 4096

struct zte_port_private {
	/* Input endpoints and buffer for this port */
	struct urb *in_urbs[N_IN_URB];
	char in_buffer[N_IN_URB][IN_BUFLEN];
	/* Output endpoints and buffer for this port */
	struct urb *out_urbs[N_OUT_URB];
	char out_buffer[N_OUT_URB][OUT_BUFLEN];
	unsigned long out_busy;		/* Bit vector of URBs in use */

	/* Settings for the port */
	int rts_state;	/* Handshaking pins (outputs) */
	int dtr_state;
	int cts_state;	/* Handshaking pins (inputs) */
	int dsr_state;
	int dcd_state;
	int ri_state;

	unsigned long tx_start_time[N_OUT_URB];
};

/* Functions used by new usb-serial code. */
static int __init zte_init(void)
{
	int retval;
	retval = usb_serial_register(&zte_1port_device);
	if (retval)
		goto failed_1port_device_register;
	retval = usb_register(&zte_driver);
	if (retval)
		goto failed_driver_register;

	info(DRIVER_DESC ": " DRIVER_VERSION);

	return 0;

failed_driver_register:
	usb_serial_deregister (&zte_1port_device);
failed_1port_device_register:
	return retval;
}

static void __exit zte_exit(void)
{
	usb_deregister (&zte_driver);
	usb_serial_deregister (&zte_1port_device);
}

module_init(zte_init);
module_exit(zte_exit);

static void zte_rx_throttle(struct usb_serial_port *port)
{
	dbg("%s", __FUNCTION__);
}

static void zte_rx_unthrottle(struct usb_serial_port *port)
{
	dbg("%s", __FUNCTION__);
}

static void zte_break_ctl(struct usb_serial_port *port, int break_state)
{
	/* Unfortunately, I don't know how to send a break */
	dbg("%s", __FUNCTION__);
}

static void zte_set_termios(struct usb_serial_port *port,
			struct ktermios *old_termios)
{
	dbg("%s", __FUNCTION__);

	zte_send_setup(port);
}

static int zte_tiocmget(struct usb_serial_port *port, struct file *file)
{
	unsigned int value;
	struct zte_port_private *portdata;

	portdata = usb_get_serial_port_data(port);

	value = ((portdata->rts_state) ? TIOCM_RTS : 0) |
		((portdata->dtr_state) ? TIOCM_DTR : 0) |
		((portdata->cts_state) ? TIOCM_CTS : 0) |
		((portdata->dsr_state) ? TIOCM_DSR : 0) |
		((portdata->dcd_state) ? TIOCM_CAR : 0) |
		((portdata->ri_state) ? TIOCM_RNG : 0);

	return value;
}

static int zte_tiocmset(struct usb_serial_port *port, struct file *file,
			unsigned int set, unsigned int clear)
{
	struct zte_port_private *portdata;

	portdata = usb_get_serial_port_data(port);

	if (set & TIOCM_RTS)
		portdata->rts_state = 1;
	if (set & TIOCM_DTR)
		portdata->dtr_state = 1;

	if (clear & TIOCM_RTS)
		portdata->rts_state = 0;
	if (clear & TIOCM_DTR)
		portdata->dtr_state = 0;
	return zte_send_setup(port);
}

static int zte_ioctl(struct usb_serial_port *port, struct file *file,
			unsigned int cmd, unsigned long arg)
{
	return -ENOIOCTLCMD;
}

/* Write */
static int zte_write(struct usb_serial_port *port,
			const unsigned char *buf, int count)
{
	struct zte_port_private *portdata;
	int i;
	int left, todo;
	struct urb *this_urb = NULL; /* spurious */
	int err;

	portdata = usb_get_serial_port_data(port);

	dbg("%s: write (%d chars)", __FUNCTION__, count);

	i = 0;
	left = count;
	for (i=0; left > 0 && i < N_OUT_URB; i++) {
		todo = left;
		if (todo > OUT_BUFLEN)
			todo = OUT_BUFLEN;

		this_urb = portdata->out_urbs[i];
		if (test_and_set_bit(i, &portdata->out_busy)) {
			if (time_before(jiffies,
					portdata->tx_start_time[i] + 10 * HZ))
				continue;
			usb_unlink_urb(this_urb);
			continue;
		}
		if (this_urb->status != 0)
			dbg("usb_write %p failed (err=%d)",
				this_urb, this_urb->status);

		dbg("%s: endpoint %d buf %d", __FUNCTION__,
			usb_pipeendpoint(this_urb->pipe), i);

		/* send the data */
		memcpy (this_urb->transfer_buffer, buf, todo);
		this_urb->transfer_buffer_length = todo;

		this_urb->dev = port->serial->dev;
		err = usb_submit_urb(this_urb, GFP_ATOMIC);
		if (err) {
			dbg("usb_submit_urb %p (write bulk) failed "
				"(%d, has %d)", this_urb,
				err, this_urb->status);
			clear_bit(i, &portdata->out_busy);
			continue;
		}
		portdata->tx_start_time[i] = jiffies;
		buf += todo;
		left -= todo;
	}

	count -= left;
	dbg("%s: wrote (did %d)", __FUNCTION__, count);
	return count;
}

static void zte_indat_callback(struct urb *urb)
{
	int err;
	int endpoint;
	struct usb_serial_port *port;
	struct tty_struct *tty;
	unsigned char *data = urb->transfer_buffer;
	int status = urb->status;

	dbg("%s: %p", __FUNCTION__, urb);

	endpoint = usb_pipeendpoint(urb->pipe);
	port = (struct usb_serial_port *) urb->context;

	if (status) {
		dbg("%s: nonzero status: %d on endpoint %02x.",
		    __FUNCTION__, status, endpoint);
	} else {
		tty = port->tty;
		if (urb->actual_length) {
			tty_buffer_request_room(tty, urb->actual_length);
			tty_insert_flip_string(tty, data, urb->actual_length);
			tty_flip_buffer_push(tty);
		} else {
			dbg("%s: empty read urb received", __FUNCTION__);
		}

		/* Resubmit urb so we continue receiving */
		if (port->open_count && status != -ESHUTDOWN) {
			err = usb_submit_urb(urb, GFP_ATOMIC);
			if (err)
				printk(KERN_ERR "%s: resubmit read urb failed. "
					"(%d)", __FUNCTION__, err);
		}
	}
	return;
}

static void zte_outdat_callback(struct urb *urb)
{
	struct usb_serial_port *port;
	struct zte_port_private *portdata;
	int i;

	dbg("%s", __FUNCTION__);

	port = (struct usb_serial_port *) urb->context;

	usb_serial_port_softint(port);

	portdata = usb_get_serial_port_data(port);
	for (i = 0; i < N_OUT_URB; ++i) {
		if (portdata->out_urbs[i] == urb) {
			smp_mb__before_clear_bit();
			clear_bit(i, &portdata->out_busy);
			break;
		}

	}
}

static void zte_instat_callback(struct urb *urb)
{
	int err;
	int status = urb->status;
	struct usb_serial_port *port = (struct usb_serial_port *) urb->context;
	struct zte_port_private *portdata = usb_get_serial_port_data(port);
	struct usb_serial *serial = port->serial;

	dbg("%s", __FUNCTION__);
	dbg("%s: urb %p port %p has data %p", __FUNCTION__,urb,port,portdata);

	if (status == 0) {
		struct usb_ctrlrequest *req_pkt =
				(struct usb_ctrlrequest *)urb->transfer_buffer;

		if (!req_pkt) {
			dbg("%s: NULL req_pkt\n", __FUNCTION__);
			return;
		}
		if ((req_pkt->bRequestType == 0xA1) &&
				(req_pkt->bRequest == 0x20)) {
			int old_dcd_state;
			unsigned char signals = *((unsigned char *)
					urb->transfer_buffer +
					sizeof(struct usb_ctrlrequest));

			dbg("%s: signal x%x", __FUNCTION__, signals);

			old_dcd_state = portdata->dcd_state;
			portdata->cts_state = 1;
			portdata->dcd_state = ((signals & 0x01) ? 1 : 0);
			portdata->dsr_state = ((signals & 0x02) ? 1 : 0);
			portdata->ri_state = ((signals & 0x08) ? 1 : 0);

			if (port->tty && !C_CLOCAL(port->tty) &&
					old_dcd_state && !portdata->dcd_state)
				tty_hangup(port->tty);
		} else {
			dbg("%s: type %x req %x", __FUNCTION__,
				req_pkt->bRequestType,req_pkt->bRequest);
		}
	} else
		dbg("%s: error %d", __FUNCTION__, status);

	/* Resubmit urb so we continue receiving IRQ data */
	if (status != -ESHUTDOWN) {
		urb->dev = serial->dev;
		err = usb_submit_urb(urb, GFP_ATOMIC);
		if (err)
			dbg("%s: resubmit intr urb failed. (%d)",
				__FUNCTION__, err);
	}
}

static int zte_write_room(struct usb_serial_port *port)
{
	struct zte_port_private *portdata;
	int i;
	int data_len = 0;
	struct urb *this_urb;

	portdata = usb_get_serial_port_data(port);

	for (i=0; i < N_OUT_URB; i++) {
		this_urb = portdata->out_urbs[i];
		if (this_urb && !test_bit(i, &portdata->out_busy))
			data_len += OUT_BUFLEN;
	}

	dbg("%s: %d", __FUNCTION__, data_len);
	return data_len;
}

static int zte_chars_in_buffer(struct usb_serial_port *port)
{
	struct zte_port_private *portdata;
	int i;
	int data_len = 0;
	struct urb *this_urb;

	portdata = usb_get_serial_port_data(port);

	for (i=0; i < N_OUT_URB; i++) {
		this_urb = portdata->out_urbs[i];
		if (this_urb && test_bit(i, &portdata->out_busy))
			data_len += this_urb->transfer_buffer_length;
	}
	dbg("%s: %d", __FUNCTION__, data_len);
	return data_len;
}

static int zte_open(struct usb_serial_port *port, struct file *filp)
{
	struct zte_port_private *portdata;
	struct usb_serial *serial = port->serial;
	int i, err;
	struct urb *urb;

	portdata = usb_get_serial_port_data(port);

	dbg("%s", __FUNCTION__);

	/* Set some sane defaults */
	portdata->rts_state = 1;
	portdata->dtr_state = 1;

	/* Reset low level data toggle and start reading from endpoints */
	for (i = 0; i < N_IN_URB; i++) {
		urb = portdata->in_urbs[i];
		if (! urb)
			continue;
		if (urb->dev != serial->dev) {
			dbg("%s: dev %p != %p", __FUNCTION__,
				urb->dev, serial->dev);
			continue;
		}

		/*
		 * make sure endpoint data toggle is synchronized with the
		 * device
		 */
		usb_clear_halt(urb->dev, urb->pipe);

		err = usb_submit_urb(urb, GFP_KERNEL);
		if (err) {
			dbg("%s: submit urb %d failed (%d) %d",
				__FUNCTION__, i, err,
				urb->transfer_buffer_length);
		}
	}

	/* Reset low level data toggle on out endpoints */
	for (i = 0; i < N_OUT_URB; i++) {
		urb = portdata->out_urbs[i];
		if (! urb)
			continue;
		urb->dev = serial->dev;
		/* usb_settoggle(urb->dev, usb_pipeendpoint(urb->pipe),
				usb_pipeout(urb->pipe), 0); */
	}

	port->tty->low_latency = 1;

	zte_send_setup(port);

	return (0);
}

static void zte_close(struct usb_serial_port *port, struct file *filp)
{
	int i;
	struct usb_serial *serial = port->serial;
	struct zte_port_private *portdata;

	dbg("%s", __FUNCTION__);
	portdata = usb_get_serial_port_data(port);

	portdata->rts_state = 0;
	portdata->dtr_state = 0;

	if (serial->dev) {
		zte_send_setup(port);

		/* Stop reading/writing urbs */
		for (i = 0; i < N_IN_URB; i++)
			usb_kill_urb(portdata->in_urbs[i]);
		for (i = 0; i < N_OUT_URB; i++)
			usb_kill_urb(portdata->out_urbs[i]);
	}
	port->tty = NULL;
}

/* Helper functions used by zte_setup_urbs */
static struct urb *zte_setup_urb(struct usb_serial *serial, int endpoint,
		int dir, void *ctx, char *buf, int len,
		void (*callback)(struct urb *))
{
	struct urb *urb;

	if (endpoint == -1)
		return NULL;		/* endpoint not needed */

	urb = usb_alloc_urb(0, GFP_KERNEL);		/* No ISO */
	if (urb == NULL) {
		dbg("%s: alloc for endpoint %d failed.", __FUNCTION__, endpoint);
		return NULL;
	}

		/* Fill URB using supplied data. */
	usb_fill_bulk_urb(urb, serial->dev,
		      usb_sndbulkpipe(serial->dev, endpoint) | dir,
		      buf, len, callback, ctx);

	return urb;
}

/* Setup urbs */
static void zte_setup_urbs(struct usb_serial *serial)
{
	int i,j;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;

	dbg("%s", __FUNCTION__);

	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);

	/* Do indat endpoints first */
		for (j = 0; j < N_IN_URB; ++j) {
			portdata->in_urbs[j] = zte_setup_urb (serial,
                  	port->bulk_in_endpointAddress, USB_DIR_IN, port,
                  	portdata->in_buffer[j], IN_BUFLEN, zte_indat_callback);
		}

		/* outdat endpoints */
		for (j = 0; j < N_OUT_URB; ++j) {
			portdata->out_urbs[j] = zte_setup_urb (serial,
                  	port->bulk_out_endpointAddress, USB_DIR_OUT, port,
                  	portdata->out_buffer[j], OUT_BUFLEN, zte_outdat_callback);
		}
	}
}

static int zte_send_setup(struct usb_serial_port *port)
{
	struct usb_serial *serial = port->serial;
	struct zte_port_private *portdata;

	dbg("%s", __FUNCTION__);

	if (port->number != 0)
		return 0;

	portdata = usb_get_serial_port_data(port);

	if (port->tty) {
		int val = 0;
		if (portdata->dtr_state)
			val |= 0x01;
		if (portdata->rts_state)
			val |= 0x02;

		return usb_control_msg(serial->dev,
				usb_rcvctrlpipe(serial->dev, 0),
				0x22,0x21,val,0,NULL,0,USB_CTRL_SET_TIMEOUT);
	}

	return 0;
}

static int zte_startup(struct usb_serial *serial)
{
	int i, err;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;

	dbg("%s", __FUNCTION__);

	/* Now setup per port private data */
	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		portdata = kzalloc(sizeof(*portdata), GFP_KERNEL);
		if (!portdata) {
			dbg("%s: kmalloc for zte_port_private (%d) failed!.",
					__FUNCTION__, i);
			return (1);
		}

		usb_set_serial_port_data(port, portdata);

		if (! port->interrupt_in_urb)
			continue;
		err = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);
		if (err)
			dbg("%s: submit irq_in urb failed %d",
				__FUNCTION__, err);
	}

	zte_setup_urbs(serial);

	return (0);
}

static void zte_shutdown(struct usb_serial *serial)
{
	int i, j;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;

	dbg("%s", __FUNCTION__);

	/* Stop reading/writing urbs */
	for (i = 0; i < serial->num_ports; ++i) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);
		for (j = 0; j < N_IN_URB; j++)
			usb_kill_urb(portdata->in_urbs[j]);
		for (j = 0; j < N_OUT_URB; j++)
			usb_kill_urb(portdata->out_urbs[j]);
	}

	/* Now free them */
	for (i = 0; i < serial->num_ports; ++i) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);

		for (j = 0; j < N_IN_URB; j++) {
			if (portdata->in_urbs[j]) {
				usb_free_urb(portdata->in_urbs[j]);
				portdata->in_urbs[j] = NULL;
			}
		}
		for (j = 0; j < N_OUT_URB; j++) {
			if (portdata->out_urbs[j]) {
				usb_free_urb(portdata->out_urbs[j]);
				portdata->out_urbs[j] = NULL;
			}
		}
	}

	/* Now free per port private data */
	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		kfree(usb_get_serial_port_data(port));
	}
}

MODULE_AUTHOR(DRIVER_AUTHOR);
MODULE_DESCRIPTION(DRIVER_DESC);
MODULE_VERSION(DRIVER_VERSION);
MODULE_LICENSE("GPL");

#ifdef CONFIG_USB_DEBUG
module_param(debug, bool, S_IRUGO | S_IWUSR);
MODULE_PARM_DESC(debug, "Debug messages");
#endif

#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,25)//use 2.6.24 sourcecode

#include <linux/kernel.h>
#include <linux/jiffies.h>
#include <linux/errno.h>
#include <linux/tty.h>
#include <linux/tty_flip.h>
#include <linux/module.h>
#include <linux/bitops.h>
#include <linux/usb.h>
#include <linux/usb/serial.h>

/* Function prototypes */
static int  zte_open(struct usb_serial_port *port, struct file *filp);
static void zte_close(struct usb_serial_port *port, struct file *filp);
static int  zte_startup(struct usb_serial *serial);
static void zte_shutdown(struct usb_serial *serial);
static void zte_rx_throttle(struct usb_serial_port *port);
static void zte_rx_unthrottle(struct usb_serial_port *port);
static int  zte_write_room(struct usb_serial_port *port);

static void zte_instat_callback(struct urb *urb);

static int zte_write(struct usb_serial_port *port,
			const unsigned char *buf, int count);

static int  zte_chars_in_buffer(struct usb_serial_port *port);
static int  zte_ioctl(struct usb_serial_port *port, struct file *file,
			unsigned int cmd, unsigned long arg);
static void zte_set_termios(struct usb_serial_port *port,
				struct ktermios *old);
static void zte_break_ctl(struct usb_serial_port *port, int break_state);
static int  zte_tiocmget(struct usb_serial_port *port, struct file *file);
static int  zte_tiocmset(struct usb_serial_port *port, struct file *file,
				unsigned int set, unsigned int clear);
static int  zte_send_setup(struct usb_serial_port *port);

/* Vendor and product IDs */
#define zte_VENDOR_ID			0x19d2

static struct usb_device_id zte_ids[] = {
	   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0001, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0002, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0003, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0004, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0005, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0006, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0007, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0008, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0009, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0010, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0011, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0012, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0013, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0014, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0015, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0016, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0017, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0018, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0019, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0020, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0021, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0022, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0023, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0024, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0025, 0xff, 0xff, 0xff) },
    //   { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0026, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0027, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0028, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0029, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0030, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0031, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0032, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0033, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0034, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0035, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0036, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0037, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0038, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0039, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0040, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0041, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0042, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0043, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0044, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0045, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0046, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0047, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0048, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0049, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0050, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0051, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0052, 0xff, 0xff, 0xff) },
    //   { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0053, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0054, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0055, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0056, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0057, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0058, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0059, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0060, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0061, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0062, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0063, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0064, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0065, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0066, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0067, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0068, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0069, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0070, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0071, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0072, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0073, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0074, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0075, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0076, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0077, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0078, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0079, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0080, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0081, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0082, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0083, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0084, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0085, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0086, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0087, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0088, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0089, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0090, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0091, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0092, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0093, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0094, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0095, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0096, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0097, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0098, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0099, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0104, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0105, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0106, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0108, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0117, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0118, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0121, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0122, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0123, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0124, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0125, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0126, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0128, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0130, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0133, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0141, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0144, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0145, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0147, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0148, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0151, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0152, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0153, 0xff, 0xff, 0xff) },
    //{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0154, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0155, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0156, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0157, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0158, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0159, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0160, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0161, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0162, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0164, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0165, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0168, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0170, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0176, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0178, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1008, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1010, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1012, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1057, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1058, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1059, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1060, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1061, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1062, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1063, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1064, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1065, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1066, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1067, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1068, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1069, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1070, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1071, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1072, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1073, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1074, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1075, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1076, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1077, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1078, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1079, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1080, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1081, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1082, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1083, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1084, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1085, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1086, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1087, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1088, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1089, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1090, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1091, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1092, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1093, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1094, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1095, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1096, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1097, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1098, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1099, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1100, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1101, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1102, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1103, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1104, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1105, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1106, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1107, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1108, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1109, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1110, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1111, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1112, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1113, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1114, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1115, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1116, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1117, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1118, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1119, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1120, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1121, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1122, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1123, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1124, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1125, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1126, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1127, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1128, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1129, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1130, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1131, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1132, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1133, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1134, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1135, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1136, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1137, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1138, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1139, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1140, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1141, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1142, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1143, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1144, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1145, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1146, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1147, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1148, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1149, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1150, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1151, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1152, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1153, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1154, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1155, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1156, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1157, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1158, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1159, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1160, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1161, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1162, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1163, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1164, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1165, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1166, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1167, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1168, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1169, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1170, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1244, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1245, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1246, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1247, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1248, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1249, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1250, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1251, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1252, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1253, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1254, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1255, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1256, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1257, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1258, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1259, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1260, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1261, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1262, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1263, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1264, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1265, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1266, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1267, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1268, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1269, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1270, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1271, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1272, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1273, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1274, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1275, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1276, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1277, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1278, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1279, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1280, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1281, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1282, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1283, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1284, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1285, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1286, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1287, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1288, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1289, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1290, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1291, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1292, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1293, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1294, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1295, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1296, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1297, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1298, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1299, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1300, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1401, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1402, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1403, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1404, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1405, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1406, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1407, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1408, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1409, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1410, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1411, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1412, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1413, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1414, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1415, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1416, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1417, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1418, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1419, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1420, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1421, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1422, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1423, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1424, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1425, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1426, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1427, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1428, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1429, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1430, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1431, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1432, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1433, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1434, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1435, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1436, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1437, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1438, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1439, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1440, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1441, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1442, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1443, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1444, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1445, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1446, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1447, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1448, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1449, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1450, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1451, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1452, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1453, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1454, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1455, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1456, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1457, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1458, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1459, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1460, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1461, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1462, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1463, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1464, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1465, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1466, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1467, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1468, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1469, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1470, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1471, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1472, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1473, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1474, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1475, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1476, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1477, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1478, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1479, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1480, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1481, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1482, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1483, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1484, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1485, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1486, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1487, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1488, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1489, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1490, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1491, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1492, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1493, 0xff, 0xff, 0xff) },  

    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1494, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1495, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1496, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1497, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1498, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1499, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1500, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1501, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1502, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1503, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1504, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1505, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1506, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1507, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1508, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1509, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1510, 0xff, 0xff, 0xff) },       
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x2002, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x2003, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0xFFEC, 0xff, 0xff, 0xff) },

    { USB_DEVICE_AND_INTERFACE_INFO(TPLink_VENDOR_ID, 0x7E11, 0xff, 0xff, 0xff) },/*TPLink*/
    { USB_DEVICE_AND_INTERFACE_INFO(QUALCOMM_VENDOR_ID, 0x9001, 0xff, 0xff, 0xff) },/*QUALCOMM_VENDOR_ID*/
    { USB_DEVICE_AND_INTERFACE_INFO(QUALCOMM_VENDOR_ID, 0x9002, 0xff, 0xff, 0xff) },

	{ } /* Terminating entry */
};
MODULE_DEVICE_TABLE(usb, zte_ids);

static struct usb_driver zte_driver = {
	.name       = "zte",
	.probe      = usb_serial_probe,
	.disconnect = usb_serial_disconnect,
	.id_table   = zte_ids,
	.no_dynamic_id = 	1,
};

/* The card has three separate interfaces, which the serial driver
 * recognizes separately, thus num_port=1.
 */

static struct usb_serial_driver zte_1port_device = {
	.driver = {
		.owner =	THIS_MODULE,
		.name =		"zte1",
	},
	.description       = "GSM modem (1-port)",
	.usb_driver        = &zte_driver,
	.id_table          = zte_ids,
	.num_interrupt_in  = NUM_DONT_CARE,
	.num_bulk_in       = NUM_DONT_CARE,
	.num_bulk_out      = NUM_DONT_CARE,
	.num_ports         = 1,
	.open              = zte_open,
	.close             = zte_close,
	.write             = zte_write,
	.write_room        = zte_write_room,
	.chars_in_buffer   = zte_chars_in_buffer,
	.throttle          = zte_rx_throttle,
	.unthrottle        = zte_rx_unthrottle,
	.ioctl             = zte_ioctl,
	.set_termios       = zte_set_termios,
	.break_ctl         = zte_break_ctl,
	.tiocmget          = zte_tiocmget,
	.tiocmset          = zte_tiocmset,
	.attach            = zte_startup,
	.shutdown          = zte_shutdown,
	.read_int_callback = zte_instat_callback,
};

#ifdef CONFIG_USB_DEBUG
static int debug;
#else
#define debug 0
#endif

/* per port private data */

#define N_IN_URB 4
#define N_OUT_URB 4
#define IN_BUFLEN 4096
#define OUT_BUFLEN 4096

struct zte_port_private {
	/* Input endpoints and buffer for this port */
	struct urb *in_urbs[N_IN_URB];
	char in_buffer[N_IN_URB][IN_BUFLEN];
	/* Output endpoints and buffer for this port */
	struct urb *out_urbs[N_OUT_URB];
	char out_buffer[N_OUT_URB][OUT_BUFLEN];
	unsigned long out_busy;		/* Bit vector of URBs in use */

	/* Settings for the port */
	int rts_state;	/* Handshaking pins (outputs) */
	int dtr_state;
	int cts_state;	/* Handshaking pins (inputs) */
	int dsr_state;
	int dcd_state;
	int ri_state;

	unsigned long tx_start_time[N_OUT_URB];
};

/* Functions used by new usb-serial code. */
static int __init zte_init(void)
{
	int retval;
	retval = usb_serial_register(&zte_1port_device);
	if (retval)
		goto failed_1port_device_register;
	retval = usb_register(&zte_driver);
	if (retval)
		goto failed_driver_register;

	info(DRIVER_DESC ": " DRIVER_VERSION);

	return 0;

failed_driver_register:
	usb_serial_deregister (&zte_1port_device);
failed_1port_device_register:
	return retval;
}

static void __exit zte_exit(void)
{
	usb_deregister (&zte_driver);
	usb_serial_deregister (&zte_1port_device);
}

module_init(zte_init);
module_exit(zte_exit);

static void zte_rx_throttle(struct usb_serial_port *port)
{
	dbg("%s", __FUNCTION__);
}

static void zte_rx_unthrottle(struct usb_serial_port *port)
{
	dbg("%s", __FUNCTION__);
}

static void zte_break_ctl(struct usb_serial_port *port, int break_state)
{
	/* Unfortunately, I don't know how to send a break */
	dbg("%s", __FUNCTION__);
}

static void zte_set_termios(struct usb_serial_port *port,
			struct ktermios *old_termios)
{
	dbg("%s", __FUNCTION__);
	/* Doesn't support zte setting */
	tty_termios_copy_hw(port->tty->termios, old_termios);
	zte_send_setup(port);
}

static int zte_tiocmget(struct usb_serial_port *port, struct file *file)
{
	unsigned int value;
	struct zte_port_private *portdata;

	portdata = usb_get_serial_port_data(port);

	value = ((portdata->rts_state) ? TIOCM_RTS : 0) |
		((portdata->dtr_state) ? TIOCM_DTR : 0) |
		((portdata->cts_state) ? TIOCM_CTS : 0) |
		((portdata->dsr_state) ? TIOCM_DSR : 0) |
		((portdata->dcd_state) ? TIOCM_CAR : 0) |
		((portdata->ri_state) ? TIOCM_RNG : 0);

	return value;
}

static int zte_tiocmset(struct usb_serial_port *port, struct file *file,
			unsigned int set, unsigned int clear)
{
	struct zte_port_private *portdata;

	portdata = usb_get_serial_port_data(port);

	if (set & TIOCM_RTS)
		portdata->rts_state = 1;
	if (set & TIOCM_DTR)
		portdata->dtr_state = 1;

	if (clear & TIOCM_RTS)
		portdata->rts_state = 0;
	if (clear & TIOCM_DTR)
		portdata->dtr_state = 0;
	return zte_send_setup(port);
}

static int zte_ioctl(struct usb_serial_port *port, struct file *file,
			unsigned int cmd, unsigned long arg)
{
	return -ENOIOCTLCMD;
}

/* Write */
static int zte_write(struct usb_serial_port *port,
			const unsigned char *buf, int count)
{
	struct zte_port_private *portdata;
	int i;
	int left, todo;
	struct urb *this_urb = NULL; /* spurious */
	int err;

	portdata = usb_get_serial_port_data(port);

	dbg("%s: write (%d chars)", __FUNCTION__, count);

	i = 0;
	left = count;
	for (i=0; left > 0 && i < N_OUT_URB; i++) {
		todo = left;
		if (todo > OUT_BUFLEN)
			todo = OUT_BUFLEN;

		this_urb = portdata->out_urbs[i];
		if (test_and_set_bit(i, &portdata->out_busy)) {
			if (time_before(jiffies,
					portdata->tx_start_time[i] + 10 * HZ))
				continue;
			usb_unlink_urb(this_urb);
			continue;
		}
		if (this_urb->status != 0)
			dbg("usb_write %p failed (err=%d)",
				this_urb, this_urb->status);

		dbg("%s: endpoint %d buf %d", __FUNCTION__,
			usb_pipeendpoint(this_urb->pipe), i);

		/* send the data */
		memcpy (this_urb->transfer_buffer, buf, todo);
		this_urb->transfer_buffer_length = todo;

		this_urb->dev = port->serial->dev;
		err = usb_submit_urb(this_urb, GFP_ATOMIC);
		if (err) {
			dbg("usb_submit_urb %p (write bulk) failed "
				"(%d, has %d)", this_urb,
				err, this_urb->status);
			clear_bit(i, &portdata->out_busy);
			continue;
		}
		portdata->tx_start_time[i] = jiffies;
		buf += todo;
		left -= todo;
	}

	count -= left;
	dbg("%s: wrote (did %d)", __FUNCTION__, count);
	return count;
}

static void zte_indat_callback(struct urb *urb)
{
	int err;
	int endpoint;
	struct usb_serial_port *port;
	struct tty_struct *tty;
	unsigned char *data = urb->transfer_buffer;
	int status = urb->status;

	dbg("%s: %p", __FUNCTION__, urb);

	endpoint = usb_pipeendpoint(urb->pipe);
	port = (struct usb_serial_port *) urb->context;

	if (status) {
		dbg("%s: nonzero status: %d on endpoint %02x.",
		    __FUNCTION__, status, endpoint);
	} else {
		tty = port->tty;
		if (urb->actual_length) {
			tty_buffer_request_room(tty, urb->actual_length);
			tty_insert_flip_string(tty, data, urb->actual_length);
			tty_flip_buffer_push(tty);
		} else {
			dbg("%s: empty read urb received", __FUNCTION__);
		}

		/* Resubmit urb so we continue receiving */
		if (port->open_count && status != -ESHUTDOWN) {
			err = usb_submit_urb(urb, GFP_ATOMIC);
			if (err)
				printk(KERN_ERR "%s: resubmit read urb failed. "
					"(%d)", __FUNCTION__, err);
		}
	}
	return;
}

static void zte_outdat_callback(struct urb *urb)
{
	struct usb_serial_port *port;
	struct zte_port_private *portdata;
	int i;

	dbg("%s", __FUNCTION__);

	port = (struct usb_serial_port *) urb->context;

	usb_serial_port_softint(port);

	portdata = usb_get_serial_port_data(port);
	for (i = 0; i < N_OUT_URB; ++i) {
		if (portdata->out_urbs[i] == urb) {
			smp_mb__before_clear_bit();
			clear_bit(i, &portdata->out_busy);
			break;
		}
	}
}

static void zte_instat_callback(struct urb *urb)
{
	int err;
	int status = urb->status;
	struct usb_serial_port *port = (struct usb_serial_port *) urb->context;
	struct zte_port_private *portdata = usb_get_serial_port_data(port);
	struct usb_serial *serial = port->serial;

	dbg("%s", __FUNCTION__);
	dbg("%s: urb %p port %p has data %p", __FUNCTION__,urb,port,portdata);

	if (status == 0) {
		struct usb_ctrlrequest *req_pkt =
				(struct usb_ctrlrequest *)urb->transfer_buffer;

		if (!req_pkt) {
			dbg("%s: NULL req_pkt\n", __FUNCTION__);
			return;
		}
		if ((req_pkt->bRequestType == 0xA1) &&
				(req_pkt->bRequest == 0x20)) {
			int old_dcd_state;
			unsigned char signals = *((unsigned char *)
					urb->transfer_buffer +
					sizeof(struct usb_ctrlrequest));

			dbg("%s: signal x%x", __FUNCTION__, signals);

			old_dcd_state = portdata->dcd_state;
			portdata->cts_state = 1;
			portdata->dcd_state = ((signals & 0x01) ? 1 : 0);
			portdata->dsr_state = ((signals & 0x02) ? 1 : 0);
			portdata->ri_state = ((signals & 0x08) ? 1 : 0);

			if (port->tty && !C_CLOCAL(port->tty) &&
					old_dcd_state && !portdata->dcd_state)
				tty_hangup(port->tty);
		} else {
			dbg("%s: type %x req %x", __FUNCTION__,
				req_pkt->bRequestType,req_pkt->bRequest);
		}
	} else
		dbg("%s: error %d", __FUNCTION__, status);

	/* Resubmit urb so we continue receiving IRQ data */
	if (status != -ESHUTDOWN) {
		urb->dev = serial->dev;
		err = usb_submit_urb(urb, GFP_ATOMIC);
		if (err)
			dbg("%s: resubmit intr urb failed. (%d)",
				__FUNCTION__, err);
	}
}

static int zte_write_room(struct usb_serial_port *port)
{
	struct zte_port_private *portdata;
	int i;
	int data_len = 0;
	struct urb *this_urb;

	portdata = usb_get_serial_port_data(port);

	for (i=0; i < N_OUT_URB; i++) {
		this_urb = portdata->out_urbs[i];
		if (this_urb && !test_bit(i, &portdata->out_busy))
			data_len += OUT_BUFLEN;
	}

	dbg("%s: %d", __FUNCTION__, data_len);
	return data_len;
}

static int zte_chars_in_buffer(struct usb_serial_port *port)
{
	struct zte_port_private *portdata;
	int i;
	int data_len = 0;
	struct urb *this_urb;

	portdata = usb_get_serial_port_data(port);

	for (i=0; i < N_OUT_URB; i++) {
		this_urb = portdata->out_urbs[i];
		if (this_urb && test_bit(i, &portdata->out_busy))
			data_len += this_urb->transfer_buffer_length;
	}
	dbg("%s: %d", __FUNCTION__, data_len);
	return data_len;
}

static int zte_open(struct usb_serial_port *port, struct file *filp)
{
	struct zte_port_private *portdata;
	struct usb_serial *serial = port->serial;
	int i, err;
	struct urb *urb;

	portdata = usb_get_serial_port_data(port);

	dbg("%s", __FUNCTION__);

	/* Set some sane defaults */
	portdata->rts_state = 1;
	portdata->dtr_state = 1;

	/* Reset low level data toggle and start reading from endpoints */
	for (i = 0; i < N_IN_URB; i++) {
		urb = portdata->in_urbs[i];
		if (! urb)
			continue;
		if (urb->dev != serial->dev) {
			dbg("%s: dev %p != %p", __FUNCTION__,
				urb->dev, serial->dev);
			continue;
		}

		/*
		 * make sure endpoint data toggle is synchronized with the
		 * device
		 */
		usb_clear_halt(urb->dev, urb->pipe);

		err = usb_submit_urb(urb, GFP_KERNEL);
		if (err) {
			dbg("%s: submit urb %d failed (%d) %d",
				__FUNCTION__, i, err,
				urb->transfer_buffer_length);
		}
	}

	/* Reset low level data toggle on out endpoints */
	for (i = 0; i < N_OUT_URB; i++) {
		urb = portdata->out_urbs[i];
		if (! urb)
			continue;
		urb->dev = serial->dev;
		/* usb_settoggle(urb->dev, usb_pipeendpoint(urb->pipe),
				usb_pipeout(urb->pipe), 0); */
	}

	port->tty->low_latency = 1;

	zte_send_setup(port);

	return (0);
}

static void zte_close(struct usb_serial_port *port, struct file *filp)
{
	int i;
	struct usb_serial *serial = port->serial;
	struct zte_port_private *portdata;

	dbg("%s", __FUNCTION__);
	portdata = usb_get_serial_port_data(port);

	portdata->rts_state = 0;
	portdata->dtr_state = 0;

	if (serial->dev) {
		zte_send_setup(port);

		/* Stop reading/writing urbs */
		for (i = 0; i < N_IN_URB; i++)
			usb_kill_urb(portdata->in_urbs[i]);
		for (i = 0; i < N_OUT_URB; i++)
			usb_kill_urb(portdata->out_urbs[i]);
	}
	port->tty = NULL;
}

/* Helper functions used by zte_setup_urbs */
static struct urb *zte_setup_urb(struct usb_serial *serial, int endpoint,
		int dir, void *ctx, char *buf, int len,
		void (*callback)(struct urb *))
{
	struct urb *urb;

	if (endpoint == -1)
		return NULL;		/* endpoint not needed */

	urb = usb_alloc_urb(0, GFP_KERNEL);		/* No ISO */
	if (urb == NULL) {
		dbg("%s: alloc for endpoint %d failed.", __FUNCTION__, endpoint);
		return NULL;
	}

		/* Fill URB using supplied data. */
	usb_fill_bulk_urb(urb, serial->dev,
		      usb_sndbulkpipe(serial->dev, endpoint) | dir,
		      buf, len, callback, ctx);

	return urb;
}

/* Setup urbs */
static void zte_setup_urbs(struct usb_serial *serial)
{
	int i,j;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;

	dbg("%s", __FUNCTION__);

	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);

	/* Do indat endpoints first */
		for (j = 0; j < N_IN_URB; ++j) {
			portdata->in_urbs[j] = zte_setup_urb (serial,
                  	port->bulk_in_endpointAddress, USB_DIR_IN, port,
                  	portdata->in_buffer[j], IN_BUFLEN, zte_indat_callback);
		}

		/* outdat endpoints */
		for (j = 0; j < N_OUT_URB; ++j) {
			portdata->out_urbs[j] = zte_setup_urb (serial,
                  	port->bulk_out_endpointAddress, USB_DIR_OUT, port,
                  	portdata->out_buffer[j], OUT_BUFLEN, zte_outdat_callback);
		}
	}
}

static int zte_send_setup(struct usb_serial_port *port)
{
	struct usb_serial *serial = port->serial;
	struct zte_port_private *portdata;

	dbg("%s", __FUNCTION__);

	if (port->number != 0)
		return 0;

	portdata = usb_get_serial_port_data(port);

	if (port->tty) {
		int val = 0;
		if (portdata->dtr_state)
			val |= 0x01;
		if (portdata->rts_state)
			val |= 0x02;

		return usb_control_msg(serial->dev,
				usb_rcvctrlpipe(serial->dev, 0),
				0x22,0x21,val,0,NULL,0,USB_CTRL_SET_TIMEOUT);
	}

	return 0;
}

static int zte_startup(struct usb_serial *serial)
{
	int i, err;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;

	dbg("%s", __FUNCTION__);

	/* Now setup per port private data */
	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		portdata = kzalloc(sizeof(*portdata), GFP_KERNEL);
		if (!portdata) {
			dbg("%s: kmalloc for zte_port_private (%d) failed!.",
					__FUNCTION__, i);
			return (1);
		}

		usb_set_serial_port_data(port, portdata);

		if (! port->interrupt_in_urb)
			continue;
		err = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);
		if (err)
			dbg("%s: submit irq_in urb failed %d",
				__FUNCTION__, err);
	}

	zte_setup_urbs(serial);

	return (0);
}

static void zte_shutdown(struct usb_serial *serial)
{
	int i, j;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;

	dbg("%s", __FUNCTION__);

	/* Stop reading/writing urbs */
	for (i = 0; i < serial->num_ports; ++i) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);
		for (j = 0; j < N_IN_URB; j++)
			usb_kill_urb(portdata->in_urbs[j]);
		for (j = 0; j < N_OUT_URB; j++)
			usb_kill_urb(portdata->out_urbs[j]);
	}

	/* Now free them */
	for (i = 0; i < serial->num_ports; ++i) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);

		for (j = 0; j < N_IN_URB; j++) {
			if (portdata->in_urbs[j]) {
				usb_free_urb(portdata->in_urbs[j]);
				portdata->in_urbs[j] = NULL;
			}
		}
		for (j = 0; j < N_OUT_URB; j++) {
			if (portdata->out_urbs[j]) {
				usb_free_urb(portdata->out_urbs[j]);
				portdata->out_urbs[j] = NULL;
			}
		}
	}

	/* Now free per port private data */
	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		kfree(usb_get_serial_port_data(port));
	}
}

MODULE_AUTHOR(DRIVER_AUTHOR);
MODULE_DESCRIPTION(DRIVER_DESC);
MODULE_VERSION(DRIVER_VERSION);
MODULE_LICENSE("GPL");

#ifdef CONFIG_USB_DEBUG
module_param(debug, bool, S_IRUGO | S_IWUSR);
MODULE_PARM_DESC(debug, "Debug messages");
#endif

#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26)//use 2.6.25 sourcecode

#include <linux/kernel.h>
#include <linux/jiffies.h>
#include <linux/errno.h>
#include <linux/tty.h>
#include <linux/tty_flip.h>
#include <linux/module.h>
#include <linux/bitops.h>
#include <linux/usb.h>
#include <linux/usb/serial.h>

/* Function prototypes */
static int  zte_open(struct usb_serial_port *port, struct file *filp);
static void zte_close(struct usb_serial_port *port, struct file *filp);
static int  zte_startup(struct usb_serial *serial);
static void zte_shutdown(struct usb_serial *serial);
static void zte_rx_throttle(struct usb_serial_port *port);
static void zte_rx_unthrottle(struct usb_serial_port *port);
static int  zte_write_room(struct usb_serial_port *port);

static void zte_instat_callback(struct urb *urb);

static int zte_write(struct usb_serial_port *port,
			const unsigned char *buf, int count);

static int  zte_chars_in_buffer(struct usb_serial_port *port);
static int  zte_ioctl(struct usb_serial_port *port, struct file *file,
			unsigned int cmd, unsigned long arg);
static void zte_set_termios(struct usb_serial_port *port,
				struct ktermios *old);
static void zte_break_ctl(struct usb_serial_port *port, int break_state);
static int  zte_tiocmget(struct usb_serial_port *port, struct file *file);
static int  zte_tiocmset(struct usb_serial_port *port, struct file *file,
				unsigned int set, unsigned int clear);
static int  zte_send_setup(struct usb_serial_port *port);

/* Vendor and product IDs */
#define zte_VENDOR_ID			0x19d2

static struct usb_device_id zte_ids[] = {
	   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0001, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0002, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0003, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0004, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0005, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0006, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0007, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0008, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0009, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0010, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0011, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0012, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0013, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0014, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0015, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0016, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0017, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0018, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0019, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0020, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0021, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0022, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0023, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0024, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0025, 0xff, 0xff, 0xff) },
    //   { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0026, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0027, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0028, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0029, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0030, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0031, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0032, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0033, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0034, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0035, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0036, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0037, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0038, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0039, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0040, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0041, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0042, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0043, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0044, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0045, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0046, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0047, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0048, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0049, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0050, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0051, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0052, 0xff, 0xff, 0xff) },
    //   { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0053, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0054, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0055, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0056, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0057, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0058, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0059, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0060, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0061, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0062, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0063, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0064, 0xff, 0xff, 0xff) },

    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0065, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0066, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0067, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0068, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0069, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0070, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0071, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0072, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0073, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0074, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0075, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0076, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0077, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0078, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0079, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0080, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0081, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0082, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0083, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0084, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0085, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0086, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0087, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0088, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0089, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0090, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0091, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0092, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0093, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0094, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0095, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0096, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0097, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0098, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0099, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0104, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0105, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0106, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0108, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0117, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0118, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0121, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0122, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0123, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0124, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0125, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0126, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0128, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0130, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0133, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0141, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0144, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0145, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0147, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0148, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0151, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0152, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0153, 0xff, 0xff, 0xff) },
    //{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0154, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0155, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0156, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0157, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0158, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0159, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0160, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0161, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0162, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0164, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0165, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0168, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0170, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0176, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0178, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1008, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1010, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1012, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1057, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1058, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1059, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1060, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1061, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1062, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1063, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1064, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1065, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1066, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1067, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1068, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1069, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1070, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1071, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1072, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1073, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1074, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1075, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1076, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1077, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1078, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1079, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1080, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1081, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1082, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1083, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1084, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1085, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1086, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1087, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1088, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1089, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1090, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1091, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1092, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1093, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1094, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1095, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1096, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1097, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1098, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1099, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1100, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1101, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1102, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1103, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1104, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1105, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1106, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1107, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1108, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1109, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1110, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1111, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1112, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1113, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1114, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1115, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1116, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1117, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1118, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1119, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1120, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1121, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1122, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1123, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1124, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1125, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1126, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1127, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1128, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1129, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1130, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1131, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1132, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1133, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1134, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1135, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1136, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1137, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1138, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1139, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1140, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1141, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1142, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1143, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1144, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1145, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1146, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1147, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1148, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1149, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1150, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1151, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1152, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1153, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1154, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1155, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1156, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1157, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1158, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1159, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1160, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1161, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1162, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1163, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1164, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1165, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1166, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1167, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1168, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1169, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1170, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1244, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1245, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1246, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1247, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1248, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1249, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1250, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1251, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1252, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1253, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1254, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1255, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1256, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1257, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1258, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1259, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1260, 0xff, 0xff, 0xff) },

	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1261, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1262, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1263, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1264, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1265, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1266, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1267, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1268, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1269, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1270, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1271, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1272, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1273, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1274, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1275, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1276, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1277, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1278, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1279, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1280, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1281, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1282, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1283, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1284, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1285, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1286, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1287, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1288, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1289, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1290, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1291, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1292, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1293, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1294, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1295, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1296, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1297, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1298, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1299, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1300, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1401, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1402, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1403, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1404, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1405, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1406, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1407, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1408, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1409, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1410, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1411, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1412, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1413, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1414, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1415, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1416, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1417, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1418, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1419, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1420, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1421, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1422, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1423, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1424, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1425, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1426, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1427, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1428, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1429, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1430, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1431, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1432, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1433, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1434, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1435, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1436, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1437, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1438, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1439, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1440, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1441, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1442, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1443, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1444, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1445, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1446, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1447, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1448, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1449, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1450, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1451, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1452, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1453, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1454, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1455, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1456, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1457, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1458, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1459, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1460, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1461, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1462, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1463, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1464, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1465, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1466, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1467, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1468, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1469, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1470, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1471, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1472, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1473, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1474, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1475, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1476, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1477, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1478, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1479, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1480, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1481, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1482, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1483, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1484, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1485, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1486, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1487, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1488, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1489, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1490, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1491, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1492, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1493, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1494, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1495, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1496, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1497, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1498, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1499, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1500, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1501, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1502, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1503, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1504, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1505, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1506, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1507, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1508, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1509, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1510, 0xff, 0xff, 0xff) },       
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x2002, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x2003, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0xFFEC, 0xff, 0xff, 0xff) },

    { USB_DEVICE_AND_INTERFACE_INFO(TPLink_VENDOR_ID, 0x7E11, 0xff, 0xff, 0xff) },/*TPLink*/
    { USB_DEVICE_AND_INTERFACE_INFO(QUALCOMM_VENDOR_ID, 0x9001, 0xff, 0xff, 0xff) },/*QUALCOMM_VENDOR_ID*/
    { USB_DEVICE_AND_INTERFACE_INFO(QUALCOMM_VENDOR_ID, 0x9002, 0xff, 0xff, 0xff) },

	{ } /* Terminating entry */
};
MODULE_DEVICE_TABLE(usb, zte_ids);

static struct usb_driver zte_driver = {
	.name       = "zte",
	.probe      = usb_serial_probe,
	.disconnect = usb_serial_disconnect,
	.id_table   = zte_ids,
	.no_dynamic_id = 	1,
};

/* The card has three separate interfaces, which the serial driver
 * recognizes separately, thus num_port=1.
 */

static struct usb_serial_driver zte_1port_device = {
	.driver = {
		.owner =	THIS_MODULE,
		.name =		"zte1",
	},
	.description       = "GSM modem (1-port)",
	.usb_driver        = &zte_driver,
	.id_table          = zte_ids,
	.num_interrupt_in  = NUM_DONT_CARE,
	.num_bulk_in       = NUM_DONT_CARE,
	.num_bulk_out      = NUM_DONT_CARE,
	.num_ports         = 1,
	.open              = zte_open,
	.close             = zte_close,
	.write             = zte_write,
	.write_room        = zte_write_room,
	.chars_in_buffer   = zte_chars_in_buffer,
	.throttle          = zte_rx_throttle,
	.unthrottle        = zte_rx_unthrottle,
	.ioctl             = zte_ioctl,
	.set_termios       = zte_set_termios,
	.break_ctl         = zte_break_ctl,
	.tiocmget          = zte_tiocmget,
	.tiocmset          = zte_tiocmset,
	.attach            = zte_startup,
	.shutdown          = zte_shutdown,
	.read_int_callback = zte_instat_callback,
};

#ifdef CONFIG_USB_DEBUG
static int debug;
#else
#define debug 0
#endif

/* per port private data */

#define N_IN_URB 4
#define N_OUT_URB 4
#define IN_BUFLEN 4096
#define OUT_BUFLEN 4096

struct zte_port_private {
	/* Input endpoints and buffer for this port */
	struct urb *in_urbs[N_IN_URB];
	u8 *in_buffer[N_IN_URB];
	/* Output endpoints and buffer for this port */
	struct urb *out_urbs[N_OUT_URB];
	u8 *out_buffer[N_OUT_URB];
	unsigned long out_busy;		/* Bit vector of URBs in use */

	/* Settings for the port */
	int rts_state;	/* Handshaking pins (outputs) */
	int dtr_state;
	int cts_state;	/* Handshaking pins (inputs) */
	int dsr_state;
	int dcd_state;
	int ri_state;

	unsigned long tx_start_time[N_OUT_URB];
};

/* Functions used by new usb-serial code. */
static int __init zte_init(void)
{
	int retval;
	retval = usb_serial_register(&zte_1port_device);
	if (retval)
		goto failed_1port_device_register;
	retval = usb_register(&zte_driver);
	if (retval)
		goto failed_driver_register;

	info(DRIVER_DESC ": " DRIVER_VERSION);

	return 0;

failed_driver_register:
	usb_serial_deregister (&zte_1port_device);
failed_1port_device_register:
	return retval;
}

static void __exit zte_exit(void)
{
	usb_deregister (&zte_driver);
	usb_serial_deregister (&zte_1port_device);
}

module_init(zte_init);
module_exit(zte_exit);

static void zte_rx_throttle(struct usb_serial_port *port)
{
	dbg("%s", __FUNCTION__);
}

static void zte_rx_unthrottle(struct usb_serial_port *port)
{
	dbg("%s", __FUNCTION__);
}

static void zte_break_ctl(struct usb_serial_port *port, int break_state)
{
	/* Unfortunately, I don't know how to send a break */
	dbg("%s", __FUNCTION__);
}

static void zte_set_termios(struct usb_serial_port *port,
			struct ktermios *old_termios)
{
	dbg("%s", __FUNCTION__);
	/* Doesn't support zte setting */
	tty_termios_copy_hw(port->tty->termios, old_termios);
	zte_send_setup(port);
}

static int zte_tiocmget(struct usb_serial_port *port, struct file *file)
{
	unsigned int value;
	struct zte_port_private *portdata;

	portdata = usb_get_serial_port_data(port);

	value = ((portdata->rts_state) ? TIOCM_RTS : 0) |
		((portdata->dtr_state) ? TIOCM_DTR : 0) |
		((portdata->cts_state) ? TIOCM_CTS : 0) |
		((portdata->dsr_state) ? TIOCM_DSR : 0) |
		((portdata->dcd_state) ? TIOCM_CAR : 0) |
		((portdata->ri_state) ? TIOCM_RNG : 0);

	return value;
}

static int zte_tiocmset(struct usb_serial_port *port, struct file *file,
			unsigned int set, unsigned int clear)
{
	struct zte_port_private *portdata;

	portdata = usb_get_serial_port_data(port);

	if (set & TIOCM_RTS)
		portdata->rts_state = 1;
	if (set & TIOCM_DTR)
		portdata->dtr_state = 1;

	if (clear & TIOCM_RTS)
		portdata->rts_state = 0;
	if (clear & TIOCM_DTR)
		portdata->dtr_state = 0;
	return zte_send_setup(port);
}

static int zte_ioctl(struct usb_serial_port *port, struct file *file,
			unsigned int cmd, unsigned long arg)
{
	return -ENOIOCTLCMD;
}

/* Write */
static int zte_write(struct usb_serial_port *port,
			const unsigned char *buf, int count)
{
	struct zte_port_private *portdata;
	int i;
	int left, todo;
	struct urb *this_urb = NULL; /* spurious */
	int err;

	portdata = usb_get_serial_port_data(port);

	dbg("%s: write (%d chars)", __FUNCTION__, count);

	i = 0;
	left = count;
	for (i=0; left > 0 && i < N_OUT_URB; i++) {
		todo = left;
		if (todo > OUT_BUFLEN)
			todo = OUT_BUFLEN;

		this_urb = portdata->out_urbs[i];
		if (test_and_set_bit(i, &portdata->out_busy)) {
			if (time_before(jiffies,
					portdata->tx_start_time[i] + 10 * HZ))
				continue;
			usb_unlink_urb(this_urb);
			continue;
		}
		if (this_urb->status != 0)
			dbg("usb_write %p failed (err=%d)",
				this_urb, this_urb->status);

		dbg("%s: endpoint %d buf %d", __FUNCTION__,
			usb_pipeendpoint(this_urb->pipe), i);

		/* send the data */
		memcpy (this_urb->transfer_buffer, buf, todo);
		this_urb->transfer_buffer_length = todo;

		this_urb->dev = port->serial->dev;
		err = usb_submit_urb(this_urb, GFP_ATOMIC);
		if (err) {
			dbg("usb_submit_urb %p (write bulk) failed "
				"(%d, has %d)", this_urb,
				err, this_urb->status);
			clear_bit(i, &portdata->out_busy);
			continue;
		}
		portdata->tx_start_time[i] = jiffies;
		buf += todo;
		left -= todo;
	}

	count -= left;
	dbg("%s: wrote (did %d)", __FUNCTION__, count);
	return count;
}

static void zte_indat_callback(struct urb *urb)
{
	int err;
	int endpoint;
	struct usb_serial_port *port;
	struct tty_struct *tty;
	unsigned char *data = urb->transfer_buffer;
	int status = urb->status;

	dbg("%s: %p", __FUNCTION__, urb);

	endpoint = usb_pipeendpoint(urb->pipe);
	port = (struct usb_serial_port *) urb->context;

	if (status) {
		dbg("%s: nonzero status: %d on endpoint %02x.",
		    __FUNCTION__, status, endpoint);
	} else {
		tty = port->tty;
		if (urb->actual_length) {
			tty_buffer_request_room(tty, urb->actual_length);
			tty_insert_flip_string(tty, data, urb->actual_length);
			tty_flip_buffer_push(tty);
		} else {
			dbg("%s: empty read urb received", __FUNCTION__);
		}

		/* Resubmit urb so we continue receiving */
		if (port->open_count && status != -ESHUTDOWN) {
			err = usb_submit_urb(urb, GFP_ATOMIC);
			if (err)
				printk(KERN_ERR "%s: resubmit read urb failed. "
					"(%d)", __FUNCTION__, err);
		}
	}
	return;
}

static void zte_outdat_callback(struct urb *urb)
{
	struct usb_serial_port *port;
	struct zte_port_private *portdata;
	int i;

	dbg("%s", __FUNCTION__);

	port = (struct usb_serial_port *) urb->context;

	usb_serial_port_softint(port);

	portdata = usb_get_serial_port_data(port);
	for (i = 0; i < N_OUT_URB; ++i) {
		if (portdata->out_urbs[i] == urb) {
			smp_mb__before_clear_bit();
			clear_bit(i, &portdata->out_busy);
			break;
		}
	}
}

static void zte_instat_callback(struct urb *urb)
{
	int err;
	int status = urb->status;
	struct usb_serial_port *port = (struct usb_serial_port *) urb->context;
	struct zte_port_private *portdata = usb_get_serial_port_data(port);
	struct usb_serial *serial = port->serial;

	dbg("%s", __FUNCTION__);
	dbg("%s: urb %p port %p has data %p", __FUNCTION__,urb,port,portdata);

	if (status == 0) {
		struct usb_ctrlrequest *req_pkt =
				(struct usb_ctrlrequest *)urb->transfer_buffer;

		if (!req_pkt) {
			dbg("%s: NULL req_pkt\n", __FUNCTION__);
			return;
		}
		if ((req_pkt->bRequestType == 0xA1) &&
				(req_pkt->bRequest == 0x20)) {
			int old_dcd_state;
			unsigned char signals = *((unsigned char *)
					urb->transfer_buffer +
					sizeof(struct usb_ctrlrequest));

			dbg("%s: signal x%x", __FUNCTION__, signals);

			old_dcd_state = portdata->dcd_state;
			portdata->cts_state = 1;
			portdata->dcd_state = ((signals & 0x01) ? 1 : 0);
			portdata->dsr_state = ((signals & 0x02) ? 1 : 0);
			portdata->ri_state = ((signals & 0x08) ? 1 : 0);

			if (port->tty && !C_CLOCAL(port->tty) &&
					old_dcd_state && !portdata->dcd_state)
				tty_hangup(port->tty);
		} else {
			dbg("%s: type %x req %x", __FUNCTION__,
				req_pkt->bRequestType,req_pkt->bRequest);
		}
	} else
		dbg("%s: error %d", __FUNCTION__, status);

	/* Resubmit urb so we continue receiving IRQ data */
	if (status != -ESHUTDOWN) {
		urb->dev = serial->dev;
		err = usb_submit_urb(urb, GFP_ATOMIC);
		if (err)
			dbg("%s: resubmit intr urb failed. (%d)",
				__FUNCTION__, err);
	}
}

static int zte_write_room(struct usb_serial_port *port)
{
	struct zte_port_private *portdata;
	int i;
	int data_len = 0;
	struct urb *this_urb;

	portdata = usb_get_serial_port_data(port);

	for (i=0; i < N_OUT_URB; i++) {
		this_urb = portdata->out_urbs[i];
		if (this_urb && !test_bit(i, &portdata->out_busy))
			data_len += OUT_BUFLEN;
	}

	dbg("%s: %d", __FUNCTION__, data_len);
	return data_len;
}

static int zte_chars_in_buffer(struct usb_serial_port *port)
{
	struct zte_port_private *portdata;
	int i;
	int data_len = 0;
	struct urb *this_urb;

	portdata = usb_get_serial_port_data(port);

	for (i=0; i < N_OUT_URB; i++) {
		this_urb = portdata->out_urbs[i];
		if (this_urb && test_bit(i, &portdata->out_busy))
			data_len += this_urb->transfer_buffer_length;
	}
	dbg("%s: %d", __FUNCTION__, data_len);
	return data_len;
}

static int zte_open(struct usb_serial_port *port, struct file *filp)
{
	struct zte_port_private *portdata;
	struct usb_serial *serial = port->serial;
	int i, err;
	struct urb *urb;

	portdata = usb_get_serial_port_data(port);

	dbg("%s", __FUNCTION__);

	/* Set some sane defaults */
	portdata->rts_state = 1;
	portdata->dtr_state = 1;

	/* Reset low level data toggle and start reading from endpoints */
	for (i = 0; i < N_IN_URB; i++) {
		urb = portdata->in_urbs[i];
		if (! urb)
			continue;
		if (urb->dev != serial->dev) {
			dbg("%s: dev %p != %p", __FUNCTION__,
				urb->dev, serial->dev);
			continue;
		}

		/*
		 * make sure endpoint data toggle is synchronized with the
		 * device
		 */
		usb_clear_halt(urb->dev, urb->pipe);

		err = usb_submit_urb(urb, GFP_KERNEL);
		if (err) {
			dbg("%s: submit urb %d failed (%d) %d",
				__FUNCTION__, i, err,
				urb->transfer_buffer_length);
		}
	}

	/* Reset low level data toggle on out endpoints */
	for (i = 0; i < N_OUT_URB; i++) {
		urb = portdata->out_urbs[i];
		if (! urb)
			continue;
		urb->dev = serial->dev;
		/* usb_settoggle(urb->dev, usb_pipeendpoint(urb->pipe),
				usb_pipeout(urb->pipe), 0); */
	}

	port->tty->low_latency = 1;

	zte_send_setup(port);

	return (0);
}

static void zte_close(struct usb_serial_port *port, struct file *filp)
{
	int i;
	struct usb_serial *serial = port->serial;
	struct zte_port_private *portdata;

	dbg("%s", __FUNCTION__);
	portdata = usb_get_serial_port_data(port);

	portdata->rts_state = 0;
	portdata->dtr_state = 0;

	if (serial->dev) {
		mutex_lock(&serial->disc_mutex);
		if (!serial->disconnected)
			zte_send_setup(port);
		mutex_unlock(&serial->disc_mutex);

		/* Stop reading/writing urbs */
		for (i = 0; i < N_IN_URB; i++)
			usb_kill_urb(portdata->in_urbs[i]);
		for (i = 0; i < N_OUT_URB; i++)
			usb_kill_urb(portdata->out_urbs[i]);
	}
	port->tty = NULL;
}

/* Helper functions used by zte_setup_urbs */
static struct urb *zte_setup_urb(struct usb_serial *serial, int endpoint,
		int dir, void *ctx, char *buf, int len,
		void (*callback)(struct urb *))
{
	struct urb *urb;

	if (endpoint == -1)
		return NULL;		/* endpoint not needed */

	urb = usb_alloc_urb(0, GFP_KERNEL);		/* No ISO */
	if (urb == NULL) {
		dbg("%s: alloc for endpoint %d failed.", __FUNCTION__, endpoint);
		return NULL;
	}

		/* Fill URB using supplied data. */
	usb_fill_bulk_urb(urb, serial->dev,
		      usb_sndbulkpipe(serial->dev, endpoint) | dir,
		      buf, len, callback, ctx);

	return urb;
}

/* Setup urbs */
static void zte_setup_urbs(struct usb_serial *serial)
{
	int i,j;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;

	dbg("%s", __FUNCTION__);

	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);

	/* Do indat endpoints first */
		for (j = 0; j < N_IN_URB; ++j) {
			portdata->in_urbs[j] = zte_setup_urb (serial,
                  	port->bulk_in_endpointAddress, USB_DIR_IN, port,
                  	portdata->in_buffer[j], IN_BUFLEN, zte_indat_callback);
		}

		/* outdat endpoints */
		for (j = 0; j < N_OUT_URB; ++j) {
			portdata->out_urbs[j] = zte_setup_urb (serial,
                  	port->bulk_out_endpointAddress, USB_DIR_OUT, port,
                  	portdata->out_buffer[j], OUT_BUFLEN, zte_outdat_callback);
		}
	}
}

static int zte_send_setup(struct usb_serial_port *port)
{
	struct usb_serial *serial = port->serial;
	struct zte_port_private *portdata;

	dbg("%s", __FUNCTION__);

	if (port->number != 0)
		return 0;

	portdata = usb_get_serial_port_data(port);

	if (port->tty) {
		int val = 0;
		if (portdata->dtr_state)
			val |= 0x01;
		if (portdata->rts_state)
			val |= 0x02;

		return usb_control_msg(serial->dev,
				usb_rcvctrlpipe(serial->dev, 0),
				0x22,0x21,val,0,NULL,0,USB_CTRL_SET_TIMEOUT);
	}

	return 0;
}

static int zte_startup(struct usb_serial *serial)
{
	int i, j, err;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;
	u8 *buffer;

	dbg("%s", __FUNCTION__);

	/* Now setup per port private data */
	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		portdata = kzalloc(sizeof(*portdata), GFP_KERNEL);
		if (!portdata) {
			dbg("%s: kmalloc for zte_port_private (%d) failed!.",
					__FUNCTION__, i);
			return (1);
		}

		for (j = 0; j < N_IN_URB; j++) {
			buffer = (u8 *)__get_free_page(GFP_KERNEL);
			if (!buffer)
				goto bail_out_error;
			portdata->in_buffer[j] = buffer;
		}

		for (j = 0; j < N_OUT_URB; j++) {
			buffer = kmalloc(OUT_BUFLEN, GFP_KERNEL);
			if (!buffer)
				goto bail_out_error2;
			portdata->out_buffer[j] = buffer;
		}

		usb_set_serial_port_data(port, portdata);

		if (! port->interrupt_in_urb)
			continue;
		err = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);
		if (err)
			dbg("%s: submit irq_in urb failed %d",
				__FUNCTION__, err);
	}

	zte_setup_urbs(serial);

	return (0);

bail_out_error2:
	for (j = 0; j < N_OUT_URB; j++)
		kfree(portdata->out_buffer[j]);
bail_out_error:
	for (j = 0; j < N_IN_URB; j++)
		if (portdata->in_buffer[j])
			free_page((unsigned long)portdata->in_buffer[j]);
	kfree(portdata);
	return 1;
}

static void zte_shutdown(struct usb_serial *serial)
{
	int i, j;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;

	dbg("%s", __FUNCTION__);

	/* Stop reading/writing urbs */
	for (i = 0; i < serial->num_ports; ++i) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);
		for (j = 0; j < N_IN_URB; j++)
			usb_kill_urb(portdata->in_urbs[j]);
		for (j = 0; j < N_OUT_URB; j++)
			usb_kill_urb(portdata->out_urbs[j]);
	}

	/* Now free them */
	for (i = 0; i < serial->num_ports; ++i) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);

		for (j = 0; j < N_IN_URB; j++) {
			if (portdata->in_urbs[j]) {
				usb_free_urb(portdata->in_urbs[j]);
				free_page((unsigned long)portdata->in_buffer[j]);
				portdata->in_urbs[j] = NULL;
			}
		}
		for (j = 0; j < N_OUT_URB; j++) {
			if (portdata->out_urbs[j]) {
				usb_free_urb(portdata->out_urbs[j]);
				kfree(portdata->out_buffer[j]);
				portdata->out_urbs[j] = NULL;
			}
		}
	}

	/* Now free per port private data */
	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		kfree(usb_get_serial_port_data(port));
	}
}

MODULE_AUTHOR(DRIVER_AUTHOR);
MODULE_DESCRIPTION(DRIVER_DESC);
MODULE_VERSION(DRIVER_VERSION);
MODULE_LICENSE("GPL");

#ifdef CONFIG_USB_DEBUG
module_param(debug, bool, S_IRUGO | S_IWUSR);
MODULE_PARM_DESC(debug, "Debug messages");
#endif

#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27)//use 2.6.26 sourcecode

#include <linux/kernel.h>
#include <linux/jiffies.h>
#include <linux/errno.h>
#include <linux/tty.h>
#include <linux/tty_flip.h>
#include <linux/module.h>
#include <linux/bitops.h>
#include <linux/usb.h>
#include <linux/usb/serial.h>

/* Function prototypes */
static int  zte_open(struct usb_serial_port *port, struct file *filp);
static void zte_close(struct usb_serial_port *port, struct file *filp);
static int  zte_startup(struct usb_serial *serial);
static void zte_shutdown(struct usb_serial *serial);
static void zte_rx_throttle(struct usb_serial_port *port);
static void zte_rx_unthrottle(struct usb_serial_port *port);
static int  zte_write_room(struct usb_serial_port *port);

static void zte_instat_callback(struct urb *urb);

static int zte_write(struct usb_serial_port *port,
			const unsigned char *buf, int count);

static int  zte_chars_in_buffer(struct usb_serial_port *port);
static int  zte_ioctl(struct usb_serial_port *port, struct file *file,
			unsigned int cmd, unsigned long arg);
static void zte_set_termios(struct usb_serial_port *port,
				struct ktermios *old);
static void zte_break_ctl(struct usb_serial_port *port, int break_state);
static int  zte_tiocmget(struct usb_serial_port *port, struct file *file);
static int  zte_tiocmset(struct usb_serial_port *port, struct file *file,
				unsigned int set, unsigned int clear);
static int  zte_send_setup(struct usb_serial_port *port);

/* Vendor and product IDs */
#define zte_VENDOR_ID			0x19d2

static struct usb_device_id zte_ids[] = {
	   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0001, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0002, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0003, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0004, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0005, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0006, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0007, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0008, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0009, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0010, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0011, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0012, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0013, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0014, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0015, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0016, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0017, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0018, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0019, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0020, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0021, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0022, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0023, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0024, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0025, 0xff, 0xff, 0xff) },
    //   { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0026, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0027, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0028, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0029, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0030, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0031, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0032, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0033, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0034, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0035, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0036, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0037, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0038, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0039, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0040, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0041, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0042, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0043, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0044, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0045, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0046, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0047, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0048, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0049, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0050, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0051, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0052, 0xff, 0xff, 0xff) },
    //   { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0053, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0054, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0055, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0056, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0057, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0058, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0059, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0060, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0061, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0062, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0063, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0064, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0065, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0066, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0067, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0068, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0069, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0070, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0071, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0072, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0073, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0074, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0075, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0076, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0077, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0078, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0079, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0080, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0081, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0082, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0083, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0084, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0085, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0086, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0087, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0088, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0089, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0090, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0091, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0092, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0093, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0094, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0095, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0096, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0097, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0098, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0099, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0104, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0105, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0106, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0108, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0117, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0118, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0121, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0122, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0123, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0124, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0125, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0126, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0128, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0130, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0133, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0141, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0144, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0145, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0147, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0148, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0151, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0152, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0153, 0xff, 0xff, 0xff) },
    //{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0154, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0155, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0156, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0157, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0158, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0159, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0160, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0161, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0162, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0164, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0165, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0168, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0170, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0176, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0178, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1008, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1010, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1012, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1057, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1058, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1059, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1060, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1061, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1062, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1063, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1064, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1065, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1066, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1067, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1068, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1069, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1070, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1071, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1072, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1073, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1074, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1075, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1076, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1077, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1078, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1079, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1080, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1081, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1082, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1083, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1084, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1085, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1086, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1087, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1088, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1089, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1090, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1091, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1092, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1093, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1094, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1095, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1096, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1097, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1098, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1099, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1100, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1101, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1102, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1103, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1104, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1105, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1106, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1107, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1108, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1109, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1110, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1111, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1112, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1113, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1114, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1115, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1116, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1117, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1118, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1119, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1120, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1121, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1122, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1123, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1124, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1125, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1126, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1127, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1128, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1129, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1130, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1131, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1132, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1133, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1134, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1135, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1136, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1137, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1138, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1139, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1140, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1141, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1142, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1143, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1144, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1145, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1146, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1147, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1148, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1149, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1150, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1151, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1152, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1153, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1154, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1155, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1156, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1157, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1158, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1159, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1160, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1161, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1162, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1163, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1164, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1165, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1166, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1167, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1168, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1169, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1170, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1244, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1245, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1246, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1247, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1248, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1249, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1250, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1251, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1252, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1253, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1254, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1255, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1256, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1257, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1258, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1259, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1260, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1261, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1262, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1263, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1264, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1265, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1266, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1267, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1268, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1269, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1270, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1271, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1272, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1273, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1274, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1275, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1276, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1277, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1278, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1279, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1280, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1281, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1282, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1283, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1284, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1285, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1286, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1287, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1288, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1289, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1290, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1291, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1292, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1293, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1294, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1295, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1296, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1297, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1298, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1299, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1300, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1401, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1402, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1403, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1404, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1405, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1406, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1407, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1408, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1409, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1410, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1411, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1412, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1413, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1414, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1415, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1416, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1417, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1418, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1419, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1420, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1421, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1422, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1423, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1424, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1425, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1426, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1427, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1428, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1429, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1430, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1431, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1432, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1433, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1434, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1435, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1436, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1437, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1438, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1439, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1440, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1441, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1442, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1443, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1444, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1445, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1446, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1447, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1448, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1449, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1450, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1451, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1452, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1453, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1454, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1455, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1456, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1457, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1458, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1459, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1460, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1461, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1462, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1463, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1464, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1465, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1466, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1467, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1468, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1469, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1470, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1471, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1472, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1473, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1474, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1475, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1476, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1477, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1478, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1479, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1480, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1481, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1482, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1483, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1484, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1485, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1486, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1487, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1488, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1489, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1490, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1491, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1492, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1493, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1494, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1495, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1496, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1497, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1498, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1499, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1500, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1501, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1502, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1503, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1504, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1505, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1506, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1507, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1508, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1509, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1510, 0xff, 0xff, 0xff) },       
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x2002, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x2003, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0xFFEC, 0xff, 0xff, 0xff) },

    { USB_DEVICE_AND_INTERFACE_INFO(TPLink_VENDOR_ID, 0x7E11, 0xff, 0xff, 0xff) },/*TPLink*/
    { USB_DEVICE_AND_INTERFACE_INFO(QUALCOMM_VENDOR_ID, 0x9001, 0xff, 0xff, 0xff) },/*QUALCOMM_VENDOR_ID*/
    { USB_DEVICE_AND_INTERFACE_INFO(QUALCOMM_VENDOR_ID, 0x9002, 0xff, 0xff, 0xff) },

	{ } /* Terminating entry */
};
MODULE_DEVICE_TABLE(usb, zte_ids);

static struct usb_driver zte_driver = {
	.name       = "zte",
	.probe      = usb_serial_probe,
	.disconnect = usb_serial_disconnect,
	.id_table   = zte_ids,
	.no_dynamic_id = 	1,
};

/* The card has three separate interfaces, which the serial driver
 * recognizes separately, thus num_port=1.
 */

static struct usb_serial_driver zte_1port_device = {
	.driver = {
		.owner =	THIS_MODULE,
		.name =		"zte1",
	},
	.description       = "GSM modem (1-port)",
	.usb_driver        = &zte_driver,
	.id_table          = zte_ids,
	.num_ports         = 1,
	.open              = zte_open,
	.close             = zte_close,
	.write             = zte_write,
	.write_room        = zte_write_room,
	.chars_in_buffer   = zte_chars_in_buffer,
	.throttle          = zte_rx_throttle,
	.unthrottle        = zte_rx_unthrottle,
	.ioctl             = zte_ioctl,
	.set_termios       = zte_set_termios,
	.break_ctl         = zte_break_ctl,
	.tiocmget          = zte_tiocmget,
	.tiocmset          = zte_tiocmset,
	.attach            = zte_startup,
	.shutdown          = zte_shutdown,
	.read_int_callback = zte_instat_callback,
};

#ifdef CONFIG_USB_DEBUG
static int debug;
#else
#define debug 0
#endif

/* per port private data */

#define N_IN_URB 4
#define N_OUT_URB 4
#define IN_BUFLEN 4096
#define OUT_BUFLEN 4096

struct zte_port_private {
	/* Input endpoints and buffer for this port */
	struct urb *in_urbs[N_IN_URB];
	u8 *in_buffer[N_IN_URB];
	/* Output endpoints and buffer for this port */
	struct urb *out_urbs[N_OUT_URB];
	u8 *out_buffer[N_OUT_URB];
	unsigned long out_busy;		/* Bit vector of URBs in use */

	/* Settings for the port */
	int rts_state;	/* Handshaking pins (outputs) */
	int dtr_state;
	int cts_state;	/* Handshaking pins (inputs) */
	int dsr_state;
	int dcd_state;
	int ri_state;

	unsigned long tx_start_time[N_OUT_URB];
};

/* Functions used by new usb-serial code. */
static int __init zte_init(void)
{
	int retval;
	retval = usb_serial_register(&zte_1port_device);
	if (retval)
		goto failed_1port_device_register;
	retval = usb_register(&zte_driver);
	if (retval)
		goto failed_driver_register;

	info(DRIVER_DESC ": " DRIVER_VERSION);

	return 0;

failed_driver_register:
	usb_serial_deregister (&zte_1port_device);
failed_1port_device_register:
	return retval;
}

static void __exit zte_exit(void)
{
	usb_deregister (&zte_driver);
	usb_serial_deregister (&zte_1port_device);
}

module_init(zte_init);
module_exit(zte_exit);

static void zte_rx_throttle(struct usb_serial_port *port)
{
	dbg("%s", __func__);
}

static void zte_rx_unthrottle(struct usb_serial_port *port)
{
	dbg("%s", __func__);
}

static void zte_break_ctl(struct usb_serial_port *port, int break_state)
{
	/* Unfortunately, I don't know how to send a break */
	dbg("%s", __func__);
}

static void zte_set_termios(struct usb_serial_port *port,
			struct ktermios *old_termios)
{
	dbg("%s", __func__);
	/* Doesn't support zte setting */
	tty_termios_copy_hw(port->tty->termios, old_termios);
	zte_send_setup(port);
}

static int zte_tiocmget(struct usb_serial_port *port, struct file *file)
{
	unsigned int value;
	struct zte_port_private *portdata;

	portdata = usb_get_serial_port_data(port);

	value = ((portdata->rts_state) ? TIOCM_RTS : 0) |
		((portdata->dtr_state) ? TIOCM_DTR : 0) |
		((portdata->cts_state) ? TIOCM_CTS : 0) |
		((portdata->dsr_state) ? TIOCM_DSR : 0) |
		((portdata->dcd_state) ? TIOCM_CAR : 0) |
		((portdata->ri_state) ? TIOCM_RNG : 0);

	return value;
}

static int zte_tiocmset(struct usb_serial_port *port, struct file *file,
			unsigned int set, unsigned int clear)
{
	struct zte_port_private *portdata;

	portdata = usb_get_serial_port_data(port);

	/* FIXME: what locks portdata fields ? */
	if (set & TIOCM_RTS)
		portdata->rts_state = 1;
	if (set & TIOCM_DTR)
		portdata->dtr_state = 1;

	if (clear & TIOCM_RTS)
		portdata->rts_state = 0;
	if (clear & TIOCM_DTR)
		portdata->dtr_state = 0;
	return zte_send_setup(port);
}

static int zte_ioctl(struct usb_serial_port *port, struct file *file,
			unsigned int cmd, unsigned long arg)
{
	return -ENOIOCTLCMD;
}

/* Write */
static int zte_write(struct usb_serial_port *port,
			const unsigned char *buf, int count)
{
	struct zte_port_private *portdata;
	int i;
	int left, todo;
	struct urb *this_urb = NULL; /* spurious */
	int err;

	portdata = usb_get_serial_port_data(port);

	dbg("%s: write (%d chars)", __func__, count);

	i = 0;
	left = count;
	for (i=0; left > 0 && i < N_OUT_URB; i++) {
		todo = left;
		if (todo > OUT_BUFLEN)
			todo = OUT_BUFLEN;

		this_urb = portdata->out_urbs[i];
		if (test_and_set_bit(i, &portdata->out_busy)) {
			if (time_before(jiffies,
					portdata->tx_start_time[i] + 10 * HZ))
				continue;
			usb_unlink_urb(this_urb);
			continue;
		}
		if (this_urb->status != 0)
			dbg("usb_write %p failed (err=%d)",
				this_urb, this_urb->status);

		dbg("%s: endpoint %d buf %d", __func__,
			usb_pipeendpoint(this_urb->pipe), i);

		/* send the data */
		memcpy (this_urb->transfer_buffer, buf, todo);
		this_urb->transfer_buffer_length = todo;

		this_urb->dev = port->serial->dev;
		err = usb_submit_urb(this_urb, GFP_ATOMIC);
		if (err) {
			dbg("usb_submit_urb %p (write bulk) failed "
				"(%d, has %d)", this_urb,
				err, this_urb->status);
			clear_bit(i, &portdata->out_busy);
			continue;
		}
		portdata->tx_start_time[i] = jiffies;
		buf += todo;
		left -= todo;
	}

	count -= left;
	dbg("%s: wrote (did %d)", __func__, count);
	return count;
}

static void zte_indat_callback(struct urb *urb)
{
	int err;
	int endpoint;
	struct usb_serial_port *port;
	struct tty_struct *tty;
	unsigned char *data = urb->transfer_buffer;
	int status = urb->status;

	dbg("%s: %p", __func__, urb);

	endpoint = usb_pipeendpoint(urb->pipe);
	port =  urb->context;

	if (status) {
		dbg("%s: nonzero status: %d on endpoint %02x.",
		    __func__, status, endpoint);
	} else {
		tty = port->tty;
		if (urb->actual_length) {
			tty_buffer_request_room(tty, urb->actual_length);
			tty_insert_flip_string(tty, data, urb->actual_length);
			tty_flip_buffer_push(tty);
		} else {
			dbg("%s: empty read urb received", __func__);
		}

		/* Resubmit urb so we continue receiving */
		if (port->open_count && status != -ESHUTDOWN) {
			err = usb_submit_urb(urb, GFP_ATOMIC);
			if (err)
				printk(KERN_ERR "%s: resubmit read urb failed. "
					"(%d)", __func__, err);
		}
	}
	return;
}

static void zte_outdat_callback(struct urb *urb)
{
	struct usb_serial_port *port;
	struct zte_port_private *portdata;
	int i;

	dbg("%s", __func__);

	port =  urb->context;

	usb_serial_port_softint(port);

	portdata = usb_get_serial_port_data(port);
	for (i = 0; i < N_OUT_URB; ++i) {
		if (portdata->out_urbs[i] == urb) {
			smp_mb__before_clear_bit();
			clear_bit(i, &portdata->out_busy);
			break;
		}
	}
}

static void zte_instat_callback(struct urb *urb)
{
	int err;
	int status = urb->status;
	struct usb_serial_port *port =  urb->context;
	struct zte_port_private *portdata = usb_get_serial_port_data(port);
	struct usb_serial *serial = port->serial;

	dbg("%s", __func__);
	dbg("%s: urb %p port %p has data %p", __func__,urb,port,portdata);

	if (status == 0) {
		struct usb_ctrlrequest *req_pkt =
				(struct usb_ctrlrequest *)urb->transfer_buffer;

		if (!req_pkt) {
			dbg("%s: NULL req_pkt\n", __func__);
			return;
		}
		if ((req_pkt->bRequestType == 0xA1) &&
				(req_pkt->bRequest == 0x20)) {
			int old_dcd_state;
			unsigned char signals = *((unsigned char *)
					urb->transfer_buffer +
					sizeof(struct usb_ctrlrequest));

			dbg("%s: signal x%x", __func__, signals);

			old_dcd_state = portdata->dcd_state;
			portdata->cts_state = 1;
			portdata->dcd_state = ((signals & 0x01) ? 1 : 0);
			portdata->dsr_state = ((signals & 0x02) ? 1 : 0);
			portdata->ri_state = ((signals & 0x08) ? 1 : 0);

			if (port->tty && !C_CLOCAL(port->tty) &&
					old_dcd_state && !portdata->dcd_state)
				tty_hangup(port->tty);
		} else {
			dbg("%s: type %x req %x", __func__,
				req_pkt->bRequestType,req_pkt->bRequest);
		}
	} else
		dbg("%s: error %d", __func__, status);

	/* Resubmit urb so we continue receiving IRQ data */
	if (status != -ESHUTDOWN) {
		urb->dev = serial->dev;
		err = usb_submit_urb(urb, GFP_ATOMIC);
		if (err)
			dbg("%s: resubmit intr urb failed. (%d)",
				__func__, err);
	}
}

static int zte_write_room(struct usb_serial_port *port)
{
	struct zte_port_private *portdata;

	int i;
	int data_len = 0;
	struct urb *this_urb;

	portdata = usb_get_serial_port_data(port);


	for (i=0; i < N_OUT_URB; i++) {
		this_urb = portdata->out_urbs[i];
		if (this_urb && !test_bit(i, &portdata->out_busy))
			data_len += OUT_BUFLEN;
	}

	dbg("%s: %d", __func__, data_len);
	return data_len;
}

static int zte_chars_in_buffer(struct usb_serial_port *port)
{
	struct zte_port_private *portdata;
	int i;
	int data_len = 0;
	struct urb *this_urb;

	portdata = usb_get_serial_port_data(port);

	for (i=0; i < N_OUT_URB; i++) {
		this_urb = portdata->out_urbs[i];
		/* FIXME: This locking is insufficient as this_urb may
		   go unused during the test */
		if (this_urb && test_bit(i, &portdata->out_busy))
			data_len += this_urb->transfer_buffer_length;
	}
	dbg("%s: %d", __func__, data_len);
	return data_len;
}

static int zte_open(struct usb_serial_port *port, struct file *filp)
{
	struct zte_port_private *portdata;
	struct usb_serial *serial = port->serial;
	int i, err;
	struct urb *urb;

	portdata = usb_get_serial_port_data(port);

	dbg("%s", __func__);

	/* Set some sane defaults */
	portdata->rts_state = 1;
	portdata->dtr_state = 1;

	/* Reset low level data toggle and start reading from endpoints */
	for (i = 0; i < N_IN_URB; i++) {
		urb = portdata->in_urbs[i];
		if (! urb)
			continue;
		if (urb->dev != serial->dev) {
			dbg("%s: dev %p != %p", __func__,
				urb->dev, serial->dev);
			continue;
		}

		/*
		 * make sure endpoint data toggle is synchronized with the
		 * device
		 */
		usb_clear_halt(urb->dev, urb->pipe);

		err = usb_submit_urb(urb, GFP_KERNEL);
		if (err) {
			dbg("%s: submit urb %d failed (%d) %d",
				__func__, i, err,
				urb->transfer_buffer_length);
		}
	}

	/* Reset low level data toggle on out endpoints */
	for (i = 0; i < N_OUT_URB; i++) {
		urb = portdata->out_urbs[i];
		if (! urb)
			continue;
		urb->dev = serial->dev;
		/* usb_settoggle(urb->dev, usb_pipeendpoint(urb->pipe),
				usb_pipeout(urb->pipe), 0); */
	}

	port->tty->low_latency = 1;

	zte_send_setup(port);

	return (0);
}

static void zte_close(struct usb_serial_port *port, struct file *filp)
{
	int i;
	struct usb_serial *serial = port->serial;
	struct zte_port_private *portdata;

	dbg("%s", __func__);
	portdata = usb_get_serial_port_data(port);

	portdata->rts_state = 0;
	portdata->dtr_state = 0;

	if (serial->dev) {
		mutex_lock(&serial->disc_mutex);
		if (!serial->disconnected)
			zte_send_setup(port);
		mutex_unlock(&serial->disc_mutex);

		/* Stop reading/writing urbs */
		for (i = 0; i < N_IN_URB; i++)
			usb_kill_urb(portdata->in_urbs[i]);
		for (i = 0; i < N_OUT_URB; i++)
			usb_kill_urb(portdata->out_urbs[i]);
	}
	port->tty = NULL;
}

/* Helper functions used by zte_setup_urbs */
static struct urb *zte_setup_urb(struct usb_serial *serial, int endpoint,
		int dir, void *ctx, char *buf, int len,
		void (*callback)(struct urb *))
{
	struct urb *urb;

	if (endpoint == -1)
		return NULL;		/* endpoint not needed */

	urb = usb_alloc_urb(0, GFP_KERNEL);		/* No ISO */
	if (urb == NULL) {
		dbg("%s: alloc for endpoint %d failed.", __func__, endpoint);
		return NULL;
	}

		/* Fill URB using supplied data. */
	usb_fill_bulk_urb(urb, serial->dev,
		      usb_sndbulkpipe(serial->dev, endpoint) | dir,
		      buf, len, callback, ctx);

	return urb;
}

/* Setup urbs */
static void zte_setup_urbs(struct usb_serial *serial)
{
	int i,j;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;

	dbg("%s", __func__);

	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);

	/* Do indat endpoints first */
		for (j = 0; j < N_IN_URB; ++j) {
			portdata->in_urbs[j] = zte_setup_urb (serial,
                  	port->bulk_in_endpointAddress, USB_DIR_IN, port,
                  	portdata->in_buffer[j], IN_BUFLEN, zte_indat_callback);
		}

		/* outdat endpoints */
		for (j = 0; j < N_OUT_URB; ++j) {
			portdata->out_urbs[j] = zte_setup_urb (serial,
                  	port->bulk_out_endpointAddress, USB_DIR_OUT, port,
                  	portdata->out_buffer[j], OUT_BUFLEN, zte_outdat_callback);
		}
	}
}


/** send RTS/DTR state to the port.
 *
 * This is exactly the same as SET_CONTROL_LINE_STATE from the PSTN
 * CDC.
*/
static int zte_send_setup(struct usb_serial_port *port)
{
	struct usb_serial *serial = port->serial;
	struct zte_port_private *portdata;
	int ifNum = serial->interface->cur_altsetting->desc.bInterfaceNumber;
	dbg("%s", __func__);

	portdata = usb_get_serial_port_data(port);

	if (port->tty) {
		int val = 0;
		if (portdata->dtr_state)
			val |= 0x01;
		if (portdata->rts_state)
			val |= 0x02;

		return usb_control_msg(serial->dev,
				usb_rcvctrlpipe(serial->dev, 0),
				0x22,0x21,val,ifNum,NULL,0,USB_CTRL_SET_TIMEOUT);
	}

	return 0;
}

static int zte_startup(struct usb_serial *serial)
{
	int i, j, err;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;
	u8 *buffer;

	dbg("%s", __func__);

	/* Now setup per port private data */
	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		portdata = kzalloc(sizeof(*portdata), GFP_KERNEL);
		if (!portdata) {
			dbg("%s: kmalloc for zte_port_private (%d) failed!.",
					__func__, i);
			return (1);
		}

		for (j = 0; j < N_IN_URB; j++) {
			buffer = (u8 *)__get_free_page(GFP_KERNEL);
			if (!buffer)
				goto bail_out_error;
			portdata->in_buffer[j] = buffer;
		}

		for (j = 0; j < N_OUT_URB; j++) {
			buffer = kmalloc(OUT_BUFLEN, GFP_KERNEL);
			if (!buffer)
				goto bail_out_error2;
			portdata->out_buffer[j] = buffer;
		}

		usb_set_serial_port_data(port, portdata);

		if (! port->interrupt_in_urb)
			continue;
		err = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);
		if (err)
			dbg("%s: submit irq_in urb failed %d",
				__func__, err);
	}

	zte_setup_urbs(serial);

	return (0);

bail_out_error2:
	for (j = 0; j < N_OUT_URB; j++)
		kfree(portdata->out_buffer[j]);
bail_out_error:
	for (j = 0; j < N_IN_URB; j++)
		if (portdata->in_buffer[j])
			free_page((unsigned long)portdata->in_buffer[j]);
	kfree(portdata);
	return 1;
}

static void zte_shutdown(struct usb_serial *serial)
{
	int i, j;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;

	dbg("%s", __func__);

	/* Stop reading/writing urbs */
	for (i = 0; i < serial->num_ports; ++i) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);
		for (j = 0; j < N_IN_URB; j++)
			usb_kill_urb(portdata->in_urbs[j]);
		for (j = 0; j < N_OUT_URB; j++)
			usb_kill_urb(portdata->out_urbs[j]);
	}

	/* Now free them */
	for (i = 0; i < serial->num_ports; ++i) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);

		for (j = 0; j < N_IN_URB; j++) {
			if (portdata->in_urbs[j]) {
				usb_free_urb(portdata->in_urbs[j]);
				free_page((unsigned long)portdata->in_buffer[j]);
				portdata->in_urbs[j] = NULL;
			}
		}
		for (j = 0; j < N_OUT_URB; j++) {
			if (portdata->out_urbs[j]) {
				usb_free_urb(portdata->out_urbs[j]);
				kfree(portdata->out_buffer[j]);
				portdata->out_urbs[j] = NULL;
			}
		}
	}

	/* Now free per port private data */
	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		kfree(usb_get_serial_port_data(port));
	}
}

MODULE_AUTHOR(DRIVER_AUTHOR);
MODULE_DESCRIPTION(DRIVER_DESC);
MODULE_VERSION(DRIVER_VERSION);
MODULE_LICENSE("GPL");

#ifdef CONFIG_USB_DEBUG
module_param(debug, bool, S_IRUGO | S_IWUSR);
MODULE_PARM_DESC(debug, "Debug messages");
#endif

#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,28)//use 2.6.27 sourcecode
#include <linux/kernel.h>
#include <linux/jiffies.h>
#include <linux/errno.h>
#include <linux/tty.h>
#include <linux/tty_flip.h>
#include <linux/module.h>
#include <linux/bitops.h>
#include <linux/usb.h>
#include <linux/usb/serial.h>

/* Function prototypes */
static int  zte_open(struct tty_struct *tty, struct usb_serial_port *port,

							struct file *filp);
static void zte_close(struct tty_struct *tty, struct usb_serial_port *port,
							struct file *filp);
static int  zte_startup(struct usb_serial *serial);
static void zte_shutdown(struct usb_serial *serial);
static int  zte_write_room(struct tty_struct *tty);

static void zte_instat_callback(struct urb *urb);

static int zte_write(struct tty_struct *tty, struct usb_serial_port *port,
			const unsigned char *buf, int count);
static int  zte_chars_in_buffer(struct tty_struct *tty);
static void zte_set_termios(struct tty_struct *tty,
			struct usb_serial_port *port, struct ktermios *old);
static int  zte_tiocmget(struct tty_struct *tty, struct file *file);
static int  zte_tiocmset(struct tty_struct *tty, struct file *file,
				unsigned int set, unsigned int clear);
static int  zte_send_setup(struct tty_struct *tty, struct usb_serial_port *port);

/* Vendor and product IDs */
#define zte_VENDOR_ID			0x19d2

static struct usb_device_id zte_ids[] = {
	   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0001, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0002, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0003, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0004, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0005, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0006, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0007, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0008, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0009, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0010, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0011, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0012, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0013, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0014, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0015, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0016, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0017, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0018, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0019, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0020, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0021, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0022, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0023, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0024, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0025, 0xff, 0xff, 0xff) },
    //   { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0026, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0027, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0028, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0029, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0030, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0031, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0032, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0033, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0034, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0035, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0036, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0037, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0038, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0039, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0040, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0041, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0042, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0043, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0044, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0045, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0046, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0047, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0048, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0049, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0050, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0051, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0052, 0xff, 0xff, 0xff) },
    //   { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0053, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0054, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0055, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0056, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0057, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0058, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0059, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0060, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0061, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0062, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0063, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0064, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0065, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0066, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0067, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0068, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0069, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0070, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0071, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0072, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0073, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0074, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0075, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0076, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0077, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0078, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0079, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0080, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0081, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0082, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0083, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0084, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0085, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0086, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0087, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0088, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0089, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0090, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0091, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0092, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0093, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0094, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0095, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0096, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0097, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0098, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0099, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0104, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0105, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0106, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0108, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0117, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0118, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0121, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0122, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0123, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0124, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0125, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0126, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0128, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0130, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0133, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0141, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0144, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0145, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0147, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0148, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0151, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0152, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0153, 0xff, 0xff, 0xff) },
    //{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0154, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0155, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0156, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0157, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0158, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0159, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0160, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0161, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0162, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0164, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0165, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0168, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0170, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0176, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0178, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1008, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1010, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1012, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1057, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1058, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1059, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1060, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1061, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1062, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1063, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1064, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1065, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1066, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1067, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1068, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1069, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1070, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1071, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1072, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1073, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1074, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1075, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1076, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1077, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1078, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1079, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1080, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1081, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1082, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1083, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1084, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1085, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1086, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1087, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1088, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1089, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1090, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1091, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1092, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1093, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1094, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1095, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1096, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1097, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1098, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1099, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1100, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1101, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1102, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1103, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1104, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1105, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1106, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1107, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1108, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1109, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1110, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1111, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1112, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1113, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1114, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1115, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1116, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1117, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1118, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1119, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1120, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1121, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1122, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1123, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1124, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1125, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1126, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1127, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1128, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1129, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1130, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1131, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1132, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1133, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1134, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1135, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1136, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1137, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1138, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1139, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1140, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1141, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1142, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1143, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1144, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1145, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1146, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1147, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1148, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1149, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1150, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1151, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1152, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1153, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1154, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1155, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1156, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1157, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1158, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1159, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1160, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1161, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1162, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1163, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1164, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1165, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1166, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1167, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1168, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1169, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1170, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1244, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1245, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1246, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1247, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1248, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1249, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1250, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1251, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1252, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1253, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1254, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1255, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1256, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1257, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1258, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1259, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1260, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1261, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1262, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1263, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1264, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1265, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1266, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1267, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1268, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1269, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1270, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1271, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1272, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1273, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1274, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1275, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1276, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1277, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1278, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1279, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1280, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1281, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1282, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1283, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1284, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1285, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1286, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1287, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1288, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1289, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1290, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1291, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1292, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1293, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1294, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1295, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1296, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1297, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1298, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1299, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1300, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1401, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1402, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1403, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1404, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1405, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1406, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1407, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1408, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1409, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1410, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1411, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1412, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1413, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1414, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1415, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1416, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1417, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1418, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1419, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1420, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1421, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1422, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1423, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1424, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1425, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1426, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1427, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1428, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1429, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1430, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1431, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1432, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1433, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1434, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1435, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1436, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1437, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1438, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1439, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1440, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1441, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1442, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1443, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1444, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1445, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1446, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1447, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1448, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1449, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1450, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1451, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1452, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1453, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1454, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1455, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1456, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1457, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1458, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1459, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1460, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1461, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1462, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1463, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1464, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1465, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1466, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1467, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1468, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1469, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1470, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1471, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1472, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1473, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1474, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1475, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1476, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1477, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1478, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1479, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1480, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1481, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1482, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1483, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1484, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1485, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1486, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1487, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1488, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1489, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1490, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1491, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1492, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1493, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1494, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1495, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1496, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1497, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1498, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1499, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1500, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1501, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1502, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1503, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1504, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1505, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1506, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1507, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1508, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1509, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1510, 0xff, 0xff, 0xff) },       
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x2002, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x2003, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0xFFEC, 0xff, 0xff, 0xff) },

    { USB_DEVICE_AND_INTERFACE_INFO(TPLink_VENDOR_ID, 0x7E11, 0xff, 0xff, 0xff) },/*TPLink*/
    { USB_DEVICE_AND_INTERFACE_INFO(QUALCOMM_VENDOR_ID, 0x9001, 0xff, 0xff, 0xff) },/*QUALCOMM_VENDOR_ID*/
    { USB_DEVICE_AND_INTERFACE_INFO(QUALCOMM_VENDOR_ID, 0x9002, 0xff, 0xff, 0xff) },

	{ } /* Terminating entry */
};
MODULE_DEVICE_TABLE(usb, zte_ids);

static struct usb_driver zte_driver = {
	.name       = "zte",
	.probe      = usb_serial_probe,
	.disconnect = usb_serial_disconnect,
	.id_table   = zte_ids,
	.no_dynamic_id = 	1,
};

/* The card has three separate interfaces, which the serial driver
 * recognizes separately, thus num_port=1.
 */

static struct usb_serial_driver zte_1port_device = {
	.driver = {
		.owner =	THIS_MODULE,
		.name =		"zte1",
	},
	.description       = "GSM modem (1-port)",
	.usb_driver        = &zte_driver,
	.id_table          = zte_ids,
	.num_ports         = 1,
	.open              = zte_open,
	.close             = zte_close,
	.write             = zte_write,
	.write_room        = zte_write_room,
	.chars_in_buffer   = zte_chars_in_buffer,
	.set_termios       = zte_set_termios,
	.tiocmget          = zte_tiocmget,
	.tiocmset          = zte_tiocmset,
	.attach            = zte_startup,
	.shutdown          = zte_shutdown,
	.read_int_callback = zte_instat_callback,
};

static int debug;

/* per port private data */

#define N_IN_URB 4
#define N_OUT_URB 4
#define IN_BUFLEN 4096
#define OUT_BUFLEN 4096

struct zte_port_private {
	/* Input endpoints and buffer for this port */
	struct urb *in_urbs[N_IN_URB];
	u8 *in_buffer[N_IN_URB];
	/* Output endpoints and buffer for this port */
	struct urb *out_urbs[N_OUT_URB];
	u8 *out_buffer[N_OUT_URB];
	unsigned long out_busy;		/* Bit vector of URBs in use */

	/* Settings for the port */
	int rts_state;	/* Handshaking pins (outputs) */
	int dtr_state;
	int cts_state;	/* Handshaking pins (inputs) */
	int dsr_state;
	int dcd_state;
	int ri_state;

	unsigned long tx_start_time[N_OUT_URB];
};

/* Functions used by new usb-serial code. */
static int __init zte_init(void)
{
	int retval;
	retval = usb_serial_register(&zte_1port_device);
	if (retval)
		goto failed_1port_device_register;
	retval = usb_register(&zte_driver);
	if (retval)
		goto failed_driver_register;

	info(DRIVER_DESC ": " DRIVER_VERSION);

	return 0;

failed_driver_register:
	usb_serial_deregister(&zte_1port_device);
failed_1port_device_register:
	return retval;
}

static void __exit zte_exit(void)
{
	usb_deregister(&zte_driver);
	usb_serial_deregister(&zte_1port_device);
}

module_init(zte_init);
module_exit(zte_exit);

static void zte_set_termios(struct tty_struct *tty,
		struct usb_serial_port *port, struct ktermios *old_termios)
{
	dbg("%s", __func__);
	/* Doesn't support zte setting */
	tty_termios_copy_hw(tty->termios, old_termios);
	zte_send_setup(tty, port);
}

static int zte_tiocmget(struct tty_struct *tty, struct file *file)
{
	struct usb_serial_port *port = tty->driver_data;
	unsigned int value;
	struct zte_port_private *portdata;

	portdata = usb_get_serial_port_data(port);

	value = ((portdata->rts_state) ? TIOCM_RTS : 0) |
		((portdata->dtr_state) ? TIOCM_DTR : 0) |
		((portdata->cts_state) ? TIOCM_CTS : 0) |
		((portdata->dsr_state) ? TIOCM_DSR : 0) |
		((portdata->dcd_state) ? TIOCM_CAR : 0) |
		((portdata->ri_state) ? TIOCM_RNG : 0);

	return value;
}

static int zte_tiocmset(struct tty_struct *tty, struct file *file,
			unsigned int set, unsigned int clear)
{
	struct usb_serial_port *port = tty->driver_data;
	struct zte_port_private *portdata;

	portdata = usb_get_serial_port_data(port);

	/* FIXME: what locks portdata fields ? */
	if (set & TIOCM_RTS)
		portdata->rts_state = 1;
	if (set & TIOCM_DTR)
		portdata->dtr_state = 1;

	if (clear & TIOCM_RTS)
		portdata->rts_state = 0;
	if (clear & TIOCM_DTR)
		portdata->dtr_state = 0;
	return zte_send_setup(tty, port);
}

/* Write */
static int zte_write(struct tty_struct *tty, struct usb_serial_port *port,
			const unsigned char *buf, int count)
{
	struct zte_port_private *portdata;
	int i;
	int left, todo;
	struct urb *this_urb = NULL; /* spurious */
	int err;

	portdata = usb_get_serial_port_data(port);

	dbg("%s: write (%d chars)", __func__, count);

	i = 0;
	left = count;
	for (i = 0; left > 0 && i < N_OUT_URB; i++) {
		todo = left;
		if (todo > OUT_BUFLEN)
			todo = OUT_BUFLEN;

		this_urb = portdata->out_urbs[i];
		if (test_and_set_bit(i, &portdata->out_busy)) {
			if (time_before(jiffies,
					portdata->tx_start_time[i] + 10 * HZ))
				continue;
			usb_unlink_urb(this_urb);
			continue;
		}
		if (this_urb->status != 0)
			dbg("usb_write %p failed (err=%d)",
				this_urb, this_urb->status);

		dbg("%s: endpoint %d buf %d", __func__,
			usb_pipeendpoint(this_urb->pipe), i);

		/* send the data */
		memcpy(this_urb->transfer_buffer, buf, todo);
		this_urb->transfer_buffer_length = todo;

		this_urb->dev = port->serial->dev;
		err = usb_submit_urb(this_urb, GFP_ATOMIC);
		if (err) {
			dbg("usb_submit_urb %p (write bulk) failed "
				"(%d, has %d)", this_urb,
				err, this_urb->status);
			clear_bit(i, &portdata->out_busy);
			continue;
		}
		portdata->tx_start_time[i] = jiffies;
		buf += todo;
		left -= todo;
	}

	count -= left;
	dbg("%s: wrote (did %d)", __func__, count);
	return count;
}

static void zte_indat_callback(struct urb *urb)
{
	int err;
	int endpoint;
	struct usb_serial_port *port;
	struct tty_struct *tty;
	unsigned char *data = urb->transfer_buffer;
	int status = urb->status;

	dbg("%s: %p", __func__, urb);

	endpoint = usb_pipeendpoint(urb->pipe);
	port =  urb->context;

	if (status) {
		dbg("%s: nonzero status: %d on endpoint %02x.",
		    __func__, status, endpoint);
	} else {
		tty = port->port.tty;
		if (urb->actual_length) {
			tty_buffer_request_room(tty, urb->actual_length);
			tty_insert_flip_string(tty, data, urb->actual_length);
			tty_flip_buffer_push(tty);
		} else {
			dbg("%s: empty read urb received", __func__);
		}

		/* Resubmit urb so we continue receiving */
		if (port->port.count && status != -ESHUTDOWN) {
			err = usb_submit_urb(urb, GFP_ATOMIC);
			if (err)
				printk(KERN_ERR "%s: resubmit read urb failed. "
					"(%d)", __func__, err);
		}
	}
	return;
}

static void zte_outdat_callback(struct urb *urb)
{
	struct usb_serial_port *port;
	struct zte_port_private *portdata;
	int i;

	dbg("%s", __func__);

	port =  urb->context;

	usb_serial_port_softint(port);

	portdata = usb_get_serial_port_data(port);
	for (i = 0; i < N_OUT_URB; ++i) {
		if (portdata->out_urbs[i] == urb) {
			smp_mb__before_clear_bit();
			clear_bit(i, &portdata->out_busy);
			break;
		}
	}
}

static void zte_instat_callback(struct urb *urb)
{
	int err;
	int status = urb->status;
	struct usb_serial_port *port =  urb->context;
	struct zte_port_private *portdata = usb_get_serial_port_data(port);
	struct usb_serial *serial = port->serial;

	dbg("%s", __func__);
	dbg("%s: urb %p port %p has data %p", __func__, urb, port, portdata);

	if (status == 0) {
		struct usb_ctrlrequest *req_pkt =
				(struct usb_ctrlrequest *)urb->transfer_buffer;

		if (!req_pkt) {
			dbg("%s: NULL req_pkt\n", __func__);
			return;
		}
		if ((req_pkt->bRequestType == 0xA1) &&
				(req_pkt->bRequest == 0x20)) {
			int old_dcd_state;
			unsigned char signals = *((unsigned char *)
					urb->transfer_buffer +
					sizeof(struct usb_ctrlrequest));

			dbg("%s: signal x%x", __func__, signals);

			old_dcd_state = portdata->dcd_state;
			portdata->cts_state = 1;
			portdata->dcd_state = ((signals & 0x01) ? 1 : 0);
			portdata->dsr_state = ((signals & 0x02) ? 1 : 0);
			portdata->ri_state = ((signals & 0x08) ? 1 : 0);

			if (port->port.tty && !C_CLOCAL(port->port.tty) &&
					old_dcd_state && !portdata->dcd_state)
				tty_hangup(port->port.tty);
		} else {
			dbg("%s: type %x req %x", __func__,
				req_pkt->bRequestType, req_pkt->bRequest);
		}
	} else
		dbg("%s: error %d", __func__, status);

	/* Resubmit urb so we continue receiving IRQ data */
	if (status != -ESHUTDOWN) {
		urb->dev = serial->dev;
		err = usb_submit_urb(urb, GFP_ATOMIC);
		if (err)
			dbg("%s: resubmit intr urb failed. (%d)",
				__func__, err);
	}
}

static int zte_write_room(struct tty_struct *tty)
{
	struct usb_serial_port *port = tty->driver_data;
	struct zte_port_private *portdata;
	int i;
	int data_len = 0;
	struct urb *this_urb;

	portdata = usb_get_serial_port_data(port);


	for (i = 0; i < N_OUT_URB; i++) {
		this_urb = portdata->out_urbs[i];
		if (this_urb && !test_bit(i, &portdata->out_busy))
			data_len += OUT_BUFLEN;
	}

	dbg("%s: %d", __func__, data_len);
	return data_len;
}

static int zte_chars_in_buffer(struct tty_struct *tty)
{
	struct usb_serial_port *port = tty->driver_data;
	struct zte_port_private *portdata;
	int i;
	int data_len = 0;
	struct urb *this_urb;

	portdata = usb_get_serial_port_data(port);

	for (i = 0; i < N_OUT_URB; i++) {
		this_urb = portdata->out_urbs[i];
		/* FIXME: This locking is insufficient as this_urb may
		   go unused during the test */
		if (this_urb && test_bit(i, &portdata->out_busy))
			data_len += this_urb->transfer_buffer_length;
	}
	dbg("%s: %d", __func__, data_len);
	return data_len;
}

static int zte_open(struct tty_struct *tty,
			struct usb_serial_port *port, struct file *filp)
{
	struct zte_port_private *portdata;
	struct usb_serial *serial = port->serial;
	int i, err;
	struct urb *urb;

	portdata = usb_get_serial_port_data(port);

	dbg("%s", __func__);

	/* Set some sane defaults */
	portdata->rts_state = 1;
	portdata->dtr_state = 1;

	/* Reset low level data toggle and start reading from endpoints */
	for (i = 0; i < N_IN_URB; i++) {
		urb = portdata->in_urbs[i];
		if (!urb)
			continue;
		if (urb->dev != serial->dev) {
			dbg("%s: dev %p != %p", __func__,
				urb->dev, serial->dev);
			continue;
		}

		/*
		 * make sure endpoint data toggle is synchronized with the
		 * device
		 */
		usb_clear_halt(urb->dev, urb->pipe);

		err = usb_submit_urb(urb, GFP_KERNEL);
		if (err) {
			dbg("%s: submit urb %d failed (%d) %d",
				__func__, i, err,
				urb->transfer_buffer_length);
		}
	}

	/* Reset low level data toggle on out endpoints */
	for (i = 0; i < N_OUT_URB; i++) {
		urb = portdata->out_urbs[i];
		if (!urb)
			continue;
		urb->dev = serial->dev;
		/* usb_settoggle(urb->dev, usb_pipeendpoint(urb->pipe),
				usb_pipeout(urb->pipe), 0); */
	}

	if (tty)
		tty->low_latency = 1;

	zte_send_setup(tty, port);

	return 0;
}

static void zte_close(struct tty_struct *tty,
			struct usb_serial_port *port, struct file *filp)
{
	int i;
	struct usb_serial *serial = port->serial;
	struct zte_port_private *portdata;

	dbg("%s", __func__);
	portdata = usb_get_serial_port_data(port);

	portdata->rts_state = 0;
	portdata->dtr_state = 0;

	if (serial->dev) {
		mutex_lock(&serial->disc_mutex);
		if (!serial->disconnected)
			zte_send_setup(tty, port);
		mutex_unlock(&serial->disc_mutex);

		/* Stop reading/writing urbs */
		for (i = 0; i < N_IN_URB; i++)
			usb_kill_urb(portdata->in_urbs[i]);
		for (i = 0; i < N_OUT_URB; i++)
			usb_kill_urb(portdata->out_urbs[i]);
	}
	port->port.tty = NULL;	/* FIXME */
}

/* Helper functions used by zte_setup_urbs */
static struct urb *zte_setup_urb(struct usb_serial *serial, int endpoint,
		int dir, void *ctx, char *buf, int len,
		void (*callback)(struct urb *))
{
	struct urb *urb;

	if (endpoint == -1)
		return NULL;		/* endpoint not needed */

	urb = usb_alloc_urb(0, GFP_KERNEL);		/* No ISO */
	if (urb == NULL) {
		dbg("%s: alloc for endpoint %d failed.", __func__, endpoint);
		return NULL;
	}

		/* Fill URB using supplied data. */
	usb_fill_bulk_urb(urb, serial->dev,
		      usb_sndbulkpipe(serial->dev, endpoint) | dir,
		      buf, len, callback, ctx);

	return urb;
}

/* Setup urbs */
static void zte_setup_urbs(struct usb_serial *serial)
{
	int i, j;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;

	dbg("%s", __func__);

	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);

		/* Do indat endpoints first */
		for (j = 0; j < N_IN_URB; ++j) {
			portdata->in_urbs[j] = zte_setup_urb(serial,
					port->bulk_in_endpointAddress,
					USB_DIR_IN, port,
					portdata->in_buffer[j],
					IN_BUFLEN, zte_indat_callback);
		}

		/* outdat endpoints */
		for (j = 0; j < N_OUT_URB; ++j) {
			portdata->out_urbs[j] = zte_setup_urb(serial,
					port->bulk_out_endpointAddress,
					USB_DIR_OUT, port,
					portdata->out_buffer[j],
					OUT_BUFLEN, zte_outdat_callback);
		}
	}
}


/** send RTS/DTR state to the port.
 *
 * This is exactly the same as SET_CONTROL_LINE_STATE from the PSTN
 * CDC.
*/
static int zte_send_setup(struct tty_struct *tty,
						struct usb_serial_port *port)
{
	struct usb_serial *serial = port->serial;
	struct zte_port_private *portdata;
	int ifNum = serial->interface->cur_altsetting->desc.bInterfaceNumber;
	dbg("%s", __func__);

	portdata = usb_get_serial_port_data(port);

	if (tty) {
		int val = 0;
		if (portdata->dtr_state)
			val |= 0x01;
		if (portdata->rts_state)
			val |= 0x02;

		return usb_control_msg(serial->dev,
			usb_rcvctrlpipe(serial->dev, 0),
			0x22, 0x21, val, ifNum, NULL, 0, USB_CTRL_SET_TIMEOUT);
	}
	return 0;
}

static int zte_startup(struct usb_serial *serial)
{
	int i, j, err;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;
	u8 *buffer;

	dbg("%s", __func__);

	/* Now setup per port private data */
	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		portdata = kzalloc(sizeof(*portdata), GFP_KERNEL);
		if (!portdata) {
			dbg("%s: kmalloc for zte_port_private (%d) failed!.",
					__func__, i);
			return 1;
		}

		for (j = 0; j < N_IN_URB; j++) {
			buffer = (u8 *)__get_free_page(GFP_KERNEL);
			if (!buffer)
				goto bail_out_error;
			portdata->in_buffer[j] = buffer;
		}

		for (j = 0; j < N_OUT_URB; j++) {
			buffer = kmalloc(OUT_BUFLEN, GFP_KERNEL);
			if (!buffer)
				goto bail_out_error2;
			portdata->out_buffer[j] = buffer;
		}

		usb_set_serial_port_data(port, portdata);

		if (!port->interrupt_in_urb)
			continue;
		err = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);
		if (err)
			dbg("%s: submit irq_in urb failed %d",
				__func__, err);
	}
	zte_setup_urbs(serial);
	return 0;

bail_out_error2:
	for (j = 0; j < N_OUT_URB; j++)
		kfree(portdata->out_buffer[j]);
bail_out_error:
	for (j = 0; j < N_IN_URB; j++)
		if (portdata->in_buffer[j])
			free_page((unsigned long)portdata->in_buffer[j]);
	kfree(portdata);
	return 1;
}

static void zte_shutdown(struct usb_serial *serial)
{
	int i, j;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;

	dbg("%s", __func__);

	/* Stop reading/writing urbs */
	for (i = 0; i < serial->num_ports; ++i) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);
		for (j = 0; j < N_IN_URB; j++)
			usb_kill_urb(portdata->in_urbs[j]);
		for (j = 0; j < N_OUT_URB; j++)
			usb_kill_urb(portdata->out_urbs[j]);
	}

	/* Now free them */
	for (i = 0; i < serial->num_ports; ++i) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);

		for (j = 0; j < N_IN_URB; j++) {
			if (portdata->in_urbs[j]) {
				usb_free_urb(portdata->in_urbs[j]);
				free_page((unsigned long)
					portdata->in_buffer[j]);
				portdata->in_urbs[j] = NULL;
			}
		}
		for (j = 0; j < N_OUT_URB; j++) {
			if (portdata->out_urbs[j]) {
				usb_free_urb(portdata->out_urbs[j]);
				kfree(portdata->out_buffer[j]);
				portdata->out_urbs[j] = NULL;
			}
		}
	}

	/* Now free per port private data */
	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		kfree(usb_get_serial_port_data(port));
	}
}

MODULE_AUTHOR(DRIVER_AUTHOR);
MODULE_DESCRIPTION(DRIVER_DESC);
MODULE_VERSION(DRIVER_VERSION);
MODULE_LICENSE("GPL");

module_param(debug, bool, S_IRUGO | S_IWUSR);
MODULE_PARM_DESC(debug, "Debug messages");
//#else

//#endif
#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29)//use 2.6.28 sourcecode
#include <linux/kernel.h>
#include <linux/jiffies.h>
#include <linux/errno.h>
#include <linux/tty.h>
#include <linux/tty_flip.h>
#include <linux/module.h>
#include <linux/bitops.h>
#include <linux/usb.h>
#include <linux/usb/serial.h>

/* Function prototypes */
static int  zte_open(struct tty_struct *tty, struct usb_serial_port *port,
							struct file *filp);
static void zte_close(struct tty_struct *tty, struct usb_serial_port *port,
							struct file *filp);
static int  zte_startup(struct usb_serial *serial);
static void zte_shutdown(struct usb_serial *serial);
static int  zte_write_room(struct tty_struct *tty);

static void zte_instat_callback(struct urb *urb);

static int zte_write(struct tty_struct *tty, struct usb_serial_port *port,
			const unsigned char *buf, int count);
static int  zte_chars_in_buffer(struct tty_struct *tty);
static void zte_set_termios(struct tty_struct *tty,
			struct usb_serial_port *port, struct ktermios *old);
static int  zte_tiocmget(struct tty_struct *tty, struct file *file);
static int  zte_tiocmset(struct tty_struct *tty, struct file *file,
				unsigned int set, unsigned int clear);
static int  zte_send_setup(struct tty_struct *tty, struct usb_serial_port *port);

/* Vendor and product IDs */
#define zte_VENDOR_ID			0x19d2

static struct usb_device_id zte_ids[] = {
	   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0001, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0002, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0003, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0004, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0005, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0006, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0007, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0008, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0009, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0010, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0011, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0012, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0013, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0014, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0015, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0016, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0017, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0018, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0019, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0020, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0021, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0022, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0023, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0024, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0025, 0xff, 0xff, 0xff) },
    //   { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0026, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0027, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0028, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0029, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0030, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0031, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0032, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0033, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0034, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0035, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0036, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0037, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0038, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0039, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0040, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0041, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0042, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0043, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0044, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0045, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0046, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0047, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0048, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0049, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0050, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0051, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0052, 0xff, 0xff, 0xff) },
    //   { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0053, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0054, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0055, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0056, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0057, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0058, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0059, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0060, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0061, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0062, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0063, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0064, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0065, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0066, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0067, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0068, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0069, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0070, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0071, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0072, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0073, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0074, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0075, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0076, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0077, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0078, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0079, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0080, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0081, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0082, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0083, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0084, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0085, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0086, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0087, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0088, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0089, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0090, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0091, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0092, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0093, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0094, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0095, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0096, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0097, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0098, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0099, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0104, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0105, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0106, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0108, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0117, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0118, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0121, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0122, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0123, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0124, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0125, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0126, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0128, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0130, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0133, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0141, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0144, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0145, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0147, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0148, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0151, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0152, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0153, 0xff, 0xff, 0xff) },
    //{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0154, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0155, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0156, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0157, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0158, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0159, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0160, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0161, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0162, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0164, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0165, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0168, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0170, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0176, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0178, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1008, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1010, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1012, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1057, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1058, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1059, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1060, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1061, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1062, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1063, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1064, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1065, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1066, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1067, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1068, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1069, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1070, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1071, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1072, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1073, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1074, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1075, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1076, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1077, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1078, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1079, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1080, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1081, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1082, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1083, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1084, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1085, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1086, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1087, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1088, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1089, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1090, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1091, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1092, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1093, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1094, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1095, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1096, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1097, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1098, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1099, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1100, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1101, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1102, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1103, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1104, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1105, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1106, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1107, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1108, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1109, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1110, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1111, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1112, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1113, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1114, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1115, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1116, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1117, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1118, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1119, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1120, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1121, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1122, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1123, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1124, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1125, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1126, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1127, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1128, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1129, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1130, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1131, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1132, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1133, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1134, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1135, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1136, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1137, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1138, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1139, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1140, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1141, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1142, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1143, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1144, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1145, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1146, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1147, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1148, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1149, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1150, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1151, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1152, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1153, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1154, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1155, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1156, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1157, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1158, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1159, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1160, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1161, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1162, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1163, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1164, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1165, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1166, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1167, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1168, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1169, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1170, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1244, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1245, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1246, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1247, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1248, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1249, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1250, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1251, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1252, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1253, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1254, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1255, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1256, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1257, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1258, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1259, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1260, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1261, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1262, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1263, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1264, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1265, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1266, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1267, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1268, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1269, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1270, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1271, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1272, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1273, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1274, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1275, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1276, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1277, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1278, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1279, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1280, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1281, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1282, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1283, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1284, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1285, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1286, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1287, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1288, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1289, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1290, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1291, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1292, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1293, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1294, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1295, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1296, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1297, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1298, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1299, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1300, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1401, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1402, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1403, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1404, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1405, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1406, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1407, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1408, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1409, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1410, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1411, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1412, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1413, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1414, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1415, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1416, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1417, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1418, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1419, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1420, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1421, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1422, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1423, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1424, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1425, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1426, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1427, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1428, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1429, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1430, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1431, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1432, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1433, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1434, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1435, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1436, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1437, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1438, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1439, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1440, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1441, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1442, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1443, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1444, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1445, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1446, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1447, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1448, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1449, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1450, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1451, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1452, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1453, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1454, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1455, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1456, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1457, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1458, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1459, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1460, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1461, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1462, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1463, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1464, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1465, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1466, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1467, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1468, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1469, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1470, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1471, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1472, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1473, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1474, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1475, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1476, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1477, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1478, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1479, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1480, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1481, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1482, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1483, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1484, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1485, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1486, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1487, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1488, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1489, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1490, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1491, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1492, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1493, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1494, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1495, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1496, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1497, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1498, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1499, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1500, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1501, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1502, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1503, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1504, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1505, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1506, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1507, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1508, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1509, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1510, 0xff, 0xff, 0xff) },       
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x2002, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x2003, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0xFFEC, 0xff, 0xff, 0xff) },

    { USB_DEVICE_AND_INTERFACE_INFO(TPLink_VENDOR_ID, 0x7E11, 0xff, 0xff, 0xff) },/*TPLink*/
    { USB_DEVICE_AND_INTERFACE_INFO(QUALCOMM_VENDOR_ID, 0x9001, 0xff, 0xff, 0xff) },/*QUALCOMM_VENDOR_ID*/
    { USB_DEVICE_AND_INTERFACE_INFO(QUALCOMM_VENDOR_ID, 0x9002, 0xff, 0xff, 0xff) },

	{ } /* Terminating entry */
};
MODULE_DEVICE_TABLE(usb, zte_ids);

static struct usb_driver zte_driver = {
	.name       = "zte",
	.probe      = usb_serial_probe,
	.disconnect = usb_serial_disconnect,
	.id_table   = zte_ids,
	.no_dynamic_id = 	1,
};

/* The card has three separate interfaces, which the serial driver
 * recognizes separately, thus num_port=1.
 */

static struct usb_serial_driver zte_1port_device = {
	.driver = {
		.owner =	THIS_MODULE,
		.name =		"zte1",
	},
	.description       = "GSM modem (1-port)",
	.usb_driver        = &zte_driver,
	.id_table          = zte_ids,
	.num_ports         = 1,
	.open              = zte_open,
	.close             = zte_close,
	.write             = zte_write,
	.write_room        = zte_write_room,
	.chars_in_buffer   = zte_chars_in_buffer,
	.set_termios       = zte_set_termios,
	.tiocmget          = zte_tiocmget,
	.tiocmset          = zte_tiocmset,
	.attach            = zte_startup,
	.shutdown          = zte_shutdown,
	.read_int_callback = zte_instat_callback,
};

static int debug;

/* per port private data */

#define N_IN_URB 4
#define N_OUT_URB 4
#define IN_BUFLEN 4096
#define OUT_BUFLEN 4096

struct zte_port_private {
	/* Input endpoints and buffer for this port */
	struct urb *in_urbs[N_IN_URB];
	u8 *in_buffer[N_IN_URB];
	/* Output endpoints and buffer for this port */
	struct urb *out_urbs[N_OUT_URB];
	u8 *out_buffer[N_OUT_URB];
	unsigned long out_busy;		/* Bit vector of URBs in use */

	/* Settings for the port */
	int rts_state;	/* Handshaking pins (outputs) */
	int dtr_state;
	int cts_state;	/* Handshaking pins (inputs) */
	int dsr_state;
	int dcd_state;
	int ri_state;

	unsigned long tx_start_time[N_OUT_URB];
};

/* Functions used by new usb-serial code. */
static int __init zte_init(void)
{
	int retval;
	retval = usb_serial_register(&zte_1port_device);
	if (retval)
		goto failed_1port_device_register;
	retval = usb_register(&zte_driver);
	if (retval)
		goto failed_driver_register;

	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
	       DRIVER_DESC "\n");

	return 0;

failed_driver_register:
	usb_serial_deregister(&zte_1port_device);
failed_1port_device_register:
	return retval;
}

static void __exit zte_exit(void)
{
	usb_deregister(&zte_driver);
	usb_serial_deregister(&zte_1port_device);
}

module_init(zte_init);
module_exit(zte_exit);

static void zte_set_termios(struct tty_struct *tty,
		struct usb_serial_port *port, struct ktermios *old_termios)
{
	dbg("%s", __func__);
	/* Doesn't support zte setting */
	tty_termios_copy_hw(tty->termios, old_termios);
	zte_send_setup(tty, port);
}

static int zte_tiocmget(struct tty_struct *tty, struct file *file)
{
	struct usb_serial_port *port = tty->driver_data;
	unsigned int value;
	struct zte_port_private *portdata;

	portdata = usb_get_serial_port_data(port);

	value = ((portdata->rts_state) ? TIOCM_RTS : 0) |
		((portdata->dtr_state) ? TIOCM_DTR : 0) |
		((portdata->cts_state) ? TIOCM_CTS : 0) |
		((portdata->dsr_state) ? TIOCM_DSR : 0) |
		((portdata->dcd_state) ? TIOCM_CAR : 0) |
		((portdata->ri_state) ? TIOCM_RNG : 0);

	return value;
}

static int zte_tiocmset(struct tty_struct *tty, struct file *file,
			unsigned int set, unsigned int clear)
{
	struct usb_serial_port *port = tty->driver_data;
	struct zte_port_private *portdata;

	portdata = usb_get_serial_port_data(port);

	/* FIXME: what locks portdata fields ? */
	if (set & TIOCM_RTS)
		portdata->rts_state = 1;
	if (set & TIOCM_DTR)
		portdata->dtr_state = 1;

	if (clear & TIOCM_RTS)
		portdata->rts_state = 0;
	if (clear & TIOCM_DTR)
		portdata->dtr_state = 0;
	return zte_send_setup(tty, port);
}

/* Write */
static int zte_write(struct tty_struct *tty, struct usb_serial_port *port,
			const unsigned char *buf, int count)
{
	struct zte_port_private *portdata;
	int i;
	int left, todo;
	struct urb *this_urb = NULL; /* spurious */
	int err;

	portdata = usb_get_serial_port_data(port);

	dbg("%s: write (%d chars)", __func__, count);

	i = 0;
	left = count;
	for (i = 0; left > 0 && i < N_OUT_URB; i++) {
		todo = left;
		if (todo > OUT_BUFLEN)
			todo = OUT_BUFLEN;

		this_urb = portdata->out_urbs[i];
		if (test_and_set_bit(i, &portdata->out_busy)) {
			if (time_before(jiffies,
					portdata->tx_start_time[i] + 10 * HZ))
				continue;
			usb_unlink_urb(this_urb);
			continue;
		}
		if (this_urb->status != 0)
			dbg("usb_write %p failed (err=%d)",
				this_urb, this_urb->status);

		dbg("%s: endpoint %d buf %d", __func__,
			usb_pipeendpoint(this_urb->pipe), i);

		/* send the data */
		memcpy(this_urb->transfer_buffer, buf, todo);
		this_urb->transfer_buffer_length = todo;

		this_urb->dev = port->serial->dev;
		err = usb_submit_urb(this_urb, GFP_ATOMIC);
		if (err) {
			dbg("usb_submit_urb %p (write bulk) failed "
				"(%d, has %d)", this_urb,
				err, this_urb->status);
			clear_bit(i, &portdata->out_busy);
			continue;
		}
		portdata->tx_start_time[i] = jiffies;
		buf += todo;
		left -= todo;
	}

	count -= left;
	dbg("%s: wrote (did %d)", __func__, count);
	return count;
}

static void zte_indat_callback(struct urb *urb)
{
	int err;
	int endpoint;
	struct usb_serial_port *port;
	struct tty_struct *tty;
	unsigned char *data = urb->transfer_buffer;
	int status = urb->status;

	dbg("%s: %p", __func__, urb);

	endpoint = usb_pipeendpoint(urb->pipe);
	port =  urb->context;

	if (status) {
		dbg("%s: nonzero status: %d on endpoint %02x.",
		    __func__, status, endpoint);
	} else {
		tty = tty_port_tty_get(&port->port);
		if (urb->actual_length) {
			tty_buffer_request_room(tty, urb->actual_length);
			tty_insert_flip_string(tty, data, urb->actual_length);
			tty_flip_buffer_push(tty);
		} else 
			dbg("%s: empty read urb received", __func__);
		tty_kref_put(tty);

		/* Resubmit urb so we continue receiving */
		if (port->port.count && status != -ESHUTDOWN) {
			err = usb_submit_urb(urb, GFP_ATOMIC);
			if (err)
				printk(KERN_ERR "%s: resubmit read urb failed. "
					"(%d)", __func__, err);
		}
	}
	return;
}

static void zte_outdat_callback(struct urb *urb)
{
	struct usb_serial_port *port;
	struct zte_port_private *portdata;
	int i;

	dbg("%s", __func__);

	port =  urb->context;

	usb_serial_port_softint(port);

	portdata = usb_get_serial_port_data(port);
	for (i = 0; i < N_OUT_URB; ++i) {
		if (portdata->out_urbs[i] == urb) {
			smp_mb__before_clear_bit();
			clear_bit(i, &portdata->out_busy);
			break;
		}
	}
}

static void zte_instat_callback(struct urb *urb)
{
	int err;
	int status = urb->status;
	struct usb_serial_port *port =  urb->context;
	struct zte_port_private *portdata = usb_get_serial_port_data(port);
	struct usb_serial *serial = port->serial;

	dbg("%s", __func__);
	dbg("%s: urb %p port %p has data %p", __func__, urb, port, portdata);

	if (status == 0) {
		struct usb_ctrlrequest *req_pkt =
				(struct usb_ctrlrequest *)urb->transfer_buffer;

		if (!req_pkt) {
			dbg("%s: NULL req_pkt\n", __func__);
			return;
		}
		if ((req_pkt->bRequestType == 0xA1) &&
				(req_pkt->bRequest == 0x20)) {
			int old_dcd_state;
			unsigned char signals = *((unsigned char *)
					urb->transfer_buffer +
					sizeof(struct usb_ctrlrequest));

			dbg("%s: signal x%x", __func__, signals);

			old_dcd_state = portdata->dcd_state;
			portdata->cts_state = 1;
			portdata->dcd_state = ((signals & 0x01) ? 1 : 0);
			portdata->dsr_state = ((signals & 0x02) ? 1 : 0);
			portdata->ri_state = ((signals & 0x08) ? 1 : 0);

			if (old_dcd_state && !portdata->dcd_state) {
				struct tty_struct *tty =
						tty_port_tty_get(&port->port);
				if (tty && !C_CLOCAL(tty))
					tty_hangup(tty);
				tty_kref_put(tty);
			}
		} else {
			dbg("%s: type %x req %x", __func__,
				req_pkt->bRequestType, req_pkt->bRequest);
		}
	} else
		dbg("%s: error %d", __func__, status);

	/* Resubmit urb so we continue receiving IRQ data */
	if (status != -ESHUTDOWN) {
		urb->dev = serial->dev;
		err = usb_submit_urb(urb, GFP_ATOMIC);
		if (err)
			dbg("%s: resubmit intr urb failed. (%d)",
				__func__, err);
	}
}

static int zte_write_room(struct tty_struct *tty)
{
	struct usb_serial_port *port = tty->driver_data;
	struct zte_port_private *portdata;
	int i;
	int data_len = 0;
	struct urb *this_urb;

	portdata = usb_get_serial_port_data(port);


	for (i = 0; i < N_OUT_URB; i++) {
		this_urb = portdata->out_urbs[i];
		if (this_urb && !test_bit(i, &portdata->out_busy))
			data_len += OUT_BUFLEN;
	}

	dbg("%s: %d", __func__, data_len);
	return data_len;
}

static int zte_chars_in_buffer(struct tty_struct *tty)
{
	struct usb_serial_port *port = tty->driver_data;
	struct zte_port_private *portdata;
	int i;
	int data_len = 0;
	struct urb *this_urb;

	portdata = usb_get_serial_port_data(port);

	for (i = 0; i < N_OUT_URB; i++) {
		this_urb = portdata->out_urbs[i];
		/* FIXME: This locking is insufficient as this_urb may
		   go unused during the test */
		if (this_urb && test_bit(i, &portdata->out_busy))
			data_len += this_urb->transfer_buffer_length;
	}
	dbg("%s: %d", __func__, data_len);
	return data_len;
}

static int zte_open(struct tty_struct *tty,
			struct usb_serial_port *port, struct file *filp)
{
	struct zte_port_private *portdata;
	struct usb_serial *serial = port->serial;
	int i, err;
	struct urb *urb;

	portdata = usb_get_serial_port_data(port);

	dbg("%s", __func__);

	/* Set some sane defaults */
	portdata->rts_state = 1;
	portdata->dtr_state = 1;

	/* Reset low level data toggle and start reading from endpoints */
	for (i = 0; i < N_IN_URB; i++) {
		urb = portdata->in_urbs[i];
		if (!urb)
			continue;
		if (urb->dev != serial->dev) {
			dbg("%s: dev %p != %p", __func__,
				urb->dev, serial->dev);
			continue;
		}

		/*
		 * make sure endpoint data toggle is synchronized with the
		 * device
		 */
		usb_clear_halt(urb->dev, urb->pipe);

		err = usb_submit_urb(urb, GFP_KERNEL);
		if (err) {
			dbg("%s: submit urb %d failed (%d) %d",
				__func__, i, err,
				urb->transfer_buffer_length);
		}
	}

	/* Reset low level data toggle on out endpoints */
	for (i = 0; i < N_OUT_URB; i++) {
		urb = portdata->out_urbs[i];
		if (!urb)
			continue;
		urb->dev = serial->dev;
		/* usb_settoggle(urb->dev, usb_pipeendpoint(urb->pipe),
				usb_pipeout(urb->pipe), 0); */
	}

	if (tty)
		tty->low_latency = 1;

	zte_send_setup(tty, port);

	return 0;
}

static void zte_close(struct tty_struct *tty,
			struct usb_serial_port *port, struct file *filp)
{
	int i;
	struct usb_serial *serial = port->serial;
	struct zte_port_private *portdata;

	dbg("%s", __func__);
	portdata = usb_get_serial_port_data(port);

	portdata->rts_state = 0;
	portdata->dtr_state = 0;

	if (serial->dev) {
		mutex_lock(&serial->disc_mutex);
		if (!serial->disconnected)
			zte_send_setup(tty, port);
		mutex_unlock(&serial->disc_mutex);

		/* Stop reading/writing urbs */
		for (i = 0; i < N_IN_URB; i++)
			usb_kill_urb(portdata->in_urbs[i]);
		for (i = 0; i < N_OUT_URB; i++)
			usb_kill_urb(portdata->out_urbs[i]);
	}
	tty_port_tty_set(&port->port, NULL);
}

/* Helper functions used by zte_setup_urbs */
static struct urb *zte_setup_urb(struct usb_serial *serial, int endpoint,
		int dir, void *ctx, char *buf, int len,
		void (*callback)(struct urb *))
{
	struct urb *urb;

	if (endpoint == -1)
		return NULL;		/* endpoint not needed */

	urb = usb_alloc_urb(0, GFP_KERNEL);		/* No ISO */
	if (urb == NULL) {
		dbg("%s: alloc for endpoint %d failed.", __func__, endpoint);
		return NULL;
	}

		/* Fill URB using supplied data. */
	usb_fill_bulk_urb(urb, serial->dev,
		      usb_sndbulkpipe(serial->dev, endpoint) | dir,
		      buf, len, callback, ctx);

	return urb;
}

/* Setup urbs */
static void zte_setup_urbs(struct usb_serial *serial)
{
	int i, j;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;

	dbg("%s", __func__);

	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);

		/* Do indat endpoints first */
		for (j = 0; j < N_IN_URB; ++j) {
			portdata->in_urbs[j] = zte_setup_urb(serial,
					port->bulk_in_endpointAddress,
					USB_DIR_IN, port,
					portdata->in_buffer[j],
					IN_BUFLEN, zte_indat_callback);
		}

		/* outdat endpoints */
		for (j = 0; j < N_OUT_URB; ++j) {
			portdata->out_urbs[j] = zte_setup_urb(serial,
					port->bulk_out_endpointAddress,
					USB_DIR_OUT, port,
					portdata->out_buffer[j],
					OUT_BUFLEN, zte_outdat_callback);
		}
	}
}


/** send RTS/DTR state to the port.
 *
 * This is exactly the same as SET_CONTROL_LINE_STATE from the PSTN
 * CDC.
*/
static int zte_send_setup(struct tty_struct *tty,
						struct usb_serial_port *port)
{
	struct usb_serial *serial = port->serial;
	struct zte_port_private *portdata;
	int ifNum = serial->interface->cur_altsetting->desc.bInterfaceNumber;
	dbg("%s", __func__);

	portdata = usb_get_serial_port_data(port);

	if (tty) {
		int val = 0;
		if (portdata->dtr_state)
			val |= 0x01;
		if (portdata->rts_state)
			val |= 0x02;

		return usb_control_msg(serial->dev,
			usb_rcvctrlpipe(serial->dev, 0),
			0x22, 0x21, val, ifNum, NULL, 0, USB_CTRL_SET_TIMEOUT);
	}
	return 0;
}

static int zte_startup(struct usb_serial *serial)
{
	int i, j, err;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;
	u8 *buffer;

	dbg("%s", __func__);

	/* Now setup per port private data */
	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		portdata = kzalloc(sizeof(*portdata), GFP_KERNEL);
		if (!portdata) {
			dbg("%s: kmalloc for zte_port_private (%d) failed!.",
					__func__, i);
			return 1;
		}

		for (j = 0; j < N_IN_URB; j++) {
			buffer = (u8 *)__get_free_page(GFP_KERNEL);
			if (!buffer)
				goto bail_out_error;
			portdata->in_buffer[j] = buffer;
		}

		for (j = 0; j < N_OUT_URB; j++) {
			buffer = kmalloc(OUT_BUFLEN, GFP_KERNEL);
			if (!buffer)
				goto bail_out_error2;
			portdata->out_buffer[j] = buffer;
		}

		usb_set_serial_port_data(port, portdata);

		if (!port->interrupt_in_urb)
			continue;
		err = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);
		if (err)
			dbg("%s: submit irq_in urb failed %d",
				__func__, err);
	}
	zte_setup_urbs(serial);
	return 0;

bail_out_error2:
	for (j = 0; j < N_OUT_URB; j++)
		kfree(portdata->out_buffer[j]);
bail_out_error:
	for (j = 0; j < N_IN_URB; j++)
		if (portdata->in_buffer[j])
			free_page((unsigned long)portdata->in_buffer[j]);
	kfree(portdata);
	return 1;
}

static void zte_shutdown(struct usb_serial *serial)
{
	int i, j;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;

	dbg("%s", __func__);

	/* Stop reading/writing urbs */
	for (i = 0; i < serial->num_ports; ++i) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);
		for (j = 0; j < N_IN_URB; j++)
			usb_kill_urb(portdata->in_urbs[j]);
		for (j = 0; j < N_OUT_URB; j++)
			usb_kill_urb(portdata->out_urbs[j]);
	}

	/* Now free them */
	for (i = 0; i < serial->num_ports; ++i) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);

		for (j = 0; j < N_IN_URB; j++) {
			if (portdata->in_urbs[j]) {
				usb_free_urb(portdata->in_urbs[j]);
				free_page((unsigned long)
					portdata->in_buffer[j]);
				portdata->in_urbs[j] = NULL;
			}
		}
		for (j = 0; j < N_OUT_URB; j++) {
			if (portdata->out_urbs[j]) {
				usb_free_urb(portdata->out_urbs[j]);
				kfree(portdata->out_buffer[j]);
				portdata->out_urbs[j] = NULL;
			}
		}
	}

	/* Now free per port private data */
	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		kfree(usb_get_serial_port_data(port));
	}
}

MODULE_AUTHOR(DRIVER_AUTHOR);
MODULE_DESCRIPTION(DRIVER_DESC);
MODULE_VERSION(DRIVER_VERSION);
MODULE_LICENSE("GPL");

module_param(debug, bool, S_IRUGO | S_IWUSR);
MODULE_PARM_DESC(debug, "Debug messages");
//#else

//#endif

#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30)//use 2.6.29 sourcecode
#include <linux/kernel.h>
#include <linux/jiffies.h>
#include <linux/errno.h>
#include <linux/tty.h>
#include <linux/tty_flip.h>
#include <linux/module.h>
#include <linux/bitops.h>
#include <linux/usb.h>
#include <linux/usb/serial.h>

/* Function prototypes */
static int  zte_open(struct tty_struct *tty, struct usb_serial_port *port,
							struct file *filp);
static void zte_close(struct tty_struct *tty, struct usb_serial_port *port,
							struct file *filp);
static int  zte_startup(struct usb_serial *serial);
static void zte_shutdown(struct usb_serial *serial);
static int  zte_write_room(struct tty_struct *tty);

static void zte_instat_callback(struct urb *urb);

static int zte_write(struct tty_struct *tty, struct usb_serial_port *port,
			const unsigned char *buf, int count);
static int  zte_chars_in_buffer(struct tty_struct *tty);
static void zte_set_termios(struct tty_struct *tty,
			struct usb_serial_port *port, struct ktermios *old);
static int  zte_tiocmget(struct tty_struct *tty, struct file *file);
static int  zte_tiocmset(struct tty_struct *tty, struct file *file,
				unsigned int set, unsigned int clear);
static int  zte_send_setup(struct tty_struct *tty, struct usb_serial_port *port);

#define zte_VENDOR_ID			0x19d2

static struct usb_device_id zte_ids[] = {
	   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0001, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0002, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0003, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0004, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0005, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0006, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0007, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0008, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0009, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0010, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0011, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0012, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0013, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0014, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0015, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0016, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0017, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0018, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0019, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0020, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0021, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0022, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0023, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0024, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0025, 0xff, 0xff, 0xff) },
    //   { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0026, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0027, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0028, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0029, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0030, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0031, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0032, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0033, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0034, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0035, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0036, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0037, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0038, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0039, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0040, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0041, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0042, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0043, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0044, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0045, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0046, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0047, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0048, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0049, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0050, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0051, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0052, 0xff, 0xff, 0xff) },
    //   { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0053, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0054, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0055, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0056, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0057, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0058, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0059, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0060, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0061, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0062, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0063, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0064, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0065, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0066, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0067, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0068, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0069, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0070, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0071, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0072, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0073, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0074, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0075, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0076, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0077, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0078, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0079, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0080, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0081, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0082, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0083, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0084, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0085, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0086, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0087, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0088, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0089, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0090, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0091, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0092, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0093, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0094, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0095, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0096, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0097, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0098, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0099, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0104, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0105, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0106, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0108, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0117, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0118, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0121, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0122, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0123, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0124, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0125, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0126, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0128, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0130, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0133, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0141, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0144, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0145, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0147, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0148, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0151, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0152, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0153, 0xff, 0xff, 0xff) },
    //{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0154, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0155, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0156, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0157, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0158, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0159, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0160, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0161, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0162, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0164, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0165, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0168, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0170, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0176, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0178, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1008, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1010, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1012, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1057, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1058, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1059, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1060, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1061, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1062, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1063, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1064, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1065, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1066, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1067, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1068, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1069, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1070, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1071, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1072, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1073, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1074, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1075, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1076, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1077, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1078, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1079, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1080, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1081, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1082, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1083, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1084, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1085, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1086, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1087, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1088, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1089, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1090, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1091, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1092, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1093, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1094, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1095, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1096, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1097, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1098, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1099, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1100, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1101, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1102, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1103, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1104, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1105, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1106, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1107, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1108, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1109, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1110, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1111, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1112, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1113, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1114, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1115, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1116, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1117, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1118, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1119, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1120, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1121, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1122, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1123, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1124, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1125, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1126, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1127, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1128, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1129, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1130, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1131, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1132, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1133, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1134, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1135, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1136, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1137, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1138, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1139, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1140, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1141, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1142, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1143, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1144, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1145, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1146, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1147, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1148, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1149, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1150, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1151, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1152, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1153, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1154, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1155, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1156, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1157, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1158, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1159, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1160, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1161, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1162, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1163, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1164, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1165, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1166, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1167, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1168, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1169, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1170, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1244, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1245, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1246, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1247, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1248, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1249, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1250, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1251, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1252, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1253, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1254, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1255, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1256, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1257, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1258, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1259, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1260, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1261, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1262, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1263, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1264, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1265, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1266, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1267, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1268, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1269, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1270, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1271, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1272, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1273, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1274, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1275, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1276, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1277, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1278, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1279, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1280, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1281, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1282, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1283, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1284, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1285, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1286, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1287, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1288, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1289, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1290, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1291, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1292, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1293, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1294, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1295, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1296, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1297, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1298, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1299, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1300, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1401, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1402, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1403, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1404, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1405, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1406, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1407, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1408, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1409, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1410, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1411, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1412, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1413, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1414, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1415, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1416, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1417, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1418, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1419, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1420, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1421, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1422, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1423, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1424, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1425, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1426, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1427, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1428, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1429, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1430, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1431, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1432, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1433, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1434, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1435, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1436, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1437, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1438, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1439, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1440, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1441, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1442, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1443, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1444, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1445, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1446, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1447, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1448, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1449, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1450, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1451, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1452, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1453, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1454, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1455, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1456, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1457, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1458, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1459, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1460, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1461, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1462, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1463, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1464, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1465, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1466, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1467, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1468, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1469, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1470, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1471, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1472, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1473, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1474, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1475, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1476, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1477, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1478, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1479, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1480, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1481, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1482, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1483, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1484, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1485, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1486, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1487, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1488, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1489, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1490, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1491, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1492, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1493, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1494, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1495, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1496, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1497, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1498, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1499, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1500, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1501, 0xff, 0xff, 0xff) },  

    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1502, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1503, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1504, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1505, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1506, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1507, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1508, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1509, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1510, 0xff, 0xff, 0xff) },       
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x2002, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x2003, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0xFFEC, 0xff, 0xff, 0xff) },

    { USB_DEVICE_AND_INTERFACE_INFO(TPLink_VENDOR_ID, 0x7E11, 0xff, 0xff, 0xff) },/*TPLink*/
    { USB_DEVICE_AND_INTERFACE_INFO(QUALCOMM_VENDOR_ID, 0x9001, 0xff, 0xff, 0xff) },/*QUALCOMM_VENDOR_ID*/
    { USB_DEVICE_AND_INTERFACE_INFO(QUALCOMM_VENDOR_ID, 0x9002, 0xff, 0xff, 0xff) },

	{ } /* Terminating entry */
};
MODULE_DEVICE_TABLE(usb, zte_ids);

static struct usb_driver zte_driver = {
	.name       = "zte",
	.probe      = usb_serial_probe,
	.disconnect = usb_serial_disconnect,
	.id_table   = zte_ids,
	.no_dynamic_id = 	1,
};

/* The card has three separate interfaces, which the serial driver
 * recognizes separately, thus num_port=1.
 */

static struct usb_serial_driver zte_1port_device = {
	.driver = {
		.owner =	THIS_MODULE,
		.name =		"zte1",
	},
	.description       = "GSM modem (1-port)",
	.usb_driver        = &zte_driver,
	.id_table          = zte_ids,
	.num_ports         = 1,
	.open              = zte_open,
	.close             = zte_close,
	.write             = zte_write,
	.write_room        = zte_write_room,
	.chars_in_buffer   = zte_chars_in_buffer,
	.set_termios       = zte_set_termios,
	.tiocmget          = zte_tiocmget,
	.tiocmset          = zte_tiocmset,
	.attach            = zte_startup,
	.shutdown          = zte_shutdown,
	.read_int_callback = zte_instat_callback,
};

static int debug;

/* per port private data */

#define N_IN_URB 4
#define N_OUT_URB 4
#define IN_BUFLEN 4096
#define OUT_BUFLEN 4096

struct zte_port_private {
	/* Input endpoints and buffer for this port */
	struct urb *in_urbs[N_IN_URB];
	u8 *in_buffer[N_IN_URB];
	/* Output endpoints and buffer for this port */
	struct urb *out_urbs[N_OUT_URB];
	u8 *out_buffer[N_OUT_URB];
	unsigned long out_busy;		/* Bit vector of URBs in use */

	/* Settings for the port */
	int rts_state;	/* Handshaking pins (outputs) */
	int dtr_state;
	int cts_state;	/* Handshaking pins (inputs) */
	int dsr_state;
	int dcd_state;
	int ri_state;

	unsigned long tx_start_time[N_OUT_URB];
};

/* Functions used by new usb-serial code. */
static int __init zte_init(void)
{
	int retval;
	retval = usb_serial_register(&zte_1port_device);
	if (retval)
		goto failed_1port_device_register;
	retval = usb_register(&zte_driver);
	if (retval)
		goto failed_driver_register;

	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
	       DRIVER_DESC "\n");

	return 0;

failed_driver_register:
	usb_serial_deregister(&zte_1port_device);
failed_1port_device_register:
	return retval;
}

static void __exit zte_exit(void)
{
	usb_deregister(&zte_driver);
	usb_serial_deregister(&zte_1port_device);
}

module_init(zte_init);
module_exit(zte_exit);

static void zte_set_termios(struct tty_struct *tty,
		struct usb_serial_port *port, struct ktermios *old_termios)
{
	dbg("%s", __func__);
	/* Doesn't support zte setting */
	tty_termios_copy_hw(tty->termios, old_termios);
	zte_send_setup(tty, port);
}

static int zte_tiocmget(struct tty_struct *tty, struct file *file)
{
	struct usb_serial_port *port = tty->driver_data;
	unsigned int value;
	struct zte_port_private *portdata;

	portdata = usb_get_serial_port_data(port);

	value = ((portdata->rts_state) ? TIOCM_RTS : 0) |
		((portdata->dtr_state) ? TIOCM_DTR : 0) |
		((portdata->cts_state) ? TIOCM_CTS : 0) |
		((portdata->dsr_state) ? TIOCM_DSR : 0) |
		((portdata->dcd_state) ? TIOCM_CAR : 0) |
		((portdata->ri_state) ? TIOCM_RNG : 0);

	return value;
}

static int zte_tiocmset(struct tty_struct *tty, struct file *file,
			unsigned int set, unsigned int clear)
{
	struct usb_serial_port *port = tty->driver_data;
	struct zte_port_private *portdata;

	portdata = usb_get_serial_port_data(port);

	/* FIXME: what locks portdata fields ? */
	if (set & TIOCM_RTS)
		portdata->rts_state = 1;
	if (set & TIOCM_DTR)
		portdata->dtr_state = 1;

	if (clear & TIOCM_RTS)
		portdata->rts_state = 0;
	if (clear & TIOCM_DTR)
		portdata->dtr_state = 0;
	return zte_send_setup(tty, port);
}

/* Write */
static int zte_write(struct tty_struct *tty, struct usb_serial_port *port,
			const unsigned char *buf, int count)
{
	struct zte_port_private *portdata;
	int i;
	int left, todo;
	struct urb *this_urb = NULL; /* spurious */
	int err;

	portdata = usb_get_serial_port_data(port);

	dbg("%s: write (%d chars)", __func__, count);

	i = 0;
	left = count;
	for (i = 0; left > 0 && i < N_OUT_URB; i++) {
		todo = left;
		if (todo > OUT_BUFLEN)
			todo = OUT_BUFLEN;

		this_urb = portdata->out_urbs[i];
		if (test_and_set_bit(i, &portdata->out_busy)) {
			if (time_before(jiffies,
					portdata->tx_start_time[i] + 10 * HZ))
				continue;
			usb_unlink_urb(this_urb);
			continue;
		}
		dbg("%s: endpoint %d buf %d", __func__,
			usb_pipeendpoint(this_urb->pipe), i);

		/* send the data */
		memcpy(this_urb->transfer_buffer, buf, todo);
		this_urb->transfer_buffer_length = todo;

		this_urb->dev = port->serial->dev;
		err = usb_submit_urb(this_urb, GFP_ATOMIC);
		if (err) {
			dbg("usb_submit_urb %p (write bulk) failed "
				"(%d)", this_urb, err);
			clear_bit(i, &portdata->out_busy);
			continue;
		}
		portdata->tx_start_time[i] = jiffies;
		buf += todo;
		left -= todo;
	}

	count -= left;
	dbg("%s: wrote (did %d)", __func__, count);
	return count;
}

static void zte_indat_callback(struct urb *urb)
{
	int err;
	int endpoint;
	struct usb_serial_port *port;
	struct tty_struct *tty;
	unsigned char *data = urb->transfer_buffer;
	int status = urb->status;

	dbg("%s: %p", __func__, urb);

	endpoint = usb_pipeendpoint(urb->pipe);
	port =  urb->context;

	if (status) {
		dbg("%s: nonzero status: %d on endpoint %02x.",
		    __func__, status, endpoint);
	} else {
		tty = tty_port_tty_get(&port->port);
		if (urb->actual_length) {
			tty_buffer_request_room(tty, urb->actual_length);
			tty_insert_flip_string(tty, data, urb->actual_length);
			tty_flip_buffer_push(tty);
		} else 
			dbg("%s: empty read urb received", __func__);
		tty_kref_put(tty);

		/* Resubmit urb so we continue receiving */
		if (port->port.count && status != -ESHUTDOWN) {
			err = usb_submit_urb(urb, GFP_ATOMIC);
			if (err)
				printk(KERN_ERR "%s: resubmit read urb failed. "
					"(%d)", __func__, err);
		}
	}
	return;
}

static void zte_outdat_callback(struct urb *urb)
{
	struct usb_serial_port *port;
	struct zte_port_private *portdata;
	int i;

	dbg("%s", __func__);

	port =  urb->context;

	usb_serial_port_softint(port);

	portdata = usb_get_serial_port_data(port);
	for (i = 0; i < N_OUT_URB; ++i) {
		if (portdata->out_urbs[i] == urb) {
			smp_mb__before_clear_bit();
			clear_bit(i, &portdata->out_busy);
			break;
		}
	}
}

static void zte_instat_callback(struct urb *urb)
{
	int err;
	int status = urb->status;
	struct usb_serial_port *port =  urb->context;
	struct zte_port_private *portdata = usb_get_serial_port_data(port);
	struct usb_serial *serial = port->serial;

	dbg("%s", __func__);
	dbg("%s: urb %p port %p has data %p", __func__, urb, port, portdata);

	if (status == 0) {
		struct usb_ctrlrequest *req_pkt =
				(struct usb_ctrlrequest *)urb->transfer_buffer;

		if (!req_pkt) {
			dbg("%s: NULL req_pkt\n", __func__);
			return;
		}
		if ((req_pkt->bRequestType == 0xA1) &&
				(req_pkt->bRequest == 0x20)) {
			int old_dcd_state;
			unsigned char signals = *((unsigned char *)
					urb->transfer_buffer +
					sizeof(struct usb_ctrlrequest));

			dbg("%s: signal x%x", __func__, signals);

			old_dcd_state = portdata->dcd_state;
			portdata->cts_state = 1;
			portdata->dcd_state = ((signals & 0x01) ? 1 : 0);
			portdata->dsr_state = ((signals & 0x02) ? 1 : 0);
			portdata->ri_state = ((signals & 0x08) ? 1 : 0);

			if (old_dcd_state && !portdata->dcd_state) {
				struct tty_struct *tty =
						tty_port_tty_get(&port->port);
				if (tty && !C_CLOCAL(tty))
					tty_hangup(tty);
				tty_kref_put(tty);
			}
		} else {
			dbg("%s: type %x req %x", __func__,
				req_pkt->bRequestType, req_pkt->bRequest);
		}
	} else
		dbg("%s: error %d", __func__, status);

	/* Resubmit urb so we continue receiving IRQ data */
	if (status != -ESHUTDOWN) {
		urb->dev = serial->dev;
		err = usb_submit_urb(urb, GFP_ATOMIC);
		if (err)
			dbg("%s: resubmit intr urb failed. (%d)",
				__func__, err);
	}
}

static int zte_write_room(struct tty_struct *tty)
{
	struct usb_serial_port *port = tty->driver_data;
	struct zte_port_private *portdata;
	int i;
	int data_len = 0;
	struct urb *this_urb;

	portdata = usb_get_serial_port_data(port);


	for (i = 0; i < N_OUT_URB; i++) {
		this_urb = portdata->out_urbs[i];
		if (this_urb && !test_bit(i, &portdata->out_busy))
			data_len += OUT_BUFLEN;
	}

	dbg("%s: %d", __func__, data_len);
	return data_len;
}

static int zte_chars_in_buffer(struct tty_struct *tty)
{
	struct usb_serial_port *port = tty->driver_data;
	struct zte_port_private *portdata;
	int i;
	int data_len = 0;
	struct urb *this_urb;

	portdata = usb_get_serial_port_data(port);

	for (i = 0; i < N_OUT_URB; i++) {
		this_urb = portdata->out_urbs[i];
		/* FIXME: This locking is insufficient as this_urb may
		   go unused during the test */
		if (this_urb && test_bit(i, &portdata->out_busy))
			data_len += this_urb->transfer_buffer_length;
	}
	dbg("%s: %d", __func__, data_len);
	return data_len;
}

static int zte_open(struct tty_struct *tty,
			struct usb_serial_port *port, struct file *filp)
{
	struct zte_port_private *portdata;
	struct usb_serial *serial = port->serial;
	int i, err;
	struct urb *urb;

	portdata = usb_get_serial_port_data(port);

	dbg("%s", __func__);

	/* Set some sane defaults */
	portdata->rts_state = 1;
	portdata->dtr_state = 1;

	/* Reset low level data toggle and start reading from endpoints */
	for (i = 0; i < N_IN_URB; i++) {
		urb = portdata->in_urbs[i];
		if (!urb)
			continue;
		if (urb->dev != serial->dev) {
			dbg("%s: dev %p != %p", __func__,
				urb->dev, serial->dev);
			continue;
		}

		/*
		 * make sure endpoint data toggle is synchronized with the
		 * device
		 */
		usb_clear_halt(urb->dev, urb->pipe);

		err = usb_submit_urb(urb, GFP_KERNEL);
		if (err) {
			dbg("%s: submit urb %d failed (%d) %d",
				__func__, i, err,
				urb->transfer_buffer_length);
		}
	}

	/* Reset low level data toggle on out endpoints */
	for (i = 0; i < N_OUT_URB; i++) {
		urb = portdata->out_urbs[i];
		if (!urb)
			continue;
		urb->dev = serial->dev;
		/* usb_settoggle(urb->dev, usb_pipeendpoint(urb->pipe),
				usb_pipeout(urb->pipe), 0); */
	}

	if (tty)
		tty->low_latency = 1;

	zte_send_setup(tty, port);

	return 0;
}

static void zte_close(struct tty_struct *tty,
			struct usb_serial_port *port, struct file *filp)
{
	int i;
	struct usb_serial *serial = port->serial;
	struct zte_port_private *portdata;

	dbg("%s", __func__);
	portdata = usb_get_serial_port_data(port);

	portdata->rts_state = 0;
	portdata->dtr_state = 0;

	if (serial->dev) {
		mutex_lock(&serial->disc_mutex);
		if (!serial->disconnected)
			zte_send_setup(tty, port);
		mutex_unlock(&serial->disc_mutex);

		/* Stop reading/writing urbs */
		for (i = 0; i < N_IN_URB; i++)
			usb_kill_urb(portdata->in_urbs[i]);
		for (i = 0; i < N_OUT_URB; i++)
			usb_kill_urb(portdata->out_urbs[i]);
	}
	tty_port_tty_set(&port->port, NULL);
}

/* Helper functions used by zte_setup_urbs */
static struct urb *zte_setup_urb(struct usb_serial *serial, int endpoint,
		int dir, void *ctx, char *buf, int len,
		void (*callback)(struct urb *))
{
	struct urb *urb;

	if (endpoint == -1)
		return NULL;		/* endpoint not needed */

	urb = usb_alloc_urb(0, GFP_KERNEL);		/* No ISO */
	if (urb == NULL) {
		dbg("%s: alloc for endpoint %d failed.", __func__, endpoint);
		return NULL;
	}

		/* Fill URB using supplied data. */
	usb_fill_bulk_urb(urb, serial->dev,
		      usb_sndbulkpipe(serial->dev, endpoint) | dir,
		      buf, len, callback, ctx);

	return urb;
}

/* Setup urbs */
static void zte_setup_urbs(struct usb_serial *serial)
{
	int i, j;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;

	dbg("%s", __func__);

	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);

		/* Do indat endpoints first */
		for (j = 0; j < N_IN_URB; ++j) {
			portdata->in_urbs[j] = zte_setup_urb(serial,
					port->bulk_in_endpointAddress,
					USB_DIR_IN, port,
					portdata->in_buffer[j],
					IN_BUFLEN, zte_indat_callback);
		}

		/* outdat endpoints */
		for (j = 0; j < N_OUT_URB; ++j) {
			portdata->out_urbs[j] = zte_setup_urb(serial,
					port->bulk_out_endpointAddress,
					USB_DIR_OUT, port,
					portdata->out_buffer[j],
					OUT_BUFLEN, zte_outdat_callback);
		}
	}
}


/** send RTS/DTR state to the port.
 *
 * This is exactly the same as SET_CONTROL_LINE_STATE from the PSTN
 * CDC.
*/
static int zte_send_setup(struct tty_struct *tty,
						struct usb_serial_port *port)
{
	struct usb_serial *serial = port->serial;
	struct zte_port_private *portdata;
	int ifNum = serial->interface->cur_altsetting->desc.bInterfaceNumber;
	dbg("%s", __func__);

	portdata = usb_get_serial_port_data(port);

	if (tty) {
		int val = 0;
		if (portdata->dtr_state)
			val |= 0x01;
		if (portdata->rts_state)
			val |= 0x02;

		return usb_control_msg(serial->dev,
			usb_rcvctrlpipe(serial->dev, 0),
			0x22, 0x21, val, ifNum, NULL, 0, USB_CTRL_SET_TIMEOUT);
	}
	return 0;
}

static int zte_startup(struct usb_serial *serial)
{
	int i, j, err;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;
	u8 *buffer;

	dbg("%s", __func__);

	/* Now setup per port private data */
	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		portdata = kzalloc(sizeof(*portdata), GFP_KERNEL);
		if (!portdata) {
			dbg("%s: kmalloc for zte_port_private (%d) failed!.",
					__func__, i);
			return 1;
		}

		for (j = 0; j < N_IN_URB; j++) {
			buffer = (u8 *)__get_free_page(GFP_KERNEL);
			if (!buffer)
				goto bail_out_error;
			portdata->in_buffer[j] = buffer;
		}

		for (j = 0; j < N_OUT_URB; j++) {
			buffer = kmalloc(OUT_BUFLEN, GFP_KERNEL);
			if (!buffer)
				goto bail_out_error2;
			portdata->out_buffer[j] = buffer;
		}

		usb_set_serial_port_data(port, portdata);

		if (!port->interrupt_in_urb)
			continue;
		err = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);
		if (err)
			dbg("%s: submit irq_in urb failed %d",
				__func__, err);
	}
	zte_setup_urbs(serial);
	return 0;

bail_out_error2:
	for (j = 0; j < N_OUT_URB; j++)
		kfree(portdata->out_buffer[j]);
bail_out_error:
	for (j = 0; j < N_IN_URB; j++)
		if (portdata->in_buffer[j])
			free_page((unsigned long)portdata->in_buffer[j]);
	kfree(portdata);
	return 1;
}

static void zte_shutdown(struct usb_serial *serial)
{
	int i, j;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;

	dbg("%s", __func__);

	/* Stop reading/writing urbs */
	for (i = 0; i < serial->num_ports; ++i) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);
		for (j = 0; j < N_IN_URB; j++)
			usb_kill_urb(portdata->in_urbs[j]);
		for (j = 0; j < N_OUT_URB; j++)
			usb_kill_urb(portdata->out_urbs[j]);
	}

	/* Now free them */
	for (i = 0; i < serial->num_ports; ++i) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);

		for (j = 0; j < N_IN_URB; j++) {
			if (portdata->in_urbs[j]) {
				usb_free_urb(portdata->in_urbs[j]);
				free_page((unsigned long)
					portdata->in_buffer[j]);
				portdata->in_urbs[j] = NULL;
			}
		}
		for (j = 0; j < N_OUT_URB; j++) {
			if (portdata->out_urbs[j]) {
				usb_free_urb(portdata->out_urbs[j]);
				kfree(portdata->out_buffer[j]);
				portdata->out_urbs[j] = NULL;
			}
		}
	}

	/* Now free per port private data */
	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		kfree(usb_get_serial_port_data(port));
	}
}

MODULE_AUTHOR(DRIVER_AUTHOR);
MODULE_DESCRIPTION(DRIVER_DESC);
MODULE_VERSION(DRIVER_VERSION);
MODULE_LICENSE("GPL");

module_param(debug, bool, S_IRUGO | S_IWUSR);
MODULE_PARM_DESC(debug, "Debug messages");
//#else  //\B5\B1\D3\D030ʱ\A3\AC\C7\EBע\CA͵\F4\B1\BE\D0к\CD\CF\C2\D0\D0if some new code added,pls remove this line and next line

//#endif
#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,31)//use 2.6.30 sourcecode

#include <linux/kernel.h>
#include <linux/jiffies.h>
#include <linux/errno.h>
#include <linux/tty.h>
#include <linux/tty_flip.h>
#include <linux/module.h>
#include <linux/bitops.h>
#include <linux/usb.h>
#include <linux/usb/serial.h>

/* Function prototypes */
static int  zte_open(struct tty_struct *tty, struct usb_serial_port *port,
							struct file *filp);
static void zte_close(struct tty_struct *tty, struct usb_serial_port *port,
							struct file *filp);
static int  zte_startup(struct usb_serial *serial);
static void zte_shutdown(struct usb_serial *serial);
static int  zte_write_room(struct tty_struct *tty);

static void zte_instat_callback(struct urb *urb);

static int zte_write(struct tty_struct *tty, struct usb_serial_port *port,
			const unsigned char *buf, int count);
static int  zte_chars_in_buffer(struct tty_struct *tty);
static void zte_set_termios(struct tty_struct *tty,
			struct usb_serial_port *port, struct ktermios *old);
static int  zte_tiocmget(struct tty_struct *tty, struct file *file);
static int  zte_tiocmset(struct tty_struct *tty, struct file *file,
				unsigned int set, unsigned int clear);
static int  zte_send_setup(struct tty_struct *tty, struct usb_serial_port *port);
static int  zte_suspend(struct usb_serial *serial, pm_message_t message);
static int  zte_resume(struct usb_serial *serial);

/* Vendor and product IDs */
#define zte_VENDOR_ID			0x19d2

static struct usb_device_id zte_ids[] = {
	   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0001, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0002, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0003, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0004, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0005, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0006, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0007, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0008, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0009, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0010, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0011, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0012, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0013, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0014, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0015, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0016, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0017, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0018, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0019, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0020, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0021, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0022, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0023, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0024, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0025, 0xff, 0xff, 0xff) },
    //   { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0026, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0027, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0028, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0029, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0030, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0031, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0032, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0033, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0034, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0035, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0036, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0037, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0038, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0039, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0040, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0041, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0042, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0043, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0044, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0045, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0046, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0047, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0048, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0049, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0050, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0051, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0052, 0xff, 0xff, 0xff) },
    //   { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0053, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0054, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0055, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0056, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0057, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0058, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0059, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0060, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0061, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0062, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0063, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0064, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0065, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0066, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0067, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0068, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0069, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0070, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0071, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0072, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0073, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0074, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0075, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0076, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0077, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0078, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0079, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0080, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0081, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0082, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0083, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0084, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0085, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0086, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0087, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0088, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0089, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0090, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0091, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0092, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0093, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0094, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0095, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0096, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0097, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0098, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0099, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0104, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0105, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0106, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0108, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0117, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0118, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0121, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0122, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0123, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0124, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0125, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0126, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0128, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0130, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0133, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0141, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0144, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0145, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0147, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0148, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0151, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0152, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0153, 0xff, 0xff, 0xff) },
    //{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0154, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0155, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0156, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0157, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0158, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0159, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0160, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0161, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0162, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0164, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0165, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0168, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0170, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0176, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0178, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1008, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1010, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1012, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1057, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1058, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1059, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1060, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1061, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1062, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1063, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1064, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1065, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1066, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1067, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1068, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1069, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1070, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1071, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1072, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1073, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1074, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1075, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1076, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1077, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1078, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1079, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1080, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1081, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1082, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1083, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1084, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1085, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1086, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1087, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1088, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1089, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1090, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1091, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1092, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1093, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1094, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1095, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1096, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1097, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1098, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1099, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1100, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1101, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1102, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1103, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1104, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1105, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1106, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1107, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1108, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1109, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1110, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1111, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1112, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1113, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1114, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1115, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1116, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1117, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1118, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1119, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1120, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1121, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1122, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1123, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1124, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1125, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1126, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1127, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1128, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1129, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1130, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1131, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1132, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1133, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1134, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1135, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1136, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1137, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1138, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1139, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1140, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1141, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1142, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1143, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1144, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1145, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1146, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1147, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1148, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1149, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1150, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1151, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1152, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1153, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1154, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1155, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1156, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1157, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1158, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1159, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1160, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1161, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1162, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1163, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1164, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1165, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1166, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1167, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1168, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1169, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1170, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1244, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1245, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1246, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1247, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1248, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1249, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1250, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1251, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1252, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1253, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1254, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1255, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1256, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1257, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1258, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1259, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1260, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1261, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1262, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1263, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1264, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1265, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1266, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1267, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1268, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1269, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1270, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1271, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1272, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1273, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1274, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1275, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1276, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1277, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1278, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1279, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1280, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1281, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1282, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1283, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1284, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1285, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1286, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1287, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1288, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1289, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1290, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1291, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1292, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1293, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1294, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1295, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1296, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1297, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1298, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1299, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1300, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1401, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1402, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1403, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1404, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1405, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1406, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1407, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1408, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1409, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1410, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1411, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1412, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1413, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1414, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1415, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1416, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1417, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1418, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1419, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1420, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1421, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1422, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1423, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1424, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1425, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1426, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1427, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1428, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1429, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1430, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1431, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1432, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1433, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1434, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1435, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1436, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1437, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1438, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1439, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1440, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1441, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1442, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1443, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1444, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1445, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1446, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1447, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1448, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1449, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1450, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1451, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1452, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1453, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1454, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1455, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1456, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1457, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1458, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1459, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1460, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1461, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1462, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1463, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1464, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1465, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1466, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1467, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1468, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1469, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1470, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1471, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1472, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1473, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1474, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1475, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1476, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1477, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1478, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1479, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1480, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1481, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1482, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1483, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1484, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1485, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1486, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1487, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1488, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1489, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1490, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1491, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1492, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1493, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1494, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1495, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1496, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1497, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1498, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1499, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1500, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1501, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1502, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1503, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1504, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1505, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1506, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1507, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1508, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1509, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1510, 0xff, 0xff, 0xff) },       
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x2002, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x2003, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0xFFEC, 0xff, 0xff, 0xff) },

    { USB_DEVICE_AND_INTERFACE_INFO(TPLink_VENDOR_ID, 0x7E11, 0xff, 0xff, 0xff) },/*TPLink*/
    { USB_DEVICE_AND_INTERFACE_INFO(QUALCOMM_VENDOR_ID, 0x9001, 0xff, 0xff, 0xff) },/*QUALCOMM_VENDOR_ID*/
    { USB_DEVICE_AND_INTERFACE_INFO(QUALCOMM_VENDOR_ID, 0x9002, 0xff, 0xff, 0xff) },

	{ } /* Terminating entry */
};
MODULE_DEVICE_TABLE(usb, zte_ids);

static struct usb_driver zte_driver = {
	.name       = "zte",
	.probe      = usb_serial_probe,
	.disconnect = usb_serial_disconnect,
	.suspend    = usb_serial_suspend,
	.resume     = usb_serial_resume,
	.id_table   = zte_ids,
	.no_dynamic_id = 	1,
};

/* The card has three separate interfaces, which the serial driver
 * recognizes separately, thus num_port=1.
 */

static struct usb_serial_driver zte_1port_device = {
	.driver = {
		.owner =	THIS_MODULE,
		.name =		"zte1",
	},
	.description       = "GSM modem (1-port)",
	.usb_driver        = &zte_driver,
	.id_table          = zte_ids,
	.num_ports         = 1,
	.open              = zte_open,
	.close             = zte_close,
	.write             = zte_write,
	.write_room        = zte_write_room,
	.chars_in_buffer   = zte_chars_in_buffer,
	.set_termios       = zte_set_termios,
	.tiocmget          = zte_tiocmget,
	.tiocmset          = zte_tiocmset,
	.attach            = zte_startup,
	.shutdown          = zte_shutdown,
	.read_int_callback = zte_instat_callback,
	.suspend           = zte_suspend,
	.resume            = zte_resume,
};

static int debug;

/* per port private data */

#define N_IN_URB 4
#define N_OUT_URB 4
#define IN_BUFLEN 4096
#define OUT_BUFLEN 4096

struct zte_port_private {
	/* Input endpoints and buffer for this port */
	struct urb *in_urbs[N_IN_URB];
	u8 *in_buffer[N_IN_URB];
	/* Output endpoints and buffer for this port */
	struct urb *out_urbs[N_OUT_URB];
	u8 *out_buffer[N_OUT_URB];
	unsigned long out_busy;		/* Bit vector of URBs in use */

	/* Settings for the port */
	int rts_state;	/* Handshaking pins (outputs) */
	int dtr_state;
	int cts_state;	/* Handshaking pins (inputs) */
	int dsr_state;
	int dcd_state;
	int ri_state;

	unsigned long tx_start_time[N_OUT_URB];
};

/* Functions used by new usb-serial code. */
static int __init zte_init(void)
{
	int retval;
	retval = usb_serial_register(&zte_1port_device);
	if (retval)
		goto failed_1port_device_register;
	retval = usb_register(&zte_driver);
	if (retval)
		goto failed_driver_register;

	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
	       DRIVER_DESC "\n");

	return 0;

failed_driver_register:
	usb_serial_deregister(&zte_1port_device);
failed_1port_device_register:
	return retval;
}

static void __exit zte_exit(void)
{
	usb_deregister(&zte_driver);
	usb_serial_deregister(&zte_1port_device);
}

module_init(zte_init);
module_exit(zte_exit);

static void zte_set_termios(struct tty_struct *tty,
		struct usb_serial_port *port, struct ktermios *old_termios)
{
	dbg("%s", __func__);
	/* Doesn't support zte setting */
	tty_termios_copy_hw(tty->termios, old_termios);
	zte_send_setup(tty, port);
}

static int zte_tiocmget(struct tty_struct *tty, struct file *file)
{
	struct usb_serial_port *port = tty->driver_data;
	unsigned int value;
	struct zte_port_private *portdata;

	portdata = usb_get_serial_port_data(port);

	value = ((portdata->rts_state) ? TIOCM_RTS : 0) |
		((portdata->dtr_state) ? TIOCM_DTR : 0) |
		((portdata->cts_state) ? TIOCM_CTS : 0) |
		((portdata->dsr_state) ? TIOCM_DSR : 0) |
		((portdata->dcd_state) ? TIOCM_CAR : 0) |
		((portdata->ri_state) ? TIOCM_RNG : 0);

	return value;
}

static int zte_tiocmset(struct tty_struct *tty, struct file *file,
			unsigned int set, unsigned int clear)
{
	struct usb_serial_port *port = tty->driver_data;
	struct zte_port_private *portdata;

	portdata = usb_get_serial_port_data(port);

	/* FIXME: what locks portdata fields ? */
	if (set & TIOCM_RTS)
		portdata->rts_state = 1;
	if (set & TIOCM_DTR)
		portdata->dtr_state = 1;

	if (clear & TIOCM_RTS)
		portdata->rts_state = 0;
	if (clear & TIOCM_DTR)
		portdata->dtr_state = 0;
	return zte_send_setup(tty, port);
}

/* Write */
static int zte_write(struct tty_struct *tty, struct usb_serial_port *port,
			const unsigned char *buf, int count)
{
	struct zte_port_private *portdata;
	int i;
	int left, todo;
	struct urb *this_urb = NULL; /* spurious */
	int err;

	portdata = usb_get_serial_port_data(port);

	dbg("%s: write (%d chars)", __func__, count);

	i = 0;
	left = count;
	for (i = 0; left > 0 && i < N_OUT_URB; i++) {
		todo = left;
		if (todo > OUT_BUFLEN)
			todo = OUT_BUFLEN;

		this_urb = portdata->out_urbs[i];
		if (test_and_set_bit(i, &portdata->out_busy)) {
			if (time_before(jiffies,
					portdata->tx_start_time[i] + 10 * HZ))
				continue;
			usb_unlink_urb(this_urb);
			continue;
		}
		dbg("%s: endpoint %d buf %d", __func__,
			usb_pipeendpoint(this_urb->pipe), i);

		/* send the data */
		memcpy(this_urb->transfer_buffer, buf, todo);
		this_urb->transfer_buffer_length = todo;

		this_urb->dev = port->serial->dev;
		err = usb_submit_urb(this_urb, GFP_ATOMIC);
		if (err) {
			dbg("usb_submit_urb %p (write bulk) failed "
				"(%d)", this_urb, err);
			clear_bit(i, &portdata->out_busy);
			continue;
		}
		portdata->tx_start_time[i] = jiffies;
		buf += todo;
		left -= todo;
	}

	count -= left;
	dbg("%s: wrote (did %d)", __func__, count);
	return count;
}

static void zte_indat_callback(struct urb *urb)
{
	int err;
	int endpoint;
	struct usb_serial_port *port;
	struct tty_struct *tty;
	unsigned char *data = urb->transfer_buffer;
	int status = urb->status;

	dbg("%s: %p", __func__, urb);

	endpoint = usb_pipeendpoint(urb->pipe);
	port =  urb->context;

	if (status) {
		dbg("%s: nonzero status: %d on endpoint %02x.",
		    __func__, status, endpoint);
	} else {
		tty = tty_port_tty_get(&port->port);
		if (urb->actual_length) {
			tty_buffer_request_room(tty, urb->actual_length);
			tty_insert_flip_string(tty, data, urb->actual_length);
			tty_flip_buffer_push(tty);
		} else 
			dbg("%s: empty read urb received", __func__);
		tty_kref_put(tty);

		/* Resubmit urb so we continue receiving */
		if (port->port.count && status != -ESHUTDOWN) {
			err = usb_submit_urb(urb, GFP_ATOMIC);
			if (err)
				printk(KERN_ERR "%s: resubmit read urb failed. "
					"(%d)", __func__, err);
		}
	}
	return;
}

static void zte_outdat_callback(struct urb *urb)
{
	struct usb_serial_port *port;
	struct zte_port_private *portdata;
	int i;

	dbg("%s", __func__);

	port =  urb->context;

	usb_serial_port_softint(port);

	portdata = usb_get_serial_port_data(port);
	for (i = 0; i < N_OUT_URB; ++i) {
		if (portdata->out_urbs[i] == urb) {
			smp_mb__before_clear_bit();
			clear_bit(i, &portdata->out_busy);
			break;
		}
	}
}

static void zte_instat_callback(struct urb *urb)
{
	int err;
	int status = urb->status;
	struct usb_serial_port *port =  urb->context;
	struct zte_port_private *portdata = usb_get_serial_port_data(port);
	struct usb_serial *serial = port->serial;

	dbg("%s", __func__);
	dbg("%s: urb %p port %p has data %p", __func__, urb, port, portdata);

	if (status == 0) {
		struct usb_ctrlrequest *req_pkt =
				(struct usb_ctrlrequest *)urb->transfer_buffer;

		if (!req_pkt) {
			dbg("%s: NULL req_pkt\n", __func__);
			return;
		}
		if ((req_pkt->bRequestType == 0xA1) &&
				(req_pkt->bRequest == 0x20)) {
			int old_dcd_state;
			unsigned char signals = *((unsigned char *)
					urb->transfer_buffer +
					sizeof(struct usb_ctrlrequest));

			dbg("%s: signal x%x", __func__, signals);

			old_dcd_state = portdata->dcd_state;
			portdata->cts_state = 1;
			portdata->dcd_state = ((signals & 0x01) ? 1 : 0);
			portdata->dsr_state = ((signals & 0x02) ? 1 : 0);
			portdata->ri_state = ((signals & 0x08) ? 1 : 0);

			if (old_dcd_state && !portdata->dcd_state) {
				struct tty_struct *tty =
						tty_port_tty_get(&port->port);
				if (tty && !C_CLOCAL(tty))
					tty_hangup(tty);
				tty_kref_put(tty);
			}
		} else {
			dbg("%s: type %x req %x", __func__,
				req_pkt->bRequestType, req_pkt->bRequest);
		}
	} else
		err("%s: error %d", __func__, status);

	/* Resubmit urb so we continue receiving IRQ data */
	if (status != -ESHUTDOWN && status != -ENOENT) {
		urb->dev = serial->dev;
		err = usb_submit_urb(urb, GFP_ATOMIC);
		if (err)
			dbg("%s: resubmit intr urb failed. (%d)",
				__func__, err);
	}
}

static int zte_write_room(struct tty_struct *tty)
{
	struct usb_serial_port *port = tty->driver_data;
	struct zte_port_private *portdata;
	int i;
	int data_len = 0;
	struct urb *this_urb;

	portdata = usb_get_serial_port_data(port);

	for (i = 0; i < N_OUT_URB; i++) {
		this_urb = portdata->out_urbs[i];
		if (this_urb && !test_bit(i, &portdata->out_busy))
			data_len += OUT_BUFLEN;
	}

	dbg("%s: %d", __func__, data_len);
	return data_len;
}

static int zte_chars_in_buffer(struct tty_struct *tty)
{
	struct usb_serial_port *port = tty->driver_data;
	struct zte_port_private *portdata;
	int i;
	int data_len = 0;
	struct urb *this_urb;

	portdata = usb_get_serial_port_data(port);

	for (i = 0; i < N_OUT_URB; i++) {
		this_urb = portdata->out_urbs[i];
		/* FIXME: This locking is insufficient as this_urb may
		   go unused during the test */
		if (this_urb && test_bit(i, &portdata->out_busy))
			data_len += this_urb->transfer_buffer_length;
	}
	dbg("%s: %d", __func__, data_len);
	return data_len;
}

static int zte_open(struct tty_struct *tty,
			struct usb_serial_port *port, struct file *filp)
{
	struct zte_port_private *portdata;
	struct usb_serial *serial = port->serial;
	int i, err;
	struct urb *urb;

	portdata = usb_get_serial_port_data(port);

	dbg("%s", __func__);

	/* Set some sane defaults */
	portdata->rts_state = 1;
	portdata->dtr_state = 1;

	/* Reset low level data toggle and start reading from endpoints */
	for (i = 0; i < N_IN_URB; i++) {
		urb = portdata->in_urbs[i];
		if (!urb)
			continue;
		if (urb->dev != serial->dev) {
			dbg("%s: dev %p != %p", __func__,
				urb->dev, serial->dev);
			continue;
		}

		/*
		 * make sure endpoint data toggle is synchronized with the
		 * device
		 */
		usb_clear_halt(urb->dev, urb->pipe);

		err = usb_submit_urb(urb, GFP_KERNEL);
		if (err) {
			dbg("%s: submit urb %d failed (%d) %d",
				__func__, i, err,
				urb->transfer_buffer_length);
		}
	}

	/* Reset low level data toggle on out endpoints */
	for (i = 0; i < N_OUT_URB; i++) {
		urb = portdata->out_urbs[i];
		if (!urb)
			continue;
		urb->dev = serial->dev;
		/* usb_settoggle(urb->dev, usb_pipeendpoint(urb->pipe),
				usb_pipeout(urb->pipe), 0); */
	}

	zte_send_setup(tty, port);

	return 0;
}

static void zte_close(struct tty_struct *tty,
			struct usb_serial_port *port, struct file *filp)
{
	int i;
	struct usb_serial *serial = port->serial;
	struct zte_port_private *portdata;

	dbg("%s", __func__);
	portdata = usb_get_serial_port_data(port);

	portdata->rts_state = 0;
	portdata->dtr_state = 0;

	if (serial->dev) {
		mutex_lock(&serial->disc_mutex);
		if (!serial->disconnected)
			zte_send_setup(tty, port);
		mutex_unlock(&serial->disc_mutex);

		/* Stop reading/writing urbs */
		for (i = 0; i < N_IN_URB; i++)
			usb_kill_urb(portdata->in_urbs[i]);
		for (i = 0; i < N_OUT_URB; i++)
			usb_kill_urb(portdata->out_urbs[i]);
	}
	tty_port_tty_set(&port->port, NULL);
}

/* Helper functions used by zte_setup_urbs */
static struct urb *zte_setup_urb(struct usb_serial *serial, int endpoint,
		int dir, void *ctx, char *buf, int len,
		void (*callback)(struct urb *))
{
	struct urb *urb;

	if (endpoint == -1)
		return NULL;		/* endpoint not needed */

	urb = usb_alloc_urb(0, GFP_KERNEL);		/* No ISO */
	if (urb == NULL) {
		dbg("%s: alloc for endpoint %d failed.", __func__, endpoint);
		return NULL;
	}

		/* Fill URB using supplied data. */
	usb_fill_bulk_urb(urb, serial->dev,
		      usb_sndbulkpipe(serial->dev, endpoint) | dir,
		      buf, len, callback, ctx);

	return urb;
}

/* Setup urbs */
static void zte_setup_urbs(struct usb_serial *serial)
{
	int i, j;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;

	dbg("%s", __func__);

	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);

		/* Do indat endpoints first */
		for (j = 0; j < N_IN_URB; ++j) {
			portdata->in_urbs[j] = zte_setup_urb(serial,
					port->bulk_in_endpointAddress,
					USB_DIR_IN, port,
					portdata->in_buffer[j],
					IN_BUFLEN, zte_indat_callback);
		}

		/* outdat endpoints */
		for (j = 0; j < N_OUT_URB; ++j) {
			portdata->out_urbs[j] = zte_setup_urb(serial,
					port->bulk_out_endpointAddress,
					USB_DIR_OUT, port,
					portdata->out_buffer[j],
					OUT_BUFLEN, zte_outdat_callback);
		}
	}
}


/** send RTS/DTR state to the port.
 *
 * This is exactly the same as SET_CONTROL_LINE_STATE from the PSTN
 * CDC.
*/
static int zte_send_setup(struct tty_struct *tty,
						struct usb_serial_port *port)
{
	struct usb_serial *serial = port->serial;
	struct zte_port_private *portdata;
	int ifNum = serial->interface->cur_altsetting->desc.bInterfaceNumber;
	dbg("%s", __func__);

	portdata = usb_get_serial_port_data(port);

	if (tty) {
		int val = 0;
		if (portdata->dtr_state)
			val |= 0x01;
		if (portdata->rts_state)
			val |= 0x02;

		return usb_control_msg(serial->dev,
			usb_rcvctrlpipe(serial->dev, 0),
			0x22, 0x21, val, ifNum, NULL, 0, USB_CTRL_SET_TIMEOUT);
	}
	return 0;
}

static int zte_startup(struct usb_serial *serial)
{
	int i, j, err;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;
	u8 *buffer;

	dbg("%s", __func__);

	/* Now setup per port private data */
	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		portdata = kzalloc(sizeof(*portdata), GFP_KERNEL);
		if (!portdata) {
			dbg("%s: kmalloc for zte_port_private (%d) failed!.",
					__func__, i);
			return 1;
		}

		for (j = 0; j < N_IN_URB; j++) {
			buffer = (u8 *)__get_free_page(GFP_KERNEL);
			if (!buffer)
				goto bail_out_error;
			portdata->in_buffer[j] = buffer;
		}

		for (j = 0; j < N_OUT_URB; j++) {
			buffer = kmalloc(OUT_BUFLEN, GFP_KERNEL);
			if (!buffer)
				goto bail_out_error2;
			portdata->out_buffer[j] = buffer;
		}

		usb_set_serial_port_data(port, portdata);

		if (!port->interrupt_in_urb)
			continue;
		err = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);
		if (err)
			dbg("%s: submit irq_in urb failed %d",
				__func__, err);
	}
	zte_setup_urbs(serial);
	return 0;

bail_out_error2:
	for (j = 0; j < N_OUT_URB; j++)
		kfree(portdata->out_buffer[j]);
bail_out_error:
	for (j = 0; j < N_IN_URB; j++)
		if (portdata->in_buffer[j])
			free_page((unsigned long)portdata->in_buffer[j]);
	kfree(portdata);
	return 1;
}

static void stop_read_write_urbs(struct usb_serial *serial)
{
	int i, j;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;

	/* Stop reading/writing urbs */
	for (i = 0; i < serial->num_ports; ++i) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);
		for (j = 0; j < N_IN_URB; j++)
			usb_kill_urb(portdata->in_urbs[j]);
		for (j = 0; j < N_OUT_URB; j++)
			usb_kill_urb(portdata->out_urbs[j]);
	}
}

static void zte_shutdown(struct usb_serial *serial)
{
	int i, j;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;

	dbg("%s", __func__);

	stop_read_write_urbs(serial);

	/* Now free them */
	for (i = 0; i < serial->num_ports; ++i) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);

		for (j = 0; j < N_IN_URB; j++) {
			if (portdata->in_urbs[j]) {
				usb_free_urb(portdata->in_urbs[j]);
				free_page((unsigned long)
					portdata->in_buffer[j]);
				portdata->in_urbs[j] = NULL;
			}
		}
		for (j = 0; j < N_OUT_URB; j++) {
			if (portdata->out_urbs[j]) {
				usb_free_urb(portdata->out_urbs[j]);
				kfree(portdata->out_buffer[j]);
				portdata->out_urbs[j] = NULL;
			}
		}
	}

	/* Now free per port private data */
	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		kfree(usb_get_serial_port_data(port));
	}
}

static int zte_suspend(struct usb_serial *serial, pm_message_t message)
{
	dbg("%s entered", __func__);
	stop_read_write_urbs(serial);

	return 0;
}

static int zte_resume(struct usb_serial *serial)
{
	int err, i, j;
	struct usb_serial_port *port;
	struct urb *urb;
	struct zte_port_private *portdata;

	dbg("%s entered", __func__);
	/* get the interrupt URBs resubmitted unconditionally */
	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		if (!port->interrupt_in_urb) {
			dbg("%s: No interrupt URB for port %d\n", __func__, i);
			continue;
		}
		port->interrupt_in_urb->dev = serial->dev;
		err = usb_submit_urb(port->interrupt_in_urb, GFP_NOIO);
		dbg("Submitted interrupt URB for port %d (result %d)", i, err);
		if (err < 0) {
			err("%s: Error %d for interrupt URB of port%d",
				 __func__, err, i);
			return err;
		}
	}

	for (i = 0; i < serial->num_ports; i++) {
		/* walk all ports */
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);
		mutex_lock(&port->mutex);

		/* skip closed ports */
		if (!port->port.count) {
			mutex_unlock(&port->mutex);
			continue;
		}

		for (j = 0; j < N_IN_URB; j++) {
			urb = portdata->in_urbs[j];
			err = usb_submit_urb(urb, GFP_NOIO);
			if (err < 0) {
				mutex_unlock(&port->mutex);
				err("%s: Error %d for bulk URB %d",
					 __func__, err, i);
				return err;
			}
		}
		mutex_unlock(&port->mutex);
	}
	return 0;
}

MODULE_AUTHOR(DRIVER_AUTHOR);
MODULE_DESCRIPTION(DRIVER_DESC);
MODULE_VERSION(DRIVER_VERSION);
MODULE_LICENSE("GPL");

module_param(debug, bool, S_IRUGO | S_IWUSR);
MODULE_PARM_DESC(debug, "Debug messages"); 

#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)//use 2.6.31 sourcecode


#include <linux/kernel.h>
#include <linux/jiffies.h>
#include <linux/errno.h>
#include <linux/tty.h>
#include <linux/tty_flip.h>
#include <linux/module.h>
#include <linux/bitops.h>
#include <linux/usb.h>
#include <linux/usb/serial.h>

/* Function prototypes */
static int  zte_probe(struct usb_serial *serial,
			const struct usb_device_id *id);
static int  zte_open(struct tty_struct *tty, struct usb_serial_port *port,
							struct file *filp);
static void zte_close(struct usb_serial_port *port);
static void zte_dtr_rts(struct usb_serial_port *port, int on);

static int  zte_startup(struct usb_serial *serial);
static void zte_disconnect(struct usb_serial *serial);
static void zte_release(struct usb_serial *serial);
static int  zte_write_room(struct tty_struct *tty);

static void zte_instat_callback(struct urb *urb);

static int zte_write(struct tty_struct *tty, struct usb_serial_port *port,
			const unsigned char *buf, int count);
static int  zte_chars_in_buffer(struct tty_struct *tty);
static void zte_set_termios(struct tty_struct *tty,
			struct usb_serial_port *port, struct ktermios *old);
static int  zte_tiocmget(struct tty_struct *tty, struct file *file);
static int  zte_tiocmset(struct tty_struct *tty, struct file *file,
				unsigned int set, unsigned int clear);
static int  zte_send_setup(struct usb_serial_port *port);
#ifdef CONFIG_PM
static int  zte_suspend(struct usb_serial *serial, pm_message_t message);
static int  zte_resume(struct usb_serial *serial);
#endif

/* Vendor and product IDs */
/* Vendor and product IDs */
#define zte_VENDOR_ID			0x19d2

static struct usb_device_id zte_ids[] = {
	   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0001, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0002, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0003, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0004, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0005, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0006, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0007, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0008, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0009, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0010, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0011, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0012, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0013, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0014, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0015, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0016, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0017, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0018, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0019, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0020, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0021, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0022, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0023, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0024, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0025, 0xff, 0xff, 0xff) },
    //   { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0026, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0027, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0028, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0029, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0030, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0031, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0032, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0033, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0034, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0035, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0036, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0037, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0038, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0039, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0040, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0041, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0042, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0043, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0044, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0045, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0046, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0047, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0048, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0049, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0050, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0051, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0052, 0xff, 0xff, 0xff) },
    //   { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0053, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0054, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0055, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0056, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0057, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0058, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0059, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0060, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0061, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0062, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0063, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0064, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0065, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0066, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0067, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0068, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0069, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0070, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0071, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0072, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0073, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0074, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0075, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0076, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0077, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0078, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0079, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0080, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0081, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0082, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0083, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0084, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0085, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0086, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0087, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0088, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0089, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0090, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0091, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0092, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0093, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0094, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0095, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0096, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0097, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0098, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0099, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0104, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0105, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0106, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0108, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0117, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0118, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0121, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0122, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0123, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0124, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0125, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0126, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0128, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0130, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0133, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0141, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0144, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0145, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0147, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0148, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0151, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0152, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0153, 0xff, 0xff, 0xff) },
    //{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0154, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0155, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0156, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0157, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0158, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0159, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0160, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0161, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0162, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0164, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0165, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0168, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0170, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0176, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0178, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1008, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1010, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1012, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1057, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1058, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1059, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1060, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1061, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1062, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1063, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1064, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1065, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1066, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1067, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1068, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1069, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1070, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1071, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1072, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1073, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1074, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1075, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1076, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1077, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1078, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1079, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1080, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1081, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1082, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1083, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1084, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1085, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1086, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1087, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1088, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1089, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1090, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1091, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1092, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1093, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1094, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1095, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1096, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1097, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1098, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1099, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1100, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1101, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1102, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1103, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1104, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1105, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1106, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1107, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1108, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1109, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1110, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1111, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1112, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1113, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1114, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1115, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1116, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1117, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1118, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1119, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1120, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1121, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1122, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1123, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1124, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1125, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1126, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1127, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1128, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1129, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1130, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1131, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1132, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1133, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1134, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1135, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1136, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1137, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1138, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1139, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1140, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1141, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1142, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1143, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1144, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1145, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1146, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1147, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1148, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1149, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1150, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1151, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1152, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1153, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1154, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1155, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1156, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1157, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1158, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1159, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1160, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1161, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1162, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1163, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1164, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1165, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1166, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1167, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1168, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1169, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1170, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1244, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1245, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1246, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1247, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1248, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1249, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1250, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1251, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1252, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1253, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1254, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1255, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1256, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1257, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1258, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1259, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1260, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1261, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1262, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1263, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1264, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1265, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1266, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1267, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1268, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1269, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1270, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1271, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1272, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1273, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1274, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1275, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1276, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1277, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1278, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1279, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1280, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1281, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1282, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1283, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1284, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1285, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1286, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1287, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1288, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1289, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1290, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1291, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1292, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1293, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1294, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1295, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1296, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1297, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1298, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1299, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1300, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1401, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1402, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1403, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1404, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1405, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1406, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1407, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1408, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1409, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1410, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1411, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1412, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1413, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1414, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1415, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1416, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1417, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1418, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1419, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1420, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1421, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1422, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1423, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1424, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1425, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1426, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1427, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1428, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1429, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1430, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1431, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1432, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1433, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1434, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1435, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1436, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1437, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1438, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1439, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1440, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1441, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1442, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1443, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1444, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1445, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1446, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1447, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1448, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1449, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1450, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1451, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1452, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1453, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1454, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1455, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1456, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1457, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1458, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1459, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1460, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1461, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1462, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1463, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1464, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1465, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1466, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1467, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1468, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1469, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1470, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1471, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1472, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1473, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1474, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1475, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1476, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1477, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1478, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1479, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1480, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1481, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1482, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1483, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1484, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1485, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1486, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1487, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1488, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1489, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1490, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1491, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1492, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1493, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1494, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1495, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1496, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1497, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1498, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1499, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1500, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1501, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1502, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1503, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1504, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1505, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1506, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1507, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1508, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1509, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1510, 0xff, 0xff, 0xff) },       
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x2002, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x2003, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0xFFEC, 0xff, 0xff, 0xff) },

    { USB_DEVICE_AND_INTERFACE_INFO(TPLink_VENDOR_ID, 0x7E11, 0xff, 0xff, 0xff) },/*TPLink*/
    { USB_DEVICE_AND_INTERFACE_INFO(QUALCOMM_VENDOR_ID, 0x9001, 0xff, 0xff, 0xff) },/*QUALCOMM_VENDOR_ID*/
    { USB_DEVICE_AND_INTERFACE_INFO(QUALCOMM_VENDOR_ID, 0x9002, 0xff, 0xff, 0xff) },

	{ } /* Terminating entry */
};
MODULE_DEVICE_TABLE(usb, zte_ids);

static struct usb_driver zte_driver = {
	.name       = "zte",
	.probe      = usb_serial_probe,
	.disconnect = usb_serial_disconnect,
#ifdef CONFIG_PM
	.suspend    = usb_serial_suspend,
	.resume     = usb_serial_resume,
#endif
	.id_table   = zte_ids,
	.no_dynamic_id = 	1,
};

/* The card has three separate interfaces, which the serial driver
 * recognizes separately, thus num_port=1.
 */

static struct usb_serial_driver zte_1port_device = {
	.driver = {
		.owner =	THIS_MODULE,
		.name =		"zte1",
	},
	.description       = "GSM modem (1-port)",
	.usb_driver        = &zte_driver,
	.id_table          = zte_ids,
	.num_ports         = 1,
	.probe             = zte_probe,
	.open              = zte_open,
	.close             = zte_close,
	.dtr_rts	   = zte_dtr_rts,
	.write             = zte_write,
	.write_room        = zte_write_room,
	.chars_in_buffer   = zte_chars_in_buffer,
	.set_termios       = zte_set_termios,
	.tiocmget          = zte_tiocmget,
	.tiocmset          = zte_tiocmset,
	.attach            = zte_startup,
	.disconnect        = zte_disconnect,
	.release           = zte_release,
	.read_int_callback = zte_instat_callback,
#ifdef CONFIG_PM
	.suspend           = zte_suspend,
	.resume            = zte_resume,
#endif
};

static int debug;

/* per port private data */

#define N_IN_URB 4
#define N_OUT_URB 4
#define IN_BUFLEN 4096
#define OUT_BUFLEN 4096

struct zte_port_private {
	/* Input endpoints and buffer for this port */
	struct urb *in_urbs[N_IN_URB];
	u8 *in_buffer[N_IN_URB];
	/* Output endpoints and buffer for this port */
	struct urb *out_urbs[N_OUT_URB];
	u8 *out_buffer[N_OUT_URB];
	unsigned long out_busy;		/* Bit vector of URBs in use */

	/* Settings for the port */
	int rts_state;	/* Handshaking pins (outputs) */
	int dtr_state;
	int cts_state;	/* Handshaking pins (inputs) */
	int dsr_state;
	int dcd_state;
	int ri_state;

	unsigned long tx_start_time[N_OUT_URB];
};

/* Functions used by new usb-serial code. */
static int __init zte_init(void)
{
	int retval;
	retval = usb_serial_register(&zte_1port_device);
	if (retval)
		goto failed_1port_device_register;
	retval = usb_register(&zte_driver);
	if (retval)
		goto failed_driver_register;

	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
	       DRIVER_DESC "\n");

	return 0;

failed_driver_register:
	usb_serial_deregister(&zte_1port_device);
failed_1port_device_register:
	return retval;
}

static void __exit zte_exit(void)
{
	usb_deregister(&zte_driver);
	usb_serial_deregister(&zte_1port_device);
}

module_init(zte_init);
module_exit(zte_exit);

static int zte_probe(struct usb_serial *serial,
			const struct usb_device_id *id)
{
	/* D-Link DWM 652 still exposes CD-Rom emulation interface in modem mode */
/*
	if (serial->dev->descriptor.idVendor == DLINK_VENDOR_ID &&
		serial->dev->descriptor.idProduct == DLINK_PRODUCT_DWM_652 &&
		serial->interface->cur_altsetting->desc.bInterfaceClass == 0x8)
		return -ENODEV;
*/
	return 0;
}

static void zte_set_termios(struct tty_struct *tty,
		struct usb_serial_port *port, struct ktermios *old_termios)
{
	dbg("%s", __func__);
	/* Doesn't support zte setting */
	tty_termios_copy_hw(tty->termios, old_termios);
	zte_send_setup(port);
}

static int zte_tiocmget(struct tty_struct *tty, struct file *file)
{
	struct usb_serial_port *port = tty->driver_data;
	unsigned int value;
	struct zte_port_private *portdata;

	portdata = usb_get_serial_port_data(port);

	value = ((portdata->rts_state) ? TIOCM_RTS : 0) |
		((portdata->dtr_state) ? TIOCM_DTR : 0) |
		((portdata->cts_state) ? TIOCM_CTS : 0) |
		((portdata->dsr_state) ? TIOCM_DSR : 0) |
		((portdata->dcd_state) ? TIOCM_CAR : 0) |
		((portdata->ri_state) ? TIOCM_RNG : 0);

	return value;
}

static int zte_tiocmset(struct tty_struct *tty, struct file *file,
			unsigned int set, unsigned int clear)
{
	struct usb_serial_port *port = tty->driver_data;
	struct zte_port_private *portdata;

	portdata = usb_get_serial_port_data(port);

	/* FIXME: what locks portdata fields ? */
	if (set & TIOCM_RTS)
		portdata->rts_state = 1;
	if (set & TIOCM_DTR)
		portdata->dtr_state = 1;

	if (clear & TIOCM_RTS)
		portdata->rts_state = 0;
	if (clear & TIOCM_DTR)
		portdata->dtr_state = 0;
	return zte_send_setup(port);
}

/* Write */
static int zte_write(struct tty_struct *tty, struct usb_serial_port *port,
			const unsigned char *buf, int count)
{
	struct zte_port_private *portdata;
	int i;
	int left, todo;
	struct urb *this_urb = NULL; /* spurious */
	int err;

	portdata = usb_get_serial_port_data(port);

	dbg("%s: write (%d chars)", __func__, count);

	i = 0;
	left = count;
	for (i = 0; left > 0 && i < N_OUT_URB; i++) {
		todo = left;
		if (todo > OUT_BUFLEN)
			todo = OUT_BUFLEN;

		this_urb = portdata->out_urbs[i];
		if (test_and_set_bit(i, &portdata->out_busy)) {
			if (time_before(jiffies,
					portdata->tx_start_time[i] + 10 * HZ))
				continue;
			usb_unlink_urb(this_urb);
			continue;
		}
		dbg("%s: endpoint %d buf %d", __func__,
			usb_pipeendpoint(this_urb->pipe), i);

		/* send the data */
		memcpy(this_urb->transfer_buffer, buf, todo);
		this_urb->transfer_buffer_length = todo;

		err = usb_submit_urb(this_urb, GFP_ATOMIC);
		if (err) {
			dbg("usb_submit_urb %p (write bulk) failed "
				"(%d)", this_urb, err);
			clear_bit(i, &portdata->out_busy);
			continue;
		}
		portdata->tx_start_time[i] = jiffies;
		buf += todo;
		left -= todo;
	}

	count -= left;
	dbg("%s: wrote (did %d)", __func__, count);
	return count;
}

static void zte_indat_callback(struct urb *urb)
{
	int err;
	int endpoint;
	struct usb_serial_port *port;
	struct tty_struct *tty;
	unsigned char *data = urb->transfer_buffer;
	int status = urb->status;

	dbg("%s: %p", __func__, urb);

	endpoint = usb_pipeendpoint(urb->pipe);
	port =  urb->context;

	if (status) {
		dbg("%s: nonzero status: %d on endpoint %02x.",
		    __func__, status, endpoint);
	} else {
		tty = tty_port_tty_get(&port->port);
		if (urb->actual_length) {
			tty_buffer_request_room(tty, urb->actual_length);
			tty_insert_flip_string(tty, data, urb->actual_length);
			tty_flip_buffer_push(tty);
		} else 
			dbg("%s: empty read urb received", __func__);
		tty_kref_put(tty);

		/* Resubmit urb so we continue receiving */
		if (port->port.count && status != -ESHUTDOWN) {
			err = usb_submit_urb(urb, GFP_ATOMIC);
			if (err)
				printk(KERN_ERR "%s: resubmit read urb failed. "
					"(%d)", __func__, err);
		}
	}
	return;
}

static void zte_outdat_callback(struct urb *urb)
{
	struct usb_serial_port *port;
	struct zte_port_private *portdata;
	int i;

	dbg("%s", __func__);

	port =  urb->context;

	usb_serial_port_softint(port);

	portdata = usb_get_serial_port_data(port);
	for (i = 0; i < N_OUT_URB; ++i) {
		if (portdata->out_urbs[i] == urb) {
			smp_mb__before_clear_bit();
			clear_bit(i, &portdata->out_busy);
			break;
		}
	}
}

static void zte_instat_callback(struct urb *urb)
{
	int err;
	int status = urb->status;
	struct usb_serial_port *port =  urb->context;
	struct zte_port_private *portdata = usb_get_serial_port_data(port);

	dbg("%s", __func__);
	dbg("%s: urb %p port %p has data %p", __func__, urb, port, portdata);

	if (status == 0) {
		struct usb_ctrlrequest *req_pkt =
				(struct usb_ctrlrequest *)urb->transfer_buffer;

		if (!req_pkt) {
			dbg("%s: NULL req_pkt\n", __func__);
			return;
		}
		if ((req_pkt->bRequestType == 0xA1) &&
				(req_pkt->bRequest == 0x20)) {
			int old_dcd_state;
			unsigned char signals = *((unsigned char *)
					urb->transfer_buffer +
					sizeof(struct usb_ctrlrequest));

			dbg("%s: signal x%x", __func__, signals);

			old_dcd_state = portdata->dcd_state;
			portdata->cts_state = 1;
			portdata->dcd_state = ((signals & 0x01) ? 1 : 0);
			portdata->dsr_state = ((signals & 0x02) ? 1 : 0);
			portdata->ri_state = ((signals & 0x08) ? 1 : 0);

			if (old_dcd_state && !portdata->dcd_state) {
				struct tty_struct *tty =
						tty_port_tty_get(&port->port);
				if (tty && !C_CLOCAL(tty))
					tty_hangup(tty);
				tty_kref_put(tty);
			}
		} else {
			dbg("%s: type %x req %x", __func__,
				req_pkt->bRequestType, req_pkt->bRequest);
		}
	} else
		err("%s: error %d", __func__, status);

	/* Resubmit urb so we continue receiving IRQ data */
	if (status != -ESHUTDOWN && status != -ENOENT) {
		err = usb_submit_urb(urb, GFP_ATOMIC);
		if (err)
			dbg("%s: resubmit intr urb failed. (%d)",
				__func__, err);
	}
}

static int zte_write_room(struct tty_struct *tty)
{
	struct usb_serial_port *port = tty->driver_data;
	struct zte_port_private *portdata;
	int i;
	int data_len = 0;
	struct urb *this_urb;

	portdata = usb_get_serial_port_data(port);

	for (i = 0; i < N_OUT_URB; i++) {
		this_urb = portdata->out_urbs[i];
		if (this_urb && !test_bit(i, &portdata->out_busy))
			data_len += OUT_BUFLEN;
	}

	dbg("%s: %d", __func__, data_len);
	return data_len;
}

static int zte_chars_in_buffer(struct tty_struct *tty)
{
	struct usb_serial_port *port = tty->driver_data;
	struct zte_port_private *portdata;
	int i;
	int data_len = 0;
	struct urb *this_urb;

	portdata = usb_get_serial_port_data(port);

	for (i = 0; i < N_OUT_URB; i++) {
		this_urb = portdata->out_urbs[i];
		/* FIXME: This locking is insufficient as this_urb may
		   go unused during the test */
		if (this_urb && test_bit(i, &portdata->out_busy))
			data_len += this_urb->transfer_buffer_length;
	}
	dbg("%s: %d", __func__, data_len);
	return data_len;
}

static int zte_open(struct tty_struct *tty,
			struct usb_serial_port *port, struct file *filp)
{
	struct zte_port_private *portdata;
	int i, err;
	struct urb *urb;

	portdata = usb_get_serial_port_data(port);

	dbg("%s", __func__);

	/* Start reading from the IN endpoint */
	for (i = 0; i < N_IN_URB; i++) {
		urb = portdata->in_urbs[i];
		if (!urb)
			continue;
		err = usb_submit_urb(urb, GFP_KERNEL);
		if (err) {
			dbg("%s: submit urb %d failed (%d) %d",
				__func__, i, err,
				urb->transfer_buffer_length);
		}
	}

	zte_send_setup(port);

	return 0;
}

static void zte_dtr_rts(struct usb_serial_port *port, int on)
{
	struct usb_serial *serial = port->serial;
	struct zte_port_private *portdata;

	dbg("%s", __func__);
	portdata = usb_get_serial_port_data(port);
	mutex_lock(&serial->disc_mutex);
	portdata->rts_state = on;
	portdata->dtr_state = on;
	if (serial->dev)
		zte_send_setup(port);
	mutex_unlock(&serial->disc_mutex);
}


static void zte_close(struct usb_serial_port *port)
{
	int i;
	struct usb_serial *serial = port->serial;
	struct zte_port_private *portdata;

	dbg("%s", __func__);
	portdata = usb_get_serial_port_data(port);

	if (serial->dev) {
		/* Stop reading/writing urbs */
		for (i = 0; i < N_IN_URB; i++)
			usb_kill_urb(portdata->in_urbs[i]);
		for (i = 0; i < N_OUT_URB; i++)
			usb_kill_urb(portdata->out_urbs[i]);
	}
}

/* Helper functions used by zte_setup_urbs */
static struct urb *zte_setup_urb(struct usb_serial *serial, int endpoint,
		int dir, void *ctx, char *buf, int len,
		void (*callback)(struct urb *))
{
	struct urb *urb;

	if (endpoint == -1)
		return NULL;		/* endpoint not needed */

	urb = usb_alloc_urb(0, GFP_KERNEL);		/* No ISO */
	if (urb == NULL) {
		dbg("%s: alloc for endpoint %d failed.", __func__, endpoint);
		return NULL;
	}

		/* Fill URB using supplied data. */
	usb_fill_bulk_urb(urb, serial->dev,
		      usb_sndbulkpipe(serial->dev, endpoint) | dir,
		      buf, len, callback, ctx);

	return urb;
}

/* Setup urbs */
static void zte_setup_urbs(struct usb_serial *serial)
{
	int i, j;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;

	dbg("%s", __func__);

	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);

		/* Do indat endpoints first */
		for (j = 0; j < N_IN_URB; ++j) {
			portdata->in_urbs[j] = zte_setup_urb(serial,
					port->bulk_in_endpointAddress,
					USB_DIR_IN, port,
					portdata->in_buffer[j],
					IN_BUFLEN, zte_indat_callback);
		}

		/* outdat endpoints */
		for (j = 0; j < N_OUT_URB; ++j) {
			portdata->out_urbs[j] = zte_setup_urb(serial,
					port->bulk_out_endpointAddress,
					USB_DIR_OUT, port,
					portdata->out_buffer[j],
					OUT_BUFLEN, zte_outdat_callback);
		}
	}
}


/** send RTS/DTR state to the port.
 *
 * This is exactly the same as SET_CONTROL_LINE_STATE from the PSTN
 * CDC.
*/
static int zte_send_setup(struct usb_serial_port *port)
{
	struct usb_serial *serial = port->serial;
	struct zte_port_private *portdata;
	int ifNum = serial->interface->cur_altsetting->desc.bInterfaceNumber;
	int val = 0;
	dbg("%s", __func__);

	portdata = usb_get_serial_port_data(port);

	if (portdata->dtr_state)
		val |= 0x01;
	if (portdata->rts_state)
		val |= 0x02;

	return usb_control_msg(serial->dev,
		usb_rcvctrlpipe(serial->dev, 0),
		0x22, 0x21, val, ifNum, NULL, 0, USB_CTRL_SET_TIMEOUT);
}

static int zte_startup(struct usb_serial *serial)
{
	int i, j, err;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;
	u8 *buffer;

	dbg("%s", __func__);

	/* Now setup per port private data */
	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		portdata = kzalloc(sizeof(*portdata), GFP_KERNEL);
		if (!portdata) {
			dbg("%s: kmalloc for zte_port_private (%d) failed!.",
					__func__, i);
			return 1;
		}

		for (j = 0; j < N_IN_URB; j++) {
			buffer = (u8 *)__get_free_page(GFP_KERNEL);
			if (!buffer)
				goto bail_out_error;
			portdata->in_buffer[j] = buffer;
		}

		for (j = 0; j < N_OUT_URB; j++) {
			buffer = kmalloc(OUT_BUFLEN, GFP_KERNEL);
			if (!buffer)
				goto bail_out_error2;
			portdata->out_buffer[j] = buffer;
		}

		usb_set_serial_port_data(port, portdata);

		if (!port->interrupt_in_urb)
			continue;
		err = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);
		if (err)
			dbg("%s: submit irq_in urb failed %d",
				__func__, err);
	}
	zte_setup_urbs(serial);
	return 0;

bail_out_error2:
	for (j = 0; j < N_OUT_URB; j++)
		kfree(portdata->out_buffer[j]);
bail_out_error:
	for (j = 0; j < N_IN_URB; j++)
		if (portdata->in_buffer[j])
			free_page((unsigned long)portdata->in_buffer[j]);
	kfree(portdata);
	return 1;
}

static void stop_read_write_urbs(struct usb_serial *serial)
{
	int i, j;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;

	/* Stop reading/writing urbs */
	for (i = 0; i < serial->num_ports; ++i) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);
		for (j = 0; j < N_IN_URB; j++)
			usb_kill_urb(portdata->in_urbs[j]);
		for (j = 0; j < N_OUT_URB; j++)
			usb_kill_urb(portdata->out_urbs[j]);
	}
}

static void zte_disconnect(struct usb_serial *serial)
{
	dbg("%s", __func__);

	stop_read_write_urbs(serial);
}

static void zte_release(struct usb_serial *serial)
{
	int i, j;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;

	dbg("%s", __func__);

	/* Now free them */
	for (i = 0; i < serial->num_ports; ++i) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);

		for (j = 0; j < N_IN_URB; j++) {
			if (portdata->in_urbs[j]) {
				usb_free_urb(portdata->in_urbs[j]);
				free_page((unsigned long)
					portdata->in_buffer[j]);
				portdata->in_urbs[j] = NULL;
			}
		}
		for (j = 0; j < N_OUT_URB; j++) {
			if (portdata->out_urbs[j]) {
				usb_free_urb(portdata->out_urbs[j]);
				kfree(portdata->out_buffer[j]);
				portdata->out_urbs[j] = NULL;
			}
		}
	}

	/* Now free per port private data */
	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		kfree(usb_get_serial_port_data(port));
	}
}

#ifdef CONFIG_PM
static int zte_suspend(struct usb_serial *serial, pm_message_t message)
{
	dbg("%s entered", __func__);
	stop_read_write_urbs(serial);

	return 0;
}

static int zte_resume(struct usb_serial *serial)
{
	int err, i, j;
	struct usb_serial_port *port;
	struct urb *urb;
	struct zte_port_private *portdata;

	dbg("%s entered", __func__);
	/* get the interrupt URBs resubmitted unconditionally */
	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		if (!port->interrupt_in_urb) {
			dbg("%s: No interrupt URB for port %d\n", __func__, i);
			continue;
		}
		err = usb_submit_urb(port->interrupt_in_urb, GFP_NOIO);
		dbg("Submitted interrupt URB for port %d (result %d)", i, err);
		if (err < 0) {
			err("%s: Error %d for interrupt URB of port%d",
				 __func__, err, i);
			return err;
		}
	}

	for (i = 0; i < serial->num_ports; i++) {
		/* walk all ports */
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);
		mutex_lock(&port->mutex);

		/* skip closed ports */
		if (!port->port.count) {
			mutex_unlock(&port->mutex);
			continue;
		}

		for (j = 0; j < N_IN_URB; j++) {
			urb = portdata->in_urbs[j];
			err = usb_submit_urb(urb, GFP_NOIO);
			if (err < 0) {
				mutex_unlock(&port->mutex);
				err("%s: Error %d for bulk URB %d",
					 __func__, err, i);
				return err;
			}
		}
		mutex_unlock(&port->mutex);
	}
	return 0;
}
#endif

MODULE_AUTHOR(DRIVER_AUTHOR);
MODULE_DESCRIPTION(DRIVER_DESC);
MODULE_VERSION(DRIVER_VERSION);
MODULE_LICENSE("GPL");

module_param(debug, bool, S_IRUGO | S_IWUSR);
MODULE_PARM_DESC(debug, "Debug messages");

#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)//use 2.6.32 sourcecode
#include <linux/kernel.h>
#include <linux/jiffies.h>
#include <linux/errno.h>
#include <linux/tty.h>
#include <linux/tty_flip.h>
#include <linux/module.h>
#include <linux/bitops.h>
#include <linux/usb.h>
#include <linux/usb/serial.h>

/* Function prototypes */
static int  zte_probe(struct usb_serial *serial,
			const struct usb_device_id *id);
static int  zte_open(struct tty_struct *tty, struct usb_serial_port *port);
static void zte_close(struct usb_serial_port *port);
static void zte_dtr_rts(struct usb_serial_port *port, int on);

static int  zte_startup(struct usb_serial *serial);
static void zte_disconnect(struct usb_serial *serial);
static void zte_release(struct usb_serial *serial);
static int  zte_write_room(struct tty_struct *tty);

static void zte_instat_callback(struct urb *urb);

static int zte_write(struct tty_struct *tty, struct usb_serial_port *port,
			const unsigned char *buf, int count);
static int  zte_chars_in_buffer(struct tty_struct *tty);
static void zte_set_termios(struct tty_struct *tty,
			struct usb_serial_port *port, struct ktermios *old);
static int  zte_tiocmget(struct tty_struct *tty, struct file *file);
static int  zte_tiocmset(struct tty_struct *tty, struct file *file,
				unsigned int set, unsigned int clear);
static int  zte_send_setup(struct usb_serial_port *port);
#ifdef CONFIG_PM
static int  zte_suspend(struct usb_serial *serial, pm_message_t message);
static int  zte_resume(struct usb_serial *serial);
#endif

/* Vendor and product IDs */

/* zte PRODUCTS */
#define zte_VENDOR_ID				0x19d2

static struct usb_device_id zte_ids[] = {
	   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0001, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0002, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0003, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0004, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0005, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0006, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0007, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0008, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0009, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0010, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0011, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0012, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0013, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0014, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0015, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0016, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0017, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0018, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0019, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0020, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0021, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0022, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0023, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0024, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0025, 0xff, 0xff, 0xff) },
    //   { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0026, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0027, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0028, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0029, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0030, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0031, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0032, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0033, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0034, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0035, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0036, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0037, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0038, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0039, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0040, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0041, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0042, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0043, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0044, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0045, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0046, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0047, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0048, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0049, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0050, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0051, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0052, 0xff, 0xff, 0xff) },
    //   { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0053, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0054, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0055, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0056, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0057, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0058, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0059, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0060, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0061, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0062, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0063, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0064, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0065, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0066, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0067, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0068, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0069, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0070, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0071, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0072, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0073, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0074, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0075, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0076, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0077, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0078, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0079, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0080, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0081, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0082, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0083, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0084, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0085, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0086, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0087, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0088, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0089, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0090, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0091, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0092, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0093, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0094, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0095, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0096, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0097, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0098, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0099, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0104, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0105, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0106, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0108, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0117, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0118, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0121, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0122, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0123, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0124, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0125, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0126, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0128, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0130, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0133, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0141, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0144, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0145, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0147, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0148, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0151, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0152, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0153, 0xff, 0xff, 0xff) },
    //{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0154, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0155, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0156, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0157, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0158, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0159, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0160, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0161, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0162, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0164, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0165, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0168, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0170, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0176, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0178, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1008, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1010, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1012, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1057, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1058, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1059, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1060, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1061, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1062, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1063, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1064, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1065, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1066, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1067, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1068, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1069, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1070, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1071, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1072, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1073, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1074, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1075, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1076, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1077, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1078, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1079, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1080, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1081, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1082, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1083, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1084, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1085, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1086, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1087, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1088, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1089, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1090, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1091, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1092, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1093, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1094, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1095, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1096, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1097, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1098, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1099, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1100, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1101, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1102, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1103, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1104, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1105, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1106, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1107, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1108, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1109, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1110, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1111, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1112, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1113, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1114, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1115, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1116, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1117, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1118, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1119, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1120, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1121, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1122, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1123, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1124, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1125, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1126, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1127, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1128, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1129, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1130, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1131, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1132, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1133, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1134, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1135, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1136, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1137, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1138, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1139, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1140, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1141, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1142, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1143, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1144, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1145, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1146, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1147, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1148, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1149, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1150, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1151, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1152, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1153, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1154, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1155, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1156, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1157, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1158, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1159, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1160, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1161, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1162, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1163, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1164, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1165, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1166, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1167, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1168, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1169, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1170, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1244, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1245, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1246, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1247, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1248, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1249, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1250, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1251, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1252, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1253, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1254, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1255, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1256, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1257, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1258, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1259, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1260, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1261, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1262, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1263, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1264, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1265, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1266, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1267, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1268, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1269, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1270, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1271, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1272, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1273, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1274, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1275, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1276, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1277, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1278, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1279, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1280, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1281, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1282, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1283, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1284, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1285, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1286, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1287, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1288, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1289, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1290, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1291, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1292, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1293, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1294, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1295, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1296, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1297, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1298, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1299, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1300, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1401, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1402, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1403, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1404, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1405, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1406, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1407, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1408, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1409, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1410, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1411, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1412, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1413, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1414, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1415, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1416, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1417, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1418, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1419, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1420, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1421, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1422, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1423, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1424, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1425, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1426, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1427, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1428, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1429, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1430, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1431, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1432, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1433, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1434, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1435, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1436, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1437, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1438, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1439, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1440, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1441, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1442, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1443, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1444, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1445, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1446, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1447, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1448, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1449, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1450, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1451, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1452, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1453, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1454, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1455, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1456, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1457, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1458, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1459, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1460, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1461, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1462, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1463, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1464, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1465, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1466, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1467, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1468, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1469, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1470, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1471, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1472, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1473, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1474, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1475, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1476, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1477, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1478, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1479, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1480, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1481, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1482, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1483, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1484, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1485, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1486, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1487, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1488, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1489, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1490, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1491, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1492, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1493, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1494, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1495, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1496, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1497, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1498, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1499, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1500, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1501, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1502, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1503, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1504, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1505, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1506, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1507, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1508, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1509, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1510, 0xff, 0xff, 0xff) },       
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x2002, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x2003, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0xFFEC, 0xff, 0xff, 0xff) },

    { USB_DEVICE_AND_INTERFACE_INFO(TPLink_VENDOR_ID, 0x7E11, 0xff, 0xff, 0xff) },/*TPLink*/
    { USB_DEVICE_AND_INTERFACE_INFO(QUALCOMM_VENDOR_ID, 0x9001, 0xff, 0xff, 0xff) },/*QUALCOMM_VENDOR_ID*/
    { USB_DEVICE_AND_INTERFACE_INFO(QUALCOMM_VENDOR_ID, 0x9002, 0xff, 0xff, 0xff) },

	{ } /* Terminating entry */
};
MODULE_DEVICE_TABLE(usb, zte_ids);

static struct usb_driver zte_driver = {
	.name       = "zte",
	.probe      = usb_serial_probe,
	.disconnect = usb_serial_disconnect,
#ifdef CONFIG_PM
	.suspend    = usb_serial_suspend,
	.resume     = usb_serial_resume,
	.supports_autosuspend =	1,
#endif
	.id_table   = zte_ids,
	.no_dynamic_id = 	1,
};

/* The card has three separate interfaces, which the serial driver
 * recognizes separately, thus num_port=1.
 */

static struct usb_serial_driver zte_1port_device = {
	.driver = {
		.owner =	THIS_MODULE,
		.name =		"zte1",
	},
	.description       = "GSM modem (1-port)",
	.usb_driver        = &zte_driver,
	.id_table          = zte_ids,
	.num_ports         = 1,
	.probe             = zte_probe,
	.open              = zte_open,
	.close             = zte_close,
	.dtr_rts	   = zte_dtr_rts,
	.write             = zte_write,
	.write_room        = zte_write_room,
	.chars_in_buffer   = zte_chars_in_buffer,
	.set_termios       = zte_set_termios,
	.tiocmget          = zte_tiocmget,
	.tiocmset          = zte_tiocmset,
	.attach            = zte_startup,
	.disconnect        = zte_disconnect,
	.release           = zte_release,
	.read_int_callback = zte_instat_callback,
#ifdef CONFIG_PM
	.suspend           = zte_suspend,
	.resume            = zte_resume,
#endif
};

static int debug;

/* per port private data */

#define N_IN_URB 4
#define N_OUT_URB 4
#define IN_BUFLEN 4096
#define OUT_BUFLEN 4096

struct zte_intf_private {
	spinlock_t susp_lock;
	unsigned int suspended:1;
	int in_flight;
};

struct zte_port_private {
	/* Input endpoints and buffer for this port */
	struct urb *in_urbs[N_IN_URB];
	u8 *in_buffer[N_IN_URB];
	/* Output endpoints and buffer for this port */
	struct urb *out_urbs[N_OUT_URB];
	u8 *out_buffer[N_OUT_URB];
	unsigned long out_busy;		/* Bit vector of URBs in use */
	int opened;
	struct usb_anchor delayed;

	/* Settings for the port */
	int rts_state;	/* Handshaking pins (outputs) */
	int dtr_state;
	int cts_state;	/* Handshaking pins (inputs) */
	int dsr_state;
	int dcd_state;

	int ri_state;

	unsigned long tx_start_time[N_OUT_URB];
};

/* Functions used by new usb-serial code. */
static int __init zte_init(void)
{
	int retval;
	retval = usb_serial_register(&zte_1port_device);
	if (retval)
		goto failed_1port_device_register;
	retval = usb_register(&zte_driver);
	if (retval)
		goto failed_driver_register;

	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
	       DRIVER_DESC "\n");

	return 0;

failed_driver_register:
	usb_serial_deregister(&zte_1port_device);
failed_1port_device_register:
	return retval;
}

static void __exit zte_exit(void)
{
	usb_deregister(&zte_driver);
	usb_serial_deregister(&zte_1port_device);
}

module_init(zte_init);
module_exit(zte_exit);

static int zte_probe(struct usb_serial *serial,
			const struct usb_device_id *id)
{
	struct zte_intf_private *data;
	/* D-Link DWM 652 still exposes CD-Rom emulation interface in modem mode */
/*
	if (serial->dev->descriptor.idVendor == DLINK_VENDOR_ID &&
		serial->dev->descriptor.idProduct == DLINK_PRODUCT_DWM_652 &&
		serial->interface->cur_altsetting->desc.bInterfaceClass == 0x8)
		return -ENODEV;
*/

	data = serial->private = kzalloc(sizeof(struct zte_intf_private), GFP_KERNEL);
	if (!data)
		return -ENOMEM;
	spin_lock_init(&data->susp_lock);
	return 0;
}

static void zte_set_termios(struct tty_struct *tty,
		struct usb_serial_port *port, struct ktermios *old_termios)
{
	dbg("%s", __func__);
	/* Doesn't support zte setting */
	tty_termios_copy_hw(tty->termios, old_termios);
	zte_send_setup(port);
}

static int zte_tiocmget(struct tty_struct *tty, struct file *file)
{
	struct usb_serial_port *port = tty->driver_data;
	unsigned int value;
	struct zte_port_private *portdata;

	portdata = usb_get_serial_port_data(port);

	value = ((portdata->rts_state) ? TIOCM_RTS : 0) |
		((portdata->dtr_state) ? TIOCM_DTR : 0) |
		((portdata->cts_state) ? TIOCM_CTS : 0) |
		((portdata->dsr_state) ? TIOCM_DSR : 0) |
		((portdata->dcd_state) ? TIOCM_CAR : 0) |
		((portdata->ri_state) ? TIOCM_RNG : 0);

	return value;
}

static int zte_tiocmset(struct tty_struct *tty, struct file *file,
			unsigned int set, unsigned int clear)
{
	struct usb_serial_port *port = tty->driver_data;
	struct zte_port_private *portdata;

	portdata = usb_get_serial_port_data(port);

	/* FIXME: what locks portdata fields ? */
	if (set & TIOCM_RTS)
		portdata->rts_state = 1;
	if (set & TIOCM_DTR)
		portdata->dtr_state = 1;

	if (clear & TIOCM_RTS)
		portdata->rts_state = 0;
	if (clear & TIOCM_DTR)
		portdata->dtr_state = 0;
	return zte_send_setup(port);
}

/* Write */
static int zte_write(struct tty_struct *tty, struct usb_serial_port *port,
			const unsigned char *buf, int count)
{
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata;
	int i;
	int left, todo;
	struct urb *this_urb = NULL; /* spurious */
	int err;
	unsigned long flags;

	portdata = usb_get_serial_port_data(port);
	intfdata = port->serial->private;

	dbg("%s: write (%d chars)", __func__, count);

	i = 0;
	left = count;
	for (i = 0; left > 0 && i < N_OUT_URB; i++) {
		todo = left;
		if (todo > OUT_BUFLEN)
			todo = OUT_BUFLEN;

		this_urb = portdata->out_urbs[i];
		if (test_and_set_bit(i, &portdata->out_busy)) {
			if (time_before(jiffies,
					portdata->tx_start_time[i] + 10 * HZ))
				continue;
			usb_unlink_urb(this_urb);
			continue;
		}
		dbg("%s: endpoint %d buf %d", __func__,
			usb_pipeendpoint(this_urb->pipe), i);

		err = usb_autopm_get_interface_async(port->serial->interface);
		if (err < 0)
			break;

		/* send the data */
		memcpy(this_urb->transfer_buffer, buf, todo);
		this_urb->transfer_buffer_length = todo;

		spin_lock_irqsave(&intfdata->susp_lock, flags);
		if (intfdata->suspended) {
			usb_anchor_urb(this_urb, &portdata->delayed);
			spin_unlock_irqrestore(&intfdata->susp_lock, flags);
		} else {
			intfdata->in_flight++;
			spin_unlock_irqrestore(&intfdata->susp_lock, flags);
			err = usb_submit_urb(this_urb, GFP_ATOMIC);
			if (err) {
				dbg("usb_submit_urb %p (write bulk) failed "
					"(%d)", this_urb, err);
				clear_bit(i, &portdata->out_busy);
				spin_lock_irqsave(&intfdata->susp_lock, flags);
				intfdata->in_flight--;
				spin_unlock_irqrestore(&intfdata->susp_lock, flags);
				continue;
			}
		}

		portdata->tx_start_time[i] = jiffies;
		buf += todo;
		left -= todo;
	}

	count -= left;
	dbg("%s: wrote (did %d)", __func__, count);
	return count;
}

static void zte_indat_callback(struct urb *urb)
{
	int err;
	int endpoint;
	struct usb_serial_port *port;
	struct tty_struct *tty;
	unsigned char *data = urb->transfer_buffer;
	int status = urb->status;

	dbg("%s: %p", __func__, urb);

	endpoint = usb_pipeendpoint(urb->pipe);
	port =  urb->context;

	if (status) {
		dbg("%s: nonzero status: %d on endpoint %02x.",
		    __func__, status, endpoint);
	} else {
		tty = tty_port_tty_get(&port->port);
		if (urb->actual_length) {
			tty_buffer_request_room(tty, urb->actual_length);
			tty_insert_flip_string(tty, data, urb->actual_length);
			tty_flip_buffer_push(tty);
		} else 
			dbg("%s: empty read urb received", __func__);
		tty_kref_put(tty);

		/* Resubmit urb so we continue receiving */
		if (port->port.count && status != -ESHUTDOWN) {
			err = usb_submit_urb(urb, GFP_ATOMIC);
			if (err)
				printk(KERN_ERR "%s: resubmit read urb failed. "
					"(%d)", __func__, err);
			else
				usb_mark_last_busy(port->serial->dev);
		}

	}
	return;
}

static void zte_outdat_callback(struct urb *urb)
{
	struct usb_serial_port *port;
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata;
	int i;

	dbg("%s", __func__);

	port =  urb->context;
	intfdata = port->serial->private;

	usb_serial_port_softint(port);
	usb_autopm_put_interface_async(port->serial->interface);
	portdata = usb_get_serial_port_data(port);
	spin_lock(&intfdata->susp_lock);
	intfdata->in_flight--;
	spin_unlock(&intfdata->susp_lock);

	for (i = 0; i < N_OUT_URB; ++i) {
		if (portdata->out_urbs[i] == urb) {
			smp_mb__before_clear_bit();
			clear_bit(i, &portdata->out_busy);
			break;
		}
	}
}

static void zte_instat_callback(struct urb *urb)
{
	int err;
	int status = urb->status;
	struct usb_serial_port *port =  urb->context;
	struct zte_port_private *portdata = usb_get_serial_port_data(port);

	dbg("%s", __func__);
	dbg("%s: urb %p port %p has data %p", __func__, urb, port, portdata);

	if (status == 0) {
		struct usb_ctrlrequest *req_pkt =
				(struct usb_ctrlrequest *)urb->transfer_buffer;

		if (!req_pkt) {
			dbg("%s: NULL req_pkt\n", __func__);
			return;
		}
		if ((req_pkt->bRequestType == 0xA1) &&
				(req_pkt->bRequest == 0x20)) {
			int old_dcd_state;
			unsigned char signals = *((unsigned char *)
					urb->transfer_buffer +
					sizeof(struct usb_ctrlrequest));

			dbg("%s: signal x%x", __func__, signals);

			old_dcd_state = portdata->dcd_state;
			portdata->cts_state = 1;
			portdata->dcd_state = ((signals & 0x01) ? 1 : 0);
			portdata->dsr_state = ((signals & 0x02) ? 1 : 0);
			portdata->ri_state = ((signals & 0x08) ? 1 : 0);

			if (old_dcd_state && !portdata->dcd_state) {
				struct tty_struct *tty =
						tty_port_tty_get(&port->port);
				if (tty && !C_CLOCAL(tty))
					tty_hangup(tty);
				tty_kref_put(tty);
			}
		} else {
			dbg("%s: type %x req %x", __func__,
				req_pkt->bRequestType, req_pkt->bRequest);
		}
	} else
		err("%s: error %d", __func__, status);

	/* Resubmit urb so we continue receiving IRQ data */
	if (status != -ESHUTDOWN && status != -ENOENT) {
		err = usb_submit_urb(urb, GFP_ATOMIC);
		if (err)
			dbg("%s: resubmit intr urb failed. (%d)",
				__func__, err);
	}
}

static int zte_write_room(struct tty_struct *tty)
{
	struct usb_serial_port *port = tty->driver_data;
	struct zte_port_private *portdata;
	int i;
	int data_len = 0;
	struct urb *this_urb;

	portdata = usb_get_serial_port_data(port);

	for (i = 0; i < N_OUT_URB; i++) {
		this_urb = portdata->out_urbs[i];
		if (this_urb && !test_bit(i, &portdata->out_busy))
			data_len += OUT_BUFLEN;
	}

	dbg("%s: %d", __func__, data_len);
	return data_len;
}

static int zte_chars_in_buffer(struct tty_struct *tty)
{
	struct usb_serial_port *port = tty->driver_data;
	struct zte_port_private *portdata;
	int i;
	int data_len = 0;
	struct urb *this_urb;

	portdata = usb_get_serial_port_data(port);

	for (i = 0; i < N_OUT_URB; i++) {
		this_urb = portdata->out_urbs[i];
		/* FIXME: This locking is insufficient as this_urb may
		   go unused during the test */
		if (this_urb && test_bit(i, &portdata->out_busy))
			data_len += this_urb->transfer_buffer_length;
	}
	dbg("%s: %d", __func__, data_len);
	return data_len;
}

static int zte_open(struct tty_struct *tty, struct usb_serial_port *port)
{
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata;
	struct usb_serial *serial = port->serial;
	int i, err;
	struct urb *urb;

	portdata = usb_get_serial_port_data(port);
	intfdata = serial->private;

	dbg("%s", __func__);

	/* Start reading from the IN endpoint */
	for (i = 0; i < N_IN_URB; i++) {
		urb = portdata->in_urbs[i];
		if (!urb)
			continue;
		err = usb_submit_urb(urb, GFP_KERNEL);
		if (err) {
			dbg("%s: submit urb %d failed (%d) %d",
				__func__, i, err,
				urb->transfer_buffer_length);
		}
	}

	zte_send_setup(port);

	serial->interface->needs_remote_wakeup = 1;
	spin_lock_irq(&intfdata->susp_lock);
	portdata->opened = 1;
	spin_unlock_irq(&intfdata->susp_lock);
	usb_autopm_put_interface(serial->interface);

	return 0;
}

static void zte_dtr_rts(struct usb_serial_port *port, int on)
{
	struct usb_serial *serial = port->serial;
	struct zte_port_private *portdata;

	dbg("%s", __func__);
	portdata = usb_get_serial_port_data(port);
	mutex_lock(&serial->disc_mutex);
	portdata->rts_state = on;
	portdata->dtr_state = on;
	if (serial->dev)
		zte_send_setup(port);
	mutex_unlock(&serial->disc_mutex);
}


static void zte_close(struct usb_serial_port *port)
{
	int i;
	struct usb_serial *serial = port->serial;
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata = port->serial->private;

	dbg("%s", __func__);
	portdata = usb_get_serial_port_data(port);

	if (serial->dev) {
		/* Stop reading/writing urbs */
		spin_lock_irq(&intfdata->susp_lock);
		portdata->opened = 0;
		spin_unlock_irq(&intfdata->susp_lock);

		for (i = 0; i < N_IN_URB; i++)
			usb_kill_urb(portdata->in_urbs[i]);
		for (i = 0; i < N_OUT_URB; i++)
			usb_kill_urb(portdata->out_urbs[i]);
		usb_autopm_get_interface(serial->interface);
		serial->interface->needs_remote_wakeup = 0;
	}
}

/* Helper functions used by zte_setup_urbs */
static struct urb *zte_setup_urb(struct usb_serial *serial, int endpoint,
		int dir, void *ctx, char *buf, int len,
		void (*callback)(struct urb *))
{
	struct urb *urb;

	if (endpoint == -1)
		return NULL;		/* endpoint not needed */

	urb = usb_alloc_urb(0, GFP_KERNEL);		/* No ISO */
	if (urb == NULL) {
		dbg("%s: alloc for endpoint %d failed.", __func__, endpoint);
		return NULL;
	}

		/* Fill URB using supplied data. */
	usb_fill_bulk_urb(urb, serial->dev,
		      usb_sndbulkpipe(serial->dev, endpoint) | dir,
		      buf, len, callback, ctx);

	return urb;
}

/* Setup urbs */
static void zte_setup_urbs(struct usb_serial *serial)
{
	int i, j;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;

	dbg("%s", __func__);

	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);

		/* Do indat endpoints first */
		for (j = 0; j < N_IN_URB; ++j) {
			portdata->in_urbs[j] = zte_setup_urb(serial,
					port->bulk_in_endpointAddress,
					USB_DIR_IN, port,
					portdata->in_buffer[j],
					IN_BUFLEN, zte_indat_callback);
		}

		/* outdat endpoints */
		for (j = 0; j < N_OUT_URB; ++j) {
			portdata->out_urbs[j] = zte_setup_urb(serial,
					port->bulk_out_endpointAddress,
					USB_DIR_OUT, port,
					portdata->out_buffer[j],
					OUT_BUFLEN, zte_outdat_callback);
		}
	}
}


/** send RTS/DTR state to the port.
 *
 * This is exactly the same as SET_CONTROL_LINE_STATE from the PSTN
 * CDC.
*/
static int zte_send_setup(struct usb_serial_port *port)
{
	struct usb_serial *serial = port->serial;
	struct zte_port_private *portdata;
	int ifNum = serial->interface->cur_altsetting->desc.bInterfaceNumber;
	int val = 0;
	dbg("%s", __func__);

	portdata = usb_get_serial_port_data(port);

	if (portdata->dtr_state)
		val |= 0x01;
	if (portdata->rts_state)
		val |= 0x02;

	return usb_control_msg(serial->dev,
		usb_rcvctrlpipe(serial->dev, 0),
		0x22, 0x21, val, ifNum, NULL, 0, USB_CTRL_SET_TIMEOUT);
}

static int zte_startup(struct usb_serial *serial)
{
	int i, j, err;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;
	u8 *buffer;

	dbg("%s", __func__);

	/* Now setup per port private data */
	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		portdata = kzalloc(sizeof(*portdata), GFP_KERNEL);
		if (!portdata) {
			dbg("%s: kmalloc for zte_port_private (%d) failed!.",
					__func__, i);
			return 1;
		}
		init_usb_anchor(&portdata->delayed);

		for (j = 0; j < N_IN_URB; j++) {
			buffer = (u8 *)__get_free_page(GFP_KERNEL);
			if (!buffer)
				goto bail_out_error;
			portdata->in_buffer[j] = buffer;
		}

		for (j = 0; j < N_OUT_URB; j++) {
			buffer = kmalloc(OUT_BUFLEN, GFP_KERNEL);
			if (!buffer)
				goto bail_out_error2;
			portdata->out_buffer[j] = buffer;
		}

		usb_set_serial_port_data(port, portdata);

		if (!port->interrupt_in_urb)
			continue;
		err = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);
		if (err)
			dbg("%s: submit irq_in urb failed %d",
				__func__, err);
	}
	zte_setup_urbs(serial);
	return 0;

bail_out_error2:
	for (j = 0; j < N_OUT_URB; j++)
		kfree(portdata->out_buffer[j]);
bail_out_error:
	for (j = 0; j < N_IN_URB; j++)
		if (portdata->in_buffer[j])
			free_page((unsigned long)portdata->in_buffer[j]);
	kfree(portdata);
	return 1;
}

static void stop_read_write_urbs(struct usb_serial *serial)
{
	int i, j;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;

	/* Stop reading/writing urbs */
	for (i = 0; i < serial->num_ports; ++i) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);
		for (j = 0; j < N_IN_URB; j++)
			usb_kill_urb(portdata->in_urbs[j]);
		for (j = 0; j < N_OUT_URB; j++)
			usb_kill_urb(portdata->out_urbs[j]);
	}
}

static void zte_disconnect(struct usb_serial *serial)
{
	dbg("%s", __func__);

	stop_read_write_urbs(serial);
}

static void zte_release(struct usb_serial *serial)
{
	int i, j;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;

	dbg("%s", __func__);

	/* Now free them */
	for (i = 0; i < serial->num_ports; ++i) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);

		for (j = 0; j < N_IN_URB; j++) {
			if (portdata->in_urbs[j]) {
				usb_free_urb(portdata->in_urbs[j]);
				free_page((unsigned long)
					portdata->in_buffer[j]);
				portdata->in_urbs[j] = NULL;
			}
		}
		for (j = 0; j < N_OUT_URB; j++) {
			if (portdata->out_urbs[j]) {
				usb_free_urb(portdata->out_urbs[j]);
				kfree(portdata->out_buffer[j]);
				portdata->out_urbs[j] = NULL;
			}
		}
	}

	/* Now free per port private data */
	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		kfree(usb_get_serial_port_data(port));
	}
}

#ifdef CONFIG_PM
static int zte_suspend(struct usb_serial *serial, pm_message_t message)
{
	struct zte_intf_private *intfdata = serial->private;
	int b;

	dbg("%s entered", __func__);

	if (serial->dev->auto_pm) {
		spin_lock_irq(&intfdata->susp_lock);
		b = intfdata->in_flight;
		spin_unlock_irq(&intfdata->susp_lock);

		if (b)
			return -EBUSY;
	}

	spin_lock_irq(&intfdata->susp_lock);
	intfdata->suspended = 1;
	spin_unlock_irq(&intfdata->susp_lock);
	stop_read_write_urbs(serial);

	return 0;
}

static void play_delayed(struct usb_serial_port *port)
{
	struct zte_intf_private *data;
	struct zte_port_private *portdata;
	struct urb *urb;
	int err;

	portdata = usb_get_serial_port_data(port);
	data = port->serial->private;
	while ((urb = usb_get_from_anchor(&portdata->delayed))) {
		err = usb_submit_urb(urb, GFP_ATOMIC);

		if (!err)
			data->in_flight++;
	}
}

static int zte_resume(struct usb_serial *serial)
{
	int i, j;
	struct usb_serial_port *port;
	struct zte_intf_private *intfdata = serial->private;
	struct zte_port_private *portdata;
	struct urb *urb;
	int err = 0;

	dbg("%s entered", __func__);
	/* get the interrupt URBs resubmitted unconditionally */
	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		if (!port->interrupt_in_urb) {
			dbg("%s: No interrupt URB for port %d\n", __func__, i);
			continue;
		}
		err = usb_submit_urb(port->interrupt_in_urb, GFP_NOIO);
		dbg("Submitted interrupt URB for port %d (result %d)", i, err);
		if (err < 0) {
			err("%s: Error %d for interrupt URB of port%d",
				 __func__, err, i);
			goto err_out;
		}
	}

	for (i = 0; i < serial->num_ports; i++) {
		/* walk all ports */
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);

		/* skip closed ports */
		spin_lock_irq(&intfdata->susp_lock);
		if (!portdata->opened) {
			spin_unlock_irq(&intfdata->susp_lock);
			continue;
		}

		for (j = 0; j < N_IN_URB; j++) {
			urb = portdata->in_urbs[j];
			err = usb_submit_urb(urb, GFP_ATOMIC);
			if (err < 0) {
				err("%s: Error %d for bulk URB %d",
					 __func__, err, i);
				spin_unlock_irq(&intfdata->susp_lock);
				goto err_out;
			}
		}
		play_delayed(port);
		spin_unlock_irq(&intfdata->susp_lock);
	}
	spin_lock_irq(&intfdata->susp_lock);
	intfdata->suspended = 0;
	spin_unlock_irq(&intfdata->susp_lock);
err_out:
	return err;
}
#endif

MODULE_AUTHOR(DRIVER_AUTHOR);
MODULE_DESCRIPTION(DRIVER_DESC);
MODULE_VERSION(DRIVER_VERSION);
MODULE_LICENSE("GPL");

module_param(debug, bool, S_IRUGO | S_IWUSR);
MODULE_PARM_DESC(debug, "Debug messages");

#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,34)//use 2.6.33 sourcecode
#include <linux/kernel.h>
#include <linux/jiffies.h>
#include <linux/errno.h>
#include <linux/tty.h>
#include <linux/tty_flip.h>
#include <linux/module.h>
#include <linux/bitops.h>
#include <linux/usb.h>
#include <linux/usb/serial.h>

/* Function prototypes */
static int  zte_probe(struct usb_serial *serial,
			const struct usb_device_id *id);
static int  zte_open(struct tty_struct *tty, struct usb_serial_port *port);
static void zte_close(struct usb_serial_port *port);
static void zte_dtr_rts(struct usb_serial_port *port, int on);

static int  zte_startup(struct usb_serial *serial);
static void zte_disconnect(struct usb_serial *serial);
static void zte_release(struct usb_serial *serial);
static int  zte_write_room(struct tty_struct *tty);

static void zte_instat_callback(struct urb *urb);

static int zte_write(struct tty_struct *tty, struct usb_serial_port *port,
			const unsigned char *buf, int count);
static int  zte_chars_in_buffer(struct tty_struct *tty);
static void zte_set_termios(struct tty_struct *tty,
			struct usb_serial_port *port, struct ktermios *old);
static int  zte_tiocmget(struct tty_struct *tty, struct file *file);
static int  zte_tiocmset(struct tty_struct *tty, struct file *file,
				unsigned int set, unsigned int clear);
static int  zte_send_setup(struct usb_serial_port *port);
#ifdef CONFIG_PM
static int  zte_suspend(struct usb_serial *serial, pm_message_t message);
static int  zte_resume(struct usb_serial *serial);
#endif

/* Vendor and product IDs */
/* zte PRODUCTS */
#define zte_VENDOR_ID				0x19d2


static struct usb_device_id zte_ids[] = {
	   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0001, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0002, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0003, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0004, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0005, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0006, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0007, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0008, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0009, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0010, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0011, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0012, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0013, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0014, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0015, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0016, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0017, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0018, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0019, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0020, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0021, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0022, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0023, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0024, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0025, 0xff, 0xff, 0xff) },
    //   { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0026, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0027, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0028, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0029, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0030, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0031, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0032, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0033, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0034, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0035, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0036, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0037, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0038, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0039, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0040, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0041, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0042, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0043, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0044, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0045, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0046, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0047, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0048, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0049, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0050, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0051, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0052, 0xff, 0xff, 0xff) },
    //   { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0053, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0054, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0055, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0056, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0057, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0058, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0059, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0060, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0061, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0062, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0063, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0064, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0065, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0066, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0067, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0068, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0069, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0070, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0071, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0072, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0073, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0074, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0075, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0076, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0077, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0078, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0079, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0080, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0081, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0082, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0083, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0084, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0085, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0086, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0087, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0088, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0089, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0090, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0091, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0092, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0093, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0094, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0095, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0096, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0097, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0098, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0099, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0104, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0105, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0106, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0108, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0117, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0118, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0121, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0122, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0123, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0124, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0125, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0126, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0128, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0130, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0133, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0141, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0144, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0145, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0147, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0148, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0151, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0152, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0153, 0xff, 0xff, 0xff) },
    //{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0154, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0155, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0156, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0157, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0158, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0159, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0160, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0161, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0162, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0164, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0165, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0168, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0170, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0176, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0178, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1008, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1010, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1012, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1057, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1058, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1059, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1060, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1061, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1062, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1063, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1064, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1065, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1066, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1067, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1068, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1069, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1070, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1071, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1072, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1073, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1074, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1075, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1076, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1077, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1078, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1079, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1080, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1081, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1082, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1083, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1084, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1085, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1086, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1087, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1088, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1089, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1090, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1091, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1092, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1093, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1094, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1095, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1096, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1097, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1098, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1099, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1100, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1101, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1102, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1103, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1104, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1105, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1106, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1107, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1108, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1109, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1110, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1111, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1112, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1113, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1114, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1115, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1116, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1117, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1118, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1119, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1120, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1121, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1122, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1123, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1124, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1125, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1126, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1127, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1128, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1129, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1130, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1131, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1132, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1133, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1134, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1135, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1136, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1137, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1138, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1139, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1140, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1141, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1142, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1143, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1144, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1145, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1146, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1147, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1148, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1149, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1150, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1151, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1152, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1153, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1154, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1155, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1156, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1157, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1158, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1159, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1160, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1161, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1162, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1163, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1164, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1165, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1166, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1167, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1168, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1169, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1170, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1244, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1245, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1246, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1247, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1248, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1249, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1250, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1251, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1252, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1253, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1254, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1255, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1256, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1257, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1258, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1259, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1260, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1261, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1262, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1263, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1264, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1265, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1266, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1267, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1268, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1269, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1270, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1271, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1272, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1273, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1274, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1275, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1276, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1277, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1278, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1279, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1280, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1281, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1282, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1283, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1284, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1285, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1286, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1287, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1288, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1289, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1290, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1291, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1292, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1293, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1294, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1295, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1296, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1297, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1298, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1299, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1300, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1401, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1402, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1403, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1404, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1405, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1406, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1407, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1408, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1409, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1410, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1411, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1412, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1413, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1414, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1415, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1416, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1417, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1418, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1419, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1420, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1421, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1422, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1423, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1424, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1425, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1426, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1427, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1428, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1429, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1430, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1431, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1432, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1433, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1434, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1435, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1436, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1437, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1438, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1439, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1440, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1441, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1442, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1443, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1444, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1445, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1446, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1447, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1448, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1449, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1450, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1451, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1452, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1453, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1454, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1455, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1456, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1457, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1458, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1459, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1460, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1461, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1462, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1463, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1464, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1465, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1466, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1467, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1468, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1469, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1470, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1471, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1472, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1473, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1474, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1475, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1476, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1477, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1478, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1479, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1480, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1481, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1482, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1483, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1484, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1485, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1486, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1487, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1488, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1489, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1490, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1491, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1492, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1493, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1494, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1495, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1496, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1497, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1498, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1499, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1500, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1501, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1502, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1503, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1504, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1505, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1506, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1507, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1508, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1509, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1510, 0xff, 0xff, 0xff) },       
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x2002, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x2003, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0xFFEC, 0xff, 0xff, 0xff) },

    { USB_DEVICE_AND_INTERFACE_INFO(TPLink_VENDOR_ID, 0x7E11, 0xff, 0xff, 0xff) },/*TPLink*/
    { USB_DEVICE_AND_INTERFACE_INFO(QUALCOMM_VENDOR_ID, 0x9001, 0xff, 0xff, 0xff) },/*QUALCOMM_VENDOR_ID*/
    { USB_DEVICE_AND_INTERFACE_INFO(QUALCOMM_VENDOR_ID, 0x9002, 0xff, 0xff, 0xff) },

	{ } /* Terminating entry */
};
MODULE_DEVICE_TABLE(usb, zte_ids);

static struct usb_driver zte_driver = {
	.name       = "zte",
	.probe      = usb_serial_probe,
	.disconnect = usb_serial_disconnect,
#ifdef CONFIG_PM
	.suspend    = usb_serial_suspend,
	.resume     = usb_serial_resume,
	.supports_autosuspend =	1,
#endif
	.id_table   = zte_ids,
	.no_dynamic_id = 	1,
};

/* The card has three separate interfaces, which the serial driver
 * recognizes separately, thus num_port=1.
 */

static struct usb_serial_driver zte_1port_device = {
	.driver = {
		.owner =	THIS_MODULE,
		.name =		"zte1",
	},
	.description       = "GSM modem (1-port)",
	.usb_driver        = &zte_driver,
	.id_table          = zte_ids,
	.num_ports         = 1,
	.probe             = zte_probe,
	.open              = zte_open,
	.close             = zte_close,
	.dtr_rts	   = zte_dtr_rts,
	.write             = zte_write,
	.write_room        = zte_write_room,
	.chars_in_buffer   = zte_chars_in_buffer,
	.set_termios       = zte_set_termios,
	.tiocmget          = zte_tiocmget,
	.tiocmset          = zte_tiocmset,
	.attach            = zte_startup,
	.disconnect        = zte_disconnect,
	.release           = zte_release,
	.read_int_callback = zte_instat_callback,
#ifdef CONFIG_PM
	.suspend           = zte_suspend,
	.resume            = zte_resume,
#endif
};

static int debug;

/* per port private data */

#define N_IN_URB 4
#define N_OUT_URB 4
#define IN_BUFLEN 4096
#define OUT_BUFLEN 4096

struct zte_intf_private {
	spinlock_t susp_lock;
	unsigned int suspended:1;
	int in_flight;
};

struct zte_port_private {
	/* Input endpoints and buffer for this port */
	struct urb *in_urbs[N_IN_URB];
	u8 *in_buffer[N_IN_URB];
	/* Output endpoints and buffer for this port */
	struct urb *out_urbs[N_OUT_URB];
	u8 *out_buffer[N_OUT_URB];
	unsigned long out_busy;		/* Bit vector of URBs in use */
	int opened;
	struct usb_anchor delayed;

	/* Settings for the port */
	int rts_state;	/* Handshaking pins (outputs) */
	int dtr_state;
	int cts_state;	/* Handshaking pins (inputs) */
	int dsr_state;
	int dcd_state;
	int ri_state;

	unsigned long tx_start_time[N_OUT_URB];
};

/* Functions used by new usb-serial code. */
static int __init zte_init(void)
{
	int retval;
	retval = usb_serial_register(&zte_1port_device);
	if (retval)
		goto failed_1port_device_register;
	retval = usb_register(&zte_driver);
	if (retval)
		goto failed_driver_register;

	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
	       DRIVER_DESC "\n");

	return 0;

failed_driver_register:
	usb_serial_deregister(&zte_1port_device);
failed_1port_device_register:
	return retval;
}

static void __exit zte_exit(void)
{
	usb_deregister(&zte_driver);
	usb_serial_deregister(&zte_1port_device);
}

module_init(zte_init);
module_exit(zte_exit);

static int zte_probe(struct usb_serial *serial,
			const struct usb_device_id *id)
{
	struct zte_intf_private *data;
	/* D-Link DWM 652 still exposes CD-Rom emulation interface in modem mode */
	/*if (serial->dev->descriptor.idVendor == DLINK_VENDOR_ID &&
		serial->dev->descriptor.idProduct == DLINK_PRODUCT_DWM_652 &&
		serial->interface->cur_altsetting->desc.bInterfaceClass == 0x8)
		return -ENODEV;
*/
	data = serial->private = kzalloc(sizeof(struct zte_intf_private), GFP_KERNEL);
	if (!data)
		return -ENOMEM;
	spin_lock_init(&data->susp_lock);
	return 0;
}

static void zte_set_termios(struct tty_struct *tty,
		struct usb_serial_port *port, struct ktermios *old_termios)
{
	dbg("%s", __func__);
	/* Doesn't support zte setting */
	tty_termios_copy_hw(tty->termios, old_termios);
	zte_send_setup(port);
}

static int zte_tiocmget(struct tty_struct *tty, struct file *file)
{
	struct usb_serial_port *port = tty->driver_data;
	unsigned int value;
	struct zte_port_private *portdata;

	portdata = usb_get_serial_port_data(port);

	value = ((portdata->rts_state) ? TIOCM_RTS : 0) |
		((portdata->dtr_state) ? TIOCM_DTR : 0) |
		((portdata->cts_state) ? TIOCM_CTS : 0) |
		((portdata->dsr_state) ? TIOCM_DSR : 0) |
		((portdata->dcd_state) ? TIOCM_CAR : 0) |
		((portdata->ri_state) ? TIOCM_RNG : 0);

	return value;
}

static int zte_tiocmset(struct tty_struct *tty, struct file *file,
			unsigned int set, unsigned int clear)
{
	struct usb_serial_port *port = tty->driver_data;
	struct zte_port_private *portdata;

	portdata = usb_get_serial_port_data(port);

	/* FIXME: what locks portdata fields ? */
	if (set & TIOCM_RTS)
		portdata->rts_state = 1;
	if (set & TIOCM_DTR)
		portdata->dtr_state = 1;

	if (clear & TIOCM_RTS)
		portdata->rts_state = 0;
	if (clear & TIOCM_DTR)
		portdata->dtr_state = 0;
	return zte_send_setup(port);
}

/* Write */
static int zte_write(struct tty_struct *tty, struct usb_serial_port *port,
			const unsigned char *buf, int count)
{
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata;
	int i;
	int left, todo;
	struct urb *this_urb = NULL; /* spurious */
	int err;
	unsigned long flags;

	portdata = usb_get_serial_port_data(port);
	intfdata = port->serial->private;

	dbg("%s: write (%d chars)", __func__, count);

	i = 0;
	left = count;
	for (i = 0; left > 0 && i < N_OUT_URB; i++) {
		todo = left;
		if (todo > OUT_BUFLEN)
			todo = OUT_BUFLEN;

		this_urb = portdata->out_urbs[i];
		if (test_and_set_bit(i, &portdata->out_busy)) {
			if (time_before(jiffies,
					portdata->tx_start_time[i] + 10 * HZ))
				continue;
			usb_unlink_urb(this_urb);
			continue;
		}
		dbg("%s: endpoint %d buf %d", __func__,
			usb_pipeendpoint(this_urb->pipe), i);

		err = usb_autopm_get_interface_async(port->serial->interface);
		if (err < 0)
			break;

		/* send the data */
		memcpy(this_urb->transfer_buffer, buf, todo);
		this_urb->transfer_buffer_length = todo;

		spin_lock_irqsave(&intfdata->susp_lock, flags);
		if (intfdata->suspended) {
			usb_anchor_urb(this_urb, &portdata->delayed);
			spin_unlock_irqrestore(&intfdata->susp_lock, flags);
		} else {
			intfdata->in_flight++;
			spin_unlock_irqrestore(&intfdata->susp_lock, flags);
			err = usb_submit_urb(this_urb, GFP_ATOMIC);
			if (err) {
				dbg("usb_submit_urb %p (write bulk) failed "
					"(%d)", this_urb, err);
				clear_bit(i, &portdata->out_busy);
				spin_lock_irqsave(&intfdata->susp_lock, flags);
				intfdata->in_flight--;
				spin_unlock_irqrestore(&intfdata->susp_lock, flags);
				continue;
			}
		}

		portdata->tx_start_time[i] = jiffies;
		buf += todo;
		left -= todo;
	}

	count -= left;
	dbg("%s: wrote (did %d)", __func__, count);
	return count;
}

static void zte_indat_callback(struct urb *urb)
{
	int err;
	int endpoint;
	struct usb_serial_port *port;
	struct tty_struct *tty;
	unsigned char *data = urb->transfer_buffer;
	int status = urb->status;

	dbg("%s: %p", __func__, urb);

	endpoint = usb_pipeendpoint(urb->pipe);
	port =  urb->context;

	if (status) {
		dbg("%s: nonzero status: %d on endpoint %02x.",
		    __func__, status, endpoint);
	} else {
		tty = tty_port_tty_get(&port->port);
		if (urb->actual_length) {
			tty_buffer_request_room(tty, urb->actual_length);
			tty_insert_flip_string(tty, data, urb->actual_length);
			tty_flip_buffer_push(tty);
		} else 
			dbg("%s: empty read urb received", __func__);
		tty_kref_put(tty);

		/* Resubmit urb so we continue receiving */
		if (port->port.count && status != -ESHUTDOWN) {
			err = usb_submit_urb(urb, GFP_ATOMIC);
			if (err)
				printk(KERN_ERR "%s: resubmit read urb failed. "
					"(%d)", __func__, err);
			else
				usb_mark_last_busy(port->serial->dev);
		}

	}
	return;
}

static void zte_outdat_callback(struct urb *urb)
{
	struct usb_serial_port *port;
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata;
	int i;

	dbg("%s", __func__);

	port =  urb->context;
	intfdata = port->serial->private;

	usb_serial_port_softint(port);
	usb_autopm_put_interface_async(port->serial->interface);
	portdata = usb_get_serial_port_data(port);
	spin_lock(&intfdata->susp_lock);
	intfdata->in_flight--;
	spin_unlock(&intfdata->susp_lock);

	for (i = 0; i < N_OUT_URB; ++i) {
		if (portdata->out_urbs[i] == urb) {
			smp_mb__before_clear_bit();
			clear_bit(i, &portdata->out_busy);
			break;
		}
	}
}

static void zte_instat_callback(struct urb *urb)
{
	int err;
	int status = urb->status;
	struct usb_serial_port *port =  urb->context;
	struct zte_port_private *portdata = usb_get_serial_port_data(port);

	dbg("%s", __func__);
	dbg("%s: urb %p port %p has data %p", __func__, urb, port, portdata);

	if (status == 0) {
		struct usb_ctrlrequest *req_pkt =
				(struct usb_ctrlrequest *)urb->transfer_buffer;

		if (!req_pkt) {
			dbg("%s: NULL req_pkt\n", __func__);
			return;
		}
		if ((req_pkt->bRequestType == 0xA1) &&
				(req_pkt->bRequest == 0x20)) {
			int old_dcd_state;
			unsigned char signals = *((unsigned char *)
					urb->transfer_buffer +
					sizeof(struct usb_ctrlrequest));

			dbg("%s: signal x%x", __func__, signals);

			old_dcd_state = portdata->dcd_state;
			portdata->cts_state = 1;
			portdata->dcd_state = ((signals & 0x01) ? 1 : 0);
			portdata->dsr_state = ((signals & 0x02) ? 1 : 0);
			portdata->ri_state = ((signals & 0x08) ? 1 : 0);

			if (old_dcd_state && !portdata->dcd_state) {
				struct tty_struct *tty =
						tty_port_tty_get(&port->port);
				if (tty && !C_CLOCAL(tty))
					tty_hangup(tty);
				tty_kref_put(tty);
			}
		} else {
			dbg("%s: type %x req %x", __func__,
				req_pkt->bRequestType, req_pkt->bRequest);
		}
	} else
		err("%s: error %d", __func__, status);

	/* Resubmit urb so we continue receiving IRQ data */
	if (status != -ESHUTDOWN && status != -ENOENT) {
		err = usb_submit_urb(urb, GFP_ATOMIC);
		if (err)
			dbg("%s: resubmit intr urb failed. (%d)",
				__func__, err);
	}
}

static int zte_write_room(struct tty_struct *tty)
{
	struct usb_serial_port *port = tty->driver_data;
	struct zte_port_private *portdata;
	int i;
	int data_len = 0;
	struct urb *this_urb;

	portdata = usb_get_serial_port_data(port);

	for (i = 0; i < N_OUT_URB; i++) {
		this_urb = portdata->out_urbs[i];
		if (this_urb && !test_bit(i, &portdata->out_busy))
			data_len += OUT_BUFLEN;
	}

	dbg("%s: %d", __func__, data_len);
	return data_len;
}

static int zte_chars_in_buffer(struct tty_struct *tty)
{
	struct usb_serial_port *port = tty->driver_data;
	struct zte_port_private *portdata;
	int i;
	int data_len = 0;
	struct urb *this_urb;

	portdata = usb_get_serial_port_data(port);

	for (i = 0; i < N_OUT_URB; i++) {
		this_urb = portdata->out_urbs[i];
		/* FIXME: This locking is insufficient as this_urb may
		   go unused during the test */
		if (this_urb && test_bit(i, &portdata->out_busy))
			data_len += this_urb->transfer_buffer_length;
	}
	dbg("%s: %d", __func__, data_len);
	return data_len;
}

static int zte_open(struct tty_struct *tty, struct usb_serial_port *port)
{
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata;
	struct usb_serial *serial = port->serial;
	int i, err;
	struct urb *urb;

	portdata = usb_get_serial_port_data(port);
	intfdata = serial->private;

	dbg("%s", __func__);

	/* Start reading from the IN endpoint */
	for (i = 0; i < N_IN_URB; i++) {
		urb = portdata->in_urbs[i];
		if (!urb)
			continue;
		err = usb_submit_urb(urb, GFP_KERNEL);
		if (err) {
			dbg("%s: submit urb %d failed (%d) %d",
				__func__, i, err,
				urb->transfer_buffer_length);
		}
	}

	zte_send_setup(port);

	serial->interface->needs_remote_wakeup = 1;
	spin_lock_irq(&intfdata->susp_lock);
	portdata->opened = 1;
	spin_unlock_irq(&intfdata->susp_lock);
	usb_autopm_put_interface(serial->interface);

	return 0;
}

static void zte_dtr_rts(struct usb_serial_port *port, int on)
{
	struct usb_serial *serial = port->serial;
	struct zte_port_private *portdata;

	dbg("%s", __func__);
	portdata = usb_get_serial_port_data(port);
	mutex_lock(&serial->disc_mutex);
	portdata->rts_state = on;
	portdata->dtr_state = on;
	if (serial->dev)
		zte_send_setup(port);
	mutex_unlock(&serial->disc_mutex);
}


static void zte_close(struct usb_serial_port *port)
{
	int i;
	struct usb_serial *serial = port->serial;
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata = port->serial->private;

	dbg("%s", __func__);
	portdata = usb_get_serial_port_data(port);

	if (serial->dev) {
		/* Stop reading/writing urbs */
		spin_lock_irq(&intfdata->susp_lock);
		portdata->opened = 0;
		spin_unlock_irq(&intfdata->susp_lock);

		for (i = 0; i < N_IN_URB; i++)
			usb_kill_urb(portdata->in_urbs[i]);
		for (i = 0; i < N_OUT_URB; i++)
			usb_kill_urb(portdata->out_urbs[i]);
		usb_autopm_get_interface(serial->interface);
		serial->interface->needs_remote_wakeup = 0;
	}
}

/* Helper functions used by zte_setup_urbs */
static struct urb *zte_setup_urb(struct usb_serial *serial, int endpoint,
		int dir, void *ctx, char *buf, int len,
		void (*callback)(struct urb *))
{
	struct urb *urb;

	if (endpoint == -1)
		return NULL;		/* endpoint not needed */

	urb = usb_alloc_urb(0, GFP_KERNEL);		/* No ISO */
	if (urb == NULL) {
		dbg("%s: alloc for endpoint %d failed.", __func__, endpoint);
		return NULL;
	}

		/* Fill URB using supplied data. */
	usb_fill_bulk_urb(urb, serial->dev,
		      usb_sndbulkpipe(serial->dev, endpoint) | dir,
		      buf, len, callback, ctx);

	return urb;
}

/* Setup urbs */
static void zte_setup_urbs(struct usb_serial *serial)
{
	int i, j;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;

	dbg("%s", __func__);

	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);

		/* Do indat endpoints first */
		for (j = 0; j < N_IN_URB; ++j) {
			portdata->in_urbs[j] = zte_setup_urb(serial,
					port->bulk_in_endpointAddress,
					USB_DIR_IN, port,
					portdata->in_buffer[j],
					IN_BUFLEN, zte_indat_callback);
		}

		/* outdat endpoints */
		for (j = 0; j < N_OUT_URB; ++j) {
			portdata->out_urbs[j] = zte_setup_urb(serial,
					port->bulk_out_endpointAddress,
					USB_DIR_OUT, port,
					portdata->out_buffer[j],
					OUT_BUFLEN, zte_outdat_callback);
		}
	}
}


/** send RTS/DTR state to the port.
 *
 * This is exactly the same as SET_CONTROL_LINE_STATE from the PSTN
 * CDC.
*/
static int zte_send_setup(struct usb_serial_port *port)
{
	struct usb_serial *serial = port->serial;
	struct zte_port_private *portdata;
	int ifNum = serial->interface->cur_altsetting->desc.bInterfaceNumber;
	int val = 0;
	dbg("%s", __func__);

	portdata = usb_get_serial_port_data(port);

	if (portdata->dtr_state)
		val |= 0x01;
	if (portdata->rts_state)
		val |= 0x02;

	return usb_control_msg(serial->dev,
		usb_rcvctrlpipe(serial->dev, 0),
		0x22, 0x21, val, ifNum, NULL, 0, USB_CTRL_SET_TIMEOUT);
}

static int zte_startup(struct usb_serial *serial)
{
	int i, j, err;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;
	u8 *buffer;

	dbg("%s", __func__);

	/* Now setup per port private data */
	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		portdata = kzalloc(sizeof(*portdata), GFP_KERNEL);
		if (!portdata) {
			dbg("%s: kmalloc for zte_port_private (%d) failed!.",
					__func__, i);
			return 1;
		}
		init_usb_anchor(&portdata->delayed);

		for (j = 0; j < N_IN_URB; j++) {
			buffer = (u8 *)__get_free_page(GFP_KERNEL);
			if (!buffer)
				goto bail_out_error;
			portdata->in_buffer[j] = buffer;
		}

		for (j = 0; j < N_OUT_URB; j++) {
			buffer = kmalloc(OUT_BUFLEN, GFP_KERNEL);
			if (!buffer)
				goto bail_out_error2;
			portdata->out_buffer[j] = buffer;
		}

		usb_set_serial_port_data(port, portdata);

		if (!port->interrupt_in_urb)
			continue;
		err = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);
		if (err)
			dbg("%s: submit irq_in urb failed %d",
				__func__, err);
	}
	zte_setup_urbs(serial);
	return 0;

bail_out_error2:
	for (j = 0; j < N_OUT_URB; j++)
		kfree(portdata->out_buffer[j]);
bail_out_error:
	for (j = 0; j < N_IN_URB; j++)
		if (portdata->in_buffer[j])
			free_page((unsigned long)portdata->in_buffer[j]);
	kfree(portdata);
	return 1;
}

static void stop_read_write_urbs(struct usb_serial *serial)
{
	int i, j;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;

	/* Stop reading/writing urbs */
	for (i = 0; i < serial->num_ports; ++i) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);
		for (j = 0; j < N_IN_URB; j++)
			usb_kill_urb(portdata->in_urbs[j]);
		for (j = 0; j < N_OUT_URB; j++)
			usb_kill_urb(portdata->out_urbs[j]);
	}
}

static void zte_disconnect(struct usb_serial *serial)
{
	dbg("%s", __func__);

	stop_read_write_urbs(serial);
}

static void zte_release(struct usb_serial *serial)
{
	int i, j;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;

	dbg("%s", __func__);

	/* Now free them */
	for (i = 0; i < serial->num_ports; ++i) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);

		for (j = 0; j < N_IN_URB; j++) {
			if (portdata->in_urbs[j]) {
				usb_free_urb(portdata->in_urbs[j]);
				free_page((unsigned long)
					portdata->in_buffer[j]);
				portdata->in_urbs[j] = NULL;
			}
		}
		for (j = 0; j < N_OUT_URB; j++) {
			if (portdata->out_urbs[j]) {
				usb_free_urb(portdata->out_urbs[j]);
				kfree(portdata->out_buffer[j]);
				portdata->out_urbs[j] = NULL;
			}
		}
	}

	/* Now free per port private data */
	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		kfree(usb_get_serial_port_data(port));
	}
}

#ifdef CONFIG_PM
static int zte_suspend(struct usb_serial *serial, pm_message_t message)
{
	struct zte_intf_private *intfdata = serial->private;
	int b;

	dbg("%s entered", __func__);

	if (message.event & PM_EVENT_AUTO) {
		spin_lock_irq(&intfdata->susp_lock);
		b = intfdata->in_flight;
		spin_unlock_irq(&intfdata->susp_lock);

		if (b)
			return -EBUSY;
	}

	spin_lock_irq(&intfdata->susp_lock);
	intfdata->suspended = 1;
	spin_unlock_irq(&intfdata->susp_lock);
	stop_read_write_urbs(serial);

	return 0;
}

static void play_delayed(struct usb_serial_port *port)
{
	struct zte_intf_private *data;
	struct zte_port_private *portdata;
	struct urb *urb;
	int err;

	portdata = usb_get_serial_port_data(port);
	data = port->serial->private;
	while ((urb = usb_get_from_anchor(&portdata->delayed))) {
		err = usb_submit_urb(urb, GFP_ATOMIC);
		if (!err)
			data->in_flight++;
	}
}

static int zte_resume(struct usb_serial *serial)
{
	int i, j;
	struct usb_serial_port *port;
	struct zte_intf_private *intfdata = serial->private;
	struct zte_port_private *portdata;
	struct urb *urb;
	int err = 0;

	dbg("%s entered", __func__);
	/* get the interrupt URBs resubmitted unconditionally */
	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		if (!port->interrupt_in_urb) {
			dbg("%s: No interrupt URB for port %d\n", __func__, i);
			continue;
		}
		err = usb_submit_urb(port->interrupt_in_urb, GFP_NOIO);
		dbg("Submitted interrupt URB for port %d (result %d)", i, err);
		if (err < 0) {
			err("%s: Error %d for interrupt URB of port%d",
				 __func__, err, i);
			goto err_out;
		}
	}

	for (i = 0; i < serial->num_ports; i++) {
		/* walk all ports */
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);

		/* skip closed ports */
		spin_lock_irq(&intfdata->susp_lock);
		if (!portdata->opened) {
			spin_unlock_irq(&intfdata->susp_lock);
			continue;
		}

		for (j = 0; j < N_IN_URB; j++) {
			urb = portdata->in_urbs[j];
			err = usb_submit_urb(urb, GFP_ATOMIC);
			if (err < 0) {
				err("%s: Error %d for bulk URB %d",
					 __func__, err, i);
				spin_unlock_irq(&intfdata->susp_lock);
				goto err_out;
			}
		}
		play_delayed(port);
		spin_unlock_irq(&intfdata->susp_lock);
	}
	spin_lock_irq(&intfdata->susp_lock);
	intfdata->suspended = 0;
	spin_unlock_irq(&intfdata->susp_lock);
err_out:
	return err;
}
#endif

MODULE_AUTHOR(DRIVER_AUTHOR);
MODULE_DESCRIPTION(DRIVER_DESC);
MODULE_VERSION(DRIVER_VERSION);
MODULE_LICENSE("GPL");

module_param(debug, bool, S_IRUGO | S_IWUSR);
MODULE_PARM_DESC(debug, "Debug messages");

#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35)//use 2.6.34 sourcecode
#include <linux/kernel.h>
#include <linux/jiffies.h>
#include <linux/errno.h>
#include <linux/tty.h>
#include <linux/tty_flip.h>
#include <linux/slab.h>
#include <linux/module.h>
#include <linux/bitops.h>
#include <linux/usb.h>
#include <linux/usb/serial.h>

/* Function prototypes */
static int  zte_probe(struct usb_serial *serial,
			const struct usb_device_id *id);
static int  zte_open(struct tty_struct *tty, struct usb_serial_port *port);
static void zte_close(struct usb_serial_port *port);
static void zte_dtr_rts(struct usb_serial_port *port, int on);

static int  zte_startup(struct usb_serial *serial);
static void zte_disconnect(struct usb_serial *serial);
static void zte_release(struct usb_serial *serial);
static int  zte_write_room(struct tty_struct *tty);

static void zte_instat_callback(struct urb *urb);

static int zte_write(struct tty_struct *tty, struct usb_serial_port *port,
			const unsigned char *buf, int count);
static int  zte_chars_in_buffer(struct tty_struct *tty);
static void zte_set_termios(struct tty_struct *tty,
			struct usb_serial_port *port, struct ktermios *old);
static int  zte_tiocmget(struct tty_struct *tty, struct file *file);
static int  zte_tiocmset(struct tty_struct *tty, struct file *file,
				unsigned int set, unsigned int clear);
static int  zte_send_setup(struct usb_serial_port *port);
#ifdef CONFIG_PM
static int  zte_suspend(struct usb_serial *serial, pm_message_t message);
static int  zte_resume(struct usb_serial *serial);
#endif




/* Vendor and product IDs */
/* zte PRODUCTS */
#define zte_VENDOR_ID				0x19d2

/* some devices interfaces need special handling due to a number of reasons */
enum zte_blacklist_reason {
		zte_BLACKLIST_NONE = 0,
		zte_BLACKLIST_SENDSETUP = 1,
		zte_BLACKLIST_RESERVED_IF = 2
};

struct zte_blacklist_info {
	const u32 infolen;	/* number of interface numbers on blacklist */
	const u8  *ifaceinfo;	/* pointer to the array holding the numbers */
	enum zte_blacklist_reason reason;
};

static const u8 four_g_w14_no_sendsetup[] = { 0, 1 };
static const struct zte_blacklist_info four_g_w14_blacklist = {
	.infolen = ARRAY_SIZE(four_g_w14_no_sendsetup),
	.ifaceinfo = four_g_w14_no_sendsetup,
	.reason = zte_BLACKLIST_SENDSETUP
};


static struct usb_device_id zte_ids[] = {
	   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0001, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0002, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0003, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0004, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0005, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0006, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0007, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0008, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0009, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0010, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0011, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0012, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0013, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0014, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0015, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0016, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0017, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0018, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0019, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0020, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0021, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0022, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0023, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0024, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0025, 0xff, 0xff, 0xff) },
    //   { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0026, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0027, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0028, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0029, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0030, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0031, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0032, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0033, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0034, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0035, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0036, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0037, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0038, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0039, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0040, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0041, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0042, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0043, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0044, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0045, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0046, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0047, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0048, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0049, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0050, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0051, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0052, 0xff, 0xff, 0xff) },
    //   { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0053, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0054, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0055, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0056, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0057, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0058, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0059, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0060, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0061, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0062, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0063, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0064, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0065, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0066, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0067, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0068, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0069, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0070, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0071, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0072, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0073, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0074, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0075, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0076, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0077, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0078, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0079, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0080, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0081, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0082, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0083, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0084, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0085, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0086, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0087, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0088, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0089, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0090, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0091, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0092, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0093, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0094, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0095, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0096, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0097, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0098, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0099, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0104, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0105, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0106, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0108, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0117, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0118, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0121, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0122, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0123, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0124, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0125, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0126, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0128, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0130, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0133, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0141, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0144, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0145, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0147, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0148, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0151, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0152, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0153, 0xff, 0xff, 0xff) },
    //{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0154, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0155, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0156, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0157, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0158, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0159, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0160, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0161, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0162, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0164, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0165, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0168, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0170, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0176, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0178, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1008, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1010, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1012, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1057, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1058, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1059, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1060, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1061, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1062, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1063, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1064, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1065, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1066, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1067, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1068, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1069, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1070, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1071, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1072, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1073, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1074, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1075, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1076, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1077, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1078, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1079, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1080, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1081, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1082, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1083, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1084, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1085, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1086, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1087, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1088, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1089, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1090, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1091, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1092, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1093, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1094, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1095, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1096, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1097, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1098, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1099, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1100, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1101, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1102, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1103, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1104, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1105, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1106, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1107, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1108, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1109, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1110, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1111, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1112, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1113, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1114, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1115, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1116, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1117, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1118, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1119, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1120, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1121, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1122, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1123, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1124, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1125, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1126, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1127, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1128, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1129, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1130, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1131, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1132, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1133, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1134, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1135, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1136, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1137, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1138, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1139, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1140, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1141, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1142, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1143, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1144, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1145, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1146, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1147, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1148, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1149, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1150, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1151, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1152, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1153, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1154, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1155, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1156, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1157, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1158, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1159, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1160, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1161, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1162, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1163, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1164, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1165, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1166, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1167, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1168, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1169, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1170, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1244, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1245, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1246, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1247, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1248, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1249, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1250, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1251, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1252, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1253, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1254, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1255, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1256, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1257, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1258, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1259, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1260, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1261, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1262, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1263, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1264, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1265, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1266, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1267, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1268, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1269, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1270, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1271, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1272, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1273, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1274, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1275, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1276, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1277, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1278, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1279, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1280, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1281, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1282, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1283, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1284, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1285, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1286, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1287, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1288, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1289, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1290, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1291, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1292, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1293, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1294, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1295, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1296, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1297, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1298, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1299, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1300, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1401, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1402, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1403, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1404, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1405, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1406, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1407, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1408, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1409, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1410, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1411, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1412, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1413, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1414, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1415, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1416, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1417, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1418, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1419, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1420, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1421, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1422, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1423, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1424, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1425, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1426, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1427, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1428, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1429, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1430, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1431, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1432, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1433, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1434, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1435, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1436, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1437, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1438, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1439, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1440, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1441, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1442, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1443, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1444, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1445, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1446, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1447, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1448, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1449, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1450, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1451, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1452, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1453, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1454, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1455, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1456, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1457, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1458, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1459, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1460, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1461, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1462, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1463, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1464, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1465, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1466, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1467, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1468, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1469, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1470, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1471, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1472, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1473, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1474, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1475, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1476, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1477, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1478, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1479, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1480, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1481, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1482, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1483, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1484, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1485, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1486, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1487, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1488, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1489, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1490, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1491, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1492, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1493, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1494, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1495, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1496, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1497, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1498, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1499, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1500, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1501, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1502, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1503, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1504, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1505, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1506, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1507, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1508, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1509, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1510, 0xff, 0xff, 0xff) },       
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x2002, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x2003, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0xFFEC, 0xff, 0xff, 0xff) },

    { USB_DEVICE_AND_INTERFACE_INFO(TPLink_VENDOR_ID, 0x7E11, 0xff, 0xff, 0xff) },/*TPLink*/
    { USB_DEVICE_AND_INTERFACE_INFO(QUALCOMM_VENDOR_ID, 0x9001, 0xff, 0xff, 0xff) },/*QUALCOMM_VENDOR_ID*/
    { USB_DEVICE_AND_INTERFACE_INFO(QUALCOMM_VENDOR_ID, 0x9002, 0xff, 0xff, 0xff) },

	{ } /* Terminating entry */
};
MODULE_DEVICE_TABLE(usb, zte_ids);

static struct usb_driver zte_driver = {
	.name       = "zte",
	.probe      = usb_serial_probe,
	.disconnect = usb_serial_disconnect,
#ifdef CONFIG_PM
	.suspend    = usb_serial_suspend,
	.resume     = usb_serial_resume,
	.supports_autosuspend =	1,
#endif
	.id_table   = zte_ids,
	.no_dynamic_id = 	1,
};

/* The card has three separate interfaces, which the serial driver
 * recognizes separately, thus num_port=1.
 */

static struct usb_serial_driver zte_1port_device = {
	.driver = {
		.owner =	THIS_MODULE,
		.name =		"zte1",
	},
	.description       = "GSM modem (1-port)",
	.usb_driver        = &zte_driver,
	.id_table          = zte_ids,
	.num_ports         = 1,
	.probe             = zte_probe,
	.open              = zte_open,
	.close             = zte_close,
	.dtr_rts	   = zte_dtr_rts,
	.write             = zte_write,
	.write_room        = zte_write_room,
	.chars_in_buffer   = zte_chars_in_buffer,
	.set_termios       = zte_set_termios,
	.tiocmget          = zte_tiocmget,
	.tiocmset          = zte_tiocmset,
	.attach            = zte_startup,
	.disconnect        = zte_disconnect,
	.release           = zte_release,
	.read_int_callback = zte_instat_callback,
#ifdef CONFIG_PM
	.suspend           = zte_suspend,
	.resume            = zte_resume,
#endif
};

static int debug;

/* per port private data */

#define N_IN_URB 4
#define N_OUT_URB 4
#define IN_BUFLEN 4096
#define OUT_BUFLEN 4096

struct zte_intf_private {
	spinlock_t susp_lock;
	unsigned int suspended:1;
	int in_flight;
	struct zte_blacklist_info *blacklist_info;
};

struct zte_port_private {
	/* Input endpoints and buffer for this port */
	struct urb *in_urbs[N_IN_URB];
	u8 *in_buffer[N_IN_URB];
	/* Output endpoints and buffer for this port */
	struct urb *out_urbs[N_OUT_URB];
	u8 *out_buffer[N_OUT_URB];
	unsigned long out_busy;		/* Bit vector of URBs in use */
	int opened;
	struct usb_anchor delayed;

	/* Settings for the port */
	int rts_state;	/* Handshaking pins (outputs) */
	int dtr_state;
	int cts_state;	/* Handshaking pins (inputs) */
	int dsr_state;
	int dcd_state;
	int ri_state;

	unsigned long tx_start_time[N_OUT_URB];
};

/* Functions used by new usb-serial code. */
static int __init zte_init(void)
{
	int retval;
	retval = usb_serial_register(&zte_1port_device);
	if (retval)
		goto failed_1port_device_register;
	retval = usb_register(&zte_driver);
	if (retval)
		goto failed_driver_register;

	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
	       DRIVER_DESC "\n");

	return 0;

failed_driver_register:
	usb_serial_deregister(&zte_1port_device);
failed_1port_device_register:
	return retval;
}

static void __exit zte_exit(void)
{
	usb_deregister(&zte_driver);

	usb_serial_deregister(&zte_1port_device);
}

module_init(zte_init);
module_exit(zte_exit);

static int zte_probe(struct usb_serial *serial,
			const struct usb_device_id *id)
{
	struct zte_intf_private *data;

	/* D-Link DWM 652 still exposes CD-Rom emulation interface in modem mode */
	/*if (serial->dev->descriptor.idVendor == DLINK_VENDOR_ID &&
		serial->dev->descriptor.idProduct == DLINK_PRODUCT_DWM_652 &&
		serial->interface->cur_altsetting->desc.bInterfaceClass == 0x8)
		return -ENODEV;*/

	/* Bandrich modem and AT command interface is 0xff */
	/*if ((serial->dev->descriptor.idVendor == BANDRICH_VENDOR_ID ||
		serial->dev->descriptor.idVendor == PIRELLI_VENDOR_ID) &&
		serial->interface->cur_altsetting->desc.bInterfaceClass != 0xff)
		return -ENODEV;
*/
	data = serial->private = kzalloc(sizeof(struct zte_intf_private), GFP_KERNEL);
	if (!data)
		return -ENOMEM;
	spin_lock_init(&data->susp_lock);
	data->blacklist_info = (struct zte_blacklist_info*) id->driver_info;
	return 0;
}

static enum zte_blacklist_reason is_blacklisted(const u8 ifnum,
				const struct zte_blacklist_info *blacklist)
{
	const u8  *info;
	int i;

	if (blacklist) {
		info = blacklist->ifaceinfo;

		for (i = 0; i < blacklist->infolen; i++) {
			if (info[i] == ifnum)
				return blacklist->reason;
		}
	}
	return zte_BLACKLIST_NONE;
}

static void zte_set_termios(struct tty_struct *tty,
		struct usb_serial_port *port, struct ktermios *old_termios)
{
	dbg("%s", __func__);
	/* Doesn't support zte setting */
	tty_termios_copy_hw(tty->termios, old_termios);
	zte_send_setup(port);
}

static int zte_tiocmget(struct tty_struct *tty, struct file *file)
{
	struct usb_serial_port *port = tty->driver_data;
	unsigned int value;
	struct zte_port_private *portdata;

	portdata = usb_get_serial_port_data(port);

	value = ((portdata->rts_state) ? TIOCM_RTS : 0) |
		((portdata->dtr_state) ? TIOCM_DTR : 0) |
		((portdata->cts_state) ? TIOCM_CTS : 0) |
		((portdata->dsr_state) ? TIOCM_DSR : 0) |
		((portdata->dcd_state) ? TIOCM_CAR : 0) |
		((portdata->ri_state) ? TIOCM_RNG : 0);

	return value;
}

static int zte_tiocmset(struct tty_struct *tty, struct file *file,
			unsigned int set, unsigned int clear)
{
	struct usb_serial_port *port = tty->driver_data;
	struct zte_port_private *portdata;

	portdata = usb_get_serial_port_data(port);

	/* FIXME: what locks portdata fields ? */
	if (set & TIOCM_RTS)
		portdata->rts_state = 1;
	if (set & TIOCM_DTR)
		portdata->dtr_state = 1;

	if (clear & TIOCM_RTS)
		portdata->rts_state = 0;
	if (clear & TIOCM_DTR)
		portdata->dtr_state = 0;
	return zte_send_setup(port);
}

/* Write */
static int zte_write(struct tty_struct *tty, struct usb_serial_port *port,
			const unsigned char *buf, int count)
{
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata;
	int i;
	int left, todo;
	struct urb *this_urb = NULL; /* spurious */
	int err;
	unsigned long flags;

	portdata = usb_get_serial_port_data(port);
	intfdata = port->serial->private;

	dbg("%s: write (%d chars)", __func__, count);

	i = 0;
	left = count;
	for (i = 0; left > 0 && i < N_OUT_URB; i++) {
		todo = left;
		if (todo > OUT_BUFLEN)
			todo = OUT_BUFLEN;

		this_urb = portdata->out_urbs[i];
		if (test_and_set_bit(i, &portdata->out_busy)) {
			if (time_before(jiffies,
					portdata->tx_start_time[i] + 10 * HZ))
				continue;
			usb_unlink_urb(this_urb);
			continue;
		}
		dbg("%s: endpoint %d buf %d", __func__,
			usb_pipeendpoint(this_urb->pipe), i);

		err = usb_autopm_get_interface_async(port->serial->interface);
		if (err < 0)
			break;

		/* send the data */
		memcpy(this_urb->transfer_buffer, buf, todo);
		this_urb->transfer_buffer_length = todo;

		spin_lock_irqsave(&intfdata->susp_lock, flags);
		if (intfdata->suspended) {
			usb_anchor_urb(this_urb, &portdata->delayed);
			spin_unlock_irqrestore(&intfdata->susp_lock, flags);
		} else {
			intfdata->in_flight++;
			spin_unlock_irqrestore(&intfdata->susp_lock, flags);
			err = usb_submit_urb(this_urb, GFP_ATOMIC);
			if (err) {
				dbg("usb_submit_urb %p (write bulk) failed "
					"(%d)", this_urb, err);
				clear_bit(i, &portdata->out_busy);
				spin_lock_irqsave(&intfdata->susp_lock, flags);
				intfdata->in_flight--;
				spin_unlock_irqrestore(&intfdata->susp_lock, flags);
				continue;
			}
		}

		portdata->tx_start_time[i] = jiffies;
		buf += todo;
		left -= todo;
	}

	count -= left;
	dbg("%s: wrote (did %d)", __func__, count);
	return count;
}

static void zte_indat_callback(struct urb *urb)
{
	int err;
	int endpoint;
	struct usb_serial_port *port;
	struct tty_struct *tty;
	unsigned char *data = urb->transfer_buffer;
	int status = urb->status;

	dbg("%s: %p", __func__, urb);

	endpoint = usb_pipeendpoint(urb->pipe);
	port =  urb->context;

	if (status) {
		dbg("%s: nonzero status: %d on endpoint %02x.",
		    __func__, status, endpoint);
	} else {
		tty = tty_port_tty_get(&port->port);
		if (urb->actual_length) {
			tty_insert_flip_string(tty, data, urb->actual_length);
			tty_flip_buffer_push(tty);
		} else 
			dbg("%s: empty read urb received", __func__);
		tty_kref_put(tty);

		/* Resubmit urb so we continue receiving */
		if (status != -ESHUTDOWN) {
			err = usb_submit_urb(urb, GFP_ATOMIC);
			if (err && err != -EPERM)
				printk(KERN_ERR "%s: resubmit read urb failed. "
					"(%d)", __func__, err);
			else
				usb_mark_last_busy(port->serial->dev);
		}

	}
	return;
}

static void zte_outdat_callback(struct urb *urb)
{
	struct usb_serial_port *port;
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata;
	int i;

	dbg("%s", __func__);

	port =  urb->context;
	intfdata = port->serial->private;

	usb_serial_port_softint(port);
	usb_autopm_put_interface_async(port->serial->interface);
	portdata = usb_get_serial_port_data(port);
	spin_lock(&intfdata->susp_lock);
	intfdata->in_flight--;
	spin_unlock(&intfdata->susp_lock);

	for (i = 0; i < N_OUT_URB; ++i) {
		if (portdata->out_urbs[i] == urb) {
			smp_mb__before_clear_bit();
			clear_bit(i, &portdata->out_busy);
			break;
		}
	}
}

static void zte_instat_callback(struct urb *urb)
{
	int err;
	int status = urb->status;
	struct usb_serial_port *port =  urb->context;
	struct zte_port_private *portdata = usb_get_serial_port_data(port);

	dbg("%s", __func__);
	dbg("%s: urb %p port %p has data %p", __func__, urb, port, portdata);

	if (status == 0) {
		struct usb_ctrlrequest *req_pkt =
				(struct usb_ctrlrequest *)urb->transfer_buffer;

		if (!req_pkt) {
			dbg("%s: NULL req_pkt", __func__);
			return;
		}
		if ((req_pkt->bRequestType == 0xA1) &&
				(req_pkt->bRequest == 0x20)) {
			int old_dcd_state;
			unsigned char signals = *((unsigned char *)
					urb->transfer_buffer +
					sizeof(struct usb_ctrlrequest));

			dbg("%s: signal x%x", __func__, signals);

			old_dcd_state = portdata->dcd_state;
			portdata->cts_state = 1;
			portdata->dcd_state = ((signals & 0x01) ? 1 : 0);
			portdata->dsr_state = ((signals & 0x02) ? 1 : 0);
			portdata->ri_state = ((signals & 0x08) ? 1 : 0);

			if (old_dcd_state && !portdata->dcd_state) {
				struct tty_struct *tty =
						tty_port_tty_get(&port->port);
				if (tty && !C_CLOCAL(tty))
					tty_hangup(tty);
				tty_kref_put(tty);
			}
		} else {
			dbg("%s: type %x req %x", __func__,
				req_pkt->bRequestType, req_pkt->bRequest);
		}
	} else
		err("%s: error %d", __func__, status);

	/* Resubmit urb so we continue receiving IRQ data */
	if (status != -ESHUTDOWN && status != -ENOENT) {
		err = usb_submit_urb(urb, GFP_ATOMIC);
		if (err)
			dbg("%s: resubmit intr urb failed. (%d)",
				__func__, err);
	}
}

static int zte_write_room(struct tty_struct *tty)
{
	struct usb_serial_port *port = tty->driver_data;
	struct zte_port_private *portdata;
	int i;
	int data_len = 0;
	struct urb *this_urb;

	portdata = usb_get_serial_port_data(port);

	for (i = 0; i < N_OUT_URB; i++) {
		this_urb = portdata->out_urbs[i];
		if (this_urb && !test_bit(i, &portdata->out_busy))
			data_len += OUT_BUFLEN;
	}

	dbg("%s: %d", __func__, data_len);
	return data_len;
}

static int zte_chars_in_buffer(struct tty_struct *tty)
{
	struct usb_serial_port *port = tty->driver_data;
	struct zte_port_private *portdata;
	int i;
	int data_len = 0;
	struct urb *this_urb;

	portdata = usb_get_serial_port_data(port);

	for (i = 0; i < N_OUT_URB; i++) {
		this_urb = portdata->out_urbs[i];
		/* FIXME: This locking is insufficient as this_urb may
		   go unused during the test */
		if (this_urb && test_bit(i, &portdata->out_busy))
			data_len += this_urb->transfer_buffer_length;
	}
	dbg("%s: %d", __func__, data_len);
	return data_len;
}

static int zte_open(struct tty_struct *tty, struct usb_serial_port *port)
{
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata;
	struct usb_serial *serial = port->serial;
	int i, err;
	struct urb *urb;

	portdata = usb_get_serial_port_data(port);
	intfdata = serial->private;

	dbg("%s", __func__);

	/* Start reading from the IN endpoint */
	for (i = 0; i < N_IN_URB; i++) {
		urb = portdata->in_urbs[i];
		if (!urb)
			continue;
		err = usb_submit_urb(urb, GFP_KERNEL);
		if (err) {
			dbg("%s: submit urb %d failed (%d) %d",
				__func__, i, err,
				urb->transfer_buffer_length);
		}
	}

	zte_send_setup(port);

	serial->interface->needs_remote_wakeup = 1;
	spin_lock_irq(&intfdata->susp_lock);
	portdata->opened = 1;
	spin_unlock_irq(&intfdata->susp_lock);
	usb_autopm_put_interface(serial->interface);

	return 0;
}

static void zte_dtr_rts(struct usb_serial_port *port, int on)
{
	struct usb_serial *serial = port->serial;
	struct zte_port_private *portdata;

	dbg("%s", __func__);
	portdata = usb_get_serial_port_data(port);
	mutex_lock(&serial->disc_mutex);
	portdata->rts_state = on;
	portdata->dtr_state = on;
	if (serial->dev)
		zte_send_setup(port);
	mutex_unlock(&serial->disc_mutex);
}


static void zte_close(struct usb_serial_port *port)
{
	int i;
	struct usb_serial *serial = port->serial;
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata = port->serial->private;

	dbg("%s", __func__);
	portdata = usb_get_serial_port_data(port);

	if (serial->dev) {
		/* Stop reading/writing urbs */
		spin_lock_irq(&intfdata->susp_lock);
		portdata->opened = 0;
		spin_unlock_irq(&intfdata->susp_lock);

		for (i = 0; i < N_IN_URB; i++)
			usb_kill_urb(portdata->in_urbs[i]);
		for (i = 0; i < N_OUT_URB; i++)
			usb_kill_urb(portdata->out_urbs[i]);
		usb_autopm_get_interface(serial->interface);
		serial->interface->needs_remote_wakeup = 0;
	}
}

/* Helper functions used by zte_setup_urbs */
static struct urb *zte_setup_urb(struct usb_serial *serial, int endpoint,
		int dir, void *ctx, char *buf, int len,
		void (*callback)(struct urb *))
{
	struct urb *urb;

	if (endpoint == -1)
		return NULL;		/* endpoint not needed */

	urb = usb_alloc_urb(0, GFP_KERNEL);		/* No ISO */
	if (urb == NULL) {
		dbg("%s: alloc for endpoint %d failed.", __func__, endpoint);
		return NULL;
	}

		/* Fill URB using supplied data. */
	usb_fill_bulk_urb(urb, serial->dev,
		      usb_sndbulkpipe(serial->dev, endpoint) | dir,
		      buf, len, callback, ctx);

	return urb;
}

/* Setup urbs */
static void zte_setup_urbs(struct usb_serial *serial)
{
	int i, j;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;

	dbg("%s", __func__);

	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);

		/* Do indat endpoints first */
		for (j = 0; j < N_IN_URB; ++j) {
			portdata->in_urbs[j] = zte_setup_urb(serial,
					port->bulk_in_endpointAddress,
					USB_DIR_IN, port,
					portdata->in_buffer[j],
					IN_BUFLEN, zte_indat_callback);
		}

		/* outdat endpoints */
		for (j = 0; j < N_OUT_URB; ++j) {
			portdata->out_urbs[j] = zte_setup_urb(serial,
					port->bulk_out_endpointAddress,
					USB_DIR_OUT, port,
					portdata->out_buffer[j],
					OUT_BUFLEN, zte_outdat_callback);
		}
	}
}


/** send RTS/DTR state to the port.
 *
 * This is exactly the same as SET_CONTROL_LINE_STATE from the PSTN
 * CDC.
*/
static int zte_send_setup(struct usb_serial_port *port)
{
	struct usb_serial *serial = port->serial;
	struct zte_intf_private *intfdata =
		(struct zte_intf_private *) serial->private;
	struct zte_port_private *portdata;
	int ifNum = serial->interface->cur_altsetting->desc.bInterfaceNumber;
	int val = 0;
	dbg("%s", __func__);

	if (is_blacklisted(ifNum, intfdata->blacklist_info) ==
						zte_BLACKLIST_SENDSETUP) {
		dbg("No send_setup on blacklisted interface #%d\n", ifNum);
		return -EIO;
	}

	portdata = usb_get_serial_port_data(port);

	if (portdata->dtr_state)
		val |= 0x01;
	if (portdata->rts_state)
		val |= 0x02;

	return usb_control_msg(serial->dev,
		usb_rcvctrlpipe(serial->dev, 0),
		0x22, 0x21, val, ifNum, NULL, 0, USB_CTRL_SET_TIMEOUT);
}

static int zte_startup(struct usb_serial *serial)
{
	int i, j, err;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;
	u8 *buffer;

	dbg("%s", __func__);

	/* Now setup per port private data */
	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		portdata = kzalloc(sizeof(*portdata), GFP_KERNEL);
		if (!portdata) {
			dbg("%s: kmalloc for zte_port_private (%d) failed!.",
					__func__, i);
			return 1;
		}
		init_usb_anchor(&portdata->delayed);

		for (j = 0; j < N_IN_URB; j++) {
			buffer = (u8 *)__get_free_page(GFP_KERNEL);
			if (!buffer)
				goto bail_out_error;
			portdata->in_buffer[j] = buffer;
		}

		for (j = 0; j < N_OUT_URB; j++) {
			buffer = kmalloc(OUT_BUFLEN, GFP_KERNEL);
			if (!buffer)
				goto bail_out_error2;
			portdata->out_buffer[j] = buffer;
		}

		usb_set_serial_port_data(port, portdata);

		if (!port->interrupt_in_urb)
			continue;
		err = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);
		if (err)
			dbg("%s: submit irq_in urb failed %d",
				__func__, err);
	}
	zte_setup_urbs(serial);
	return 0;

bail_out_error2:
	for (j = 0; j < N_OUT_URB; j++)
		kfree(portdata->out_buffer[j]);
bail_out_error:
	for (j = 0; j < N_IN_URB; j++)
		if (portdata->in_buffer[j])
			free_page((unsigned long)portdata->in_buffer[j]);
	kfree(portdata);
	return 1;
}

static void stop_read_write_urbs(struct usb_serial *serial)
{
	int i, j;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;

	/* Stop reading/writing urbs */
	for (i = 0; i < serial->num_ports; ++i) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);
		for (j = 0; j < N_IN_URB; j++)
			usb_kill_urb(portdata->in_urbs[j]);
		for (j = 0; j < N_OUT_URB; j++)
			usb_kill_urb(portdata->out_urbs[j]);
	}
}

static void zte_disconnect(struct usb_serial *serial)
{
	dbg("%s", __func__);

	stop_read_write_urbs(serial);
}

static void zte_release(struct usb_serial *serial)
{
	int i, j;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;

	dbg("%s", __func__);

	/* Now free them */
	for (i = 0; i < serial->num_ports; ++i) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);

		for (j = 0; j < N_IN_URB; j++) {
			if (portdata->in_urbs[j]) {
				usb_free_urb(portdata->in_urbs[j]);
				free_page((unsigned long)
					portdata->in_buffer[j]);
				portdata->in_urbs[j] = NULL;
			}
		}
		for (j = 0; j < N_OUT_URB; j++) {
			if (portdata->out_urbs[j]) {
				usb_free_urb(portdata->out_urbs[j]);
				kfree(portdata->out_buffer[j]);
				portdata->out_urbs[j] = NULL;
			}
		}
	}

	/* Now free per port private data */
	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];

		kfree(usb_get_serial_port_data(port));
	}
}


#ifdef CONFIG_PM
static int zte_suspend(struct usb_serial *serial, pm_message_t message)
{
	struct zte_intf_private *intfdata = serial->private;
	int b;

	dbg("%s entered", __func__);

	if (message.event & PM_EVENT_AUTO) {
		spin_lock_irq(&intfdata->susp_lock);
		b = intfdata->in_flight;
		spin_unlock_irq(&intfdata->susp_lock);

		if (b)
			return -EBUSY;
	}

	spin_lock_irq(&intfdata->susp_lock);
	intfdata->suspended = 1;
	spin_unlock_irq(&intfdata->susp_lock);
	stop_read_write_urbs(serial);

	return 0;
}

static void play_delayed(struct usb_serial_port *port)
{
	struct zte_intf_private *data;
	struct zte_port_private *portdata;
	struct urb *urb;
	int err;

	portdata = usb_get_serial_port_data(port);
	data = port->serial->private;
	while ((urb = usb_get_from_anchor(&portdata->delayed))) {
		err = usb_submit_urb(urb, GFP_ATOMIC);
		if (!err)
			data->in_flight++;
	}
}

static int zte_resume(struct usb_serial *serial)
{
	int i, j;
	struct usb_serial_port *port;
	struct zte_intf_private *intfdata = serial->private;
	struct zte_port_private *portdata;
	struct urb *urb;
	int err = 0;

	dbg("%s entered", __func__);
	/* get the interrupt URBs resubmitted unconditionally */
	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		if (!port->interrupt_in_urb) {
			dbg("%s: No interrupt URB for port %d", __func__, i);
			continue;
		}
		err = usb_submit_urb(port->interrupt_in_urb, GFP_NOIO);
		dbg("Submitted interrupt URB for port %d (result %d)", i, err);
		if (err < 0) {
			err("%s: Error %d for interrupt URB of port%d",
				 __func__, err, i);
			goto err_out;
		}
	}

	for (i = 0; i < serial->num_ports; i++) {
		/* walk all ports */
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);

		/* skip closed ports */
		spin_lock_irq(&intfdata->susp_lock);
		if (!portdata->opened) {
			spin_unlock_irq(&intfdata->susp_lock);
			continue;
		}

		for (j = 0; j < N_IN_URB; j++) {
			urb = portdata->in_urbs[j];
			err = usb_submit_urb(urb, GFP_ATOMIC);
			if (err < 0) {
				err("%s: Error %d for bulk URB %d",
					 __func__, err, i);
				spin_unlock_irq(&intfdata->susp_lock);
				goto err_out;
			}
		}
		play_delayed(port);
		spin_unlock_irq(&intfdata->susp_lock);
	}
	spin_lock_irq(&intfdata->susp_lock);
	intfdata->suspended = 0;
	spin_unlock_irq(&intfdata->susp_lock);
err_out:
	return err;
}
#endif

MODULE_AUTHOR(DRIVER_AUTHOR);
MODULE_DESCRIPTION(DRIVER_DESC);
MODULE_VERSION(DRIVER_VERSION);
MODULE_LICENSE("GPL");

module_param(debug, bool, S_IRUGO | S_IWUSR);
MODULE_PARM_DESC(debug, "Debug messages");


#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)//use 2.6.35, 2.6.36  and 2.6.37sourcecode

#include <linux/kernel.h>
#include <linux/jiffies.h>
#include <linux/errno.h>
#include <linux/tty.h>
#include <linux/tty_flip.h>
#include <linux/slab.h>
#include <linux/module.h>
#include <linux/bitops.h>
#include <linux/usb.h>
#include <linux/usb/serial.h>
#include "2638/usb-wwan.h"


/* Function prototypes */
static int  zte_probe(struct usb_serial *serial,
			const struct usb_device_id *id);
static int zte_send_setup(struct usb_serial_port *port);
static void zte_instat_callback(struct urb *urb);

/* Vendor and product IDs */
/* zte PRODUCTS */
#define zte_VENDOR_ID				0x19d2

/* some devices interfaces need special handling due to a number of reasons */
enum zte_blacklist_reason {
		zte_BLACKLIST_NONE = 0,
		zte_BLACKLIST_SENDSETUP = 1,
		zte_BLACKLIST_RESERVED_IF = 2
};

struct zte_blacklist_info {
	const u32 infolen;	/* number of interface numbers on blacklist */
	const u8  *ifaceinfo;	/* pointer to the array holding the numbers */
	enum zte_blacklist_reason reason;
};

static const u8 four_g_w14_no_sendsetup[] = { 0, 1 };
static const struct zte_blacklist_info four_g_w14_blacklist = {
	.infolen = ARRAY_SIZE(four_g_w14_no_sendsetup),
	.ifaceinfo = four_g_w14_no_sendsetup,
	.reason = zte_BLACKLIST_SENDSETUP
};


static const struct usb_device_id zte_ids[] = {
	   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0001, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0002, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0003, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0004, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0005, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0006, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0007, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0008, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0009, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0010, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0011, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0012, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0013, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0014, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0015, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0016, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0017, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0018, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0019, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0020, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0021, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0022, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0023, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0024, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0025, 0xff, 0xff, 0xff) },
    //   { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0026, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0027, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0028, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0029, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0030, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0031, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0032, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0033, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0034, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0035, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0036, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0037, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0038, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0039, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0040, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0041, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0042, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0043, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0044, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0045, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0046, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0047, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0048, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0049, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0050, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0051, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0052, 0xff, 0xff, 0xff) },
    //   { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0053, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0054, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0055, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0056, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0057, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0058, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0059, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0060, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0061, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0062, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0063, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0064, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0065, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0066, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0067, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0068, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0069, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0070, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0071, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0072, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0073, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0074, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0075, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0076, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0077, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0078, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0079, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0080, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0081, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0082, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0083, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0084, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0085, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0086, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0087, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0088, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0089, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0090, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0091, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0092, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0093, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0094, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0095, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0096, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0097, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0098, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0099, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0104, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0105, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0106, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0108, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0117, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0118, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0121, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0122, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0123, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0124, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0125, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0126, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0128, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0130, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0133, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0141, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0144, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0145, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0147, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0148, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0151, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0152, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0153, 0xff, 0xff, 0xff) },
    //{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0154, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0155, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0156, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0157, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0158, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0159, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0160, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0161, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0162, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0164, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0165, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0168, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0170, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0176, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0178, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1008, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1010, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1012, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1057, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1058, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1059, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1060, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1061, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1062, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1063, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1064, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1065, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1066, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1067, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1068, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1069, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1070, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1071, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1072, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1073, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1074, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1075, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1076, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1077, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1078, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1079, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1080, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1081, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1082, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1083, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1084, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1085, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1086, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1087, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1088, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1089, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1090, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1091, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1092, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1093, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1094, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1095, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1096, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1097, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1098, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1099, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1100, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1101, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1102, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1103, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1104, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1105, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1106, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1107, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1108, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1109, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1110, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1111, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1112, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1113, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1114, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1115, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1116, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1117, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1118, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1119, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1120, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1121, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1122, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1123, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1124, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1125, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1126, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1127, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1128, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1129, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1130, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1131, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1132, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1133, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1134, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1135, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1136, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1137, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1138, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1139, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1140, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1141, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1142, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1143, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1144, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1145, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1146, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1147, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1148, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1149, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1150, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1151, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1152, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1153, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1154, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1155, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1156, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1157, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1158, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1159, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1160, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1161, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1162, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1163, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1164, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1165, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1166, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1167, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1168, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1169, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1170, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1244, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1245, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1246, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1247, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1248, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1249, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1250, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1251, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1252, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1253, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1254, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1255, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1256, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1257, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1258, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1259, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1260, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1261, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1262, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1263, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1264, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1265, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1266, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1267, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1268, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1269, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1270, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1271, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1272, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1273, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1274, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1275, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1276, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1277, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1278, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1279, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1280, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1281, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1282, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1283, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1284, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1285, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1286, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1287, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1288, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1289, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1290, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1291, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1292, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1293, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1294, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1295, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1296, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1297, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1298, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1299, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1300, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1401, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1402, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1403, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1404, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1405, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1406, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1407, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1408, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1409, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1410, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1411, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1412, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1413, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1414, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1415, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1416, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1417, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1418, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1419, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1420, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1421, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1422, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1423, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1424, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1425, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1426, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1427, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1428, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1429, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1430, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1431, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1432, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1433, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1434, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1435, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1436, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1437, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1438, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1439, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1440, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1441, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1442, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1443, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1444, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1445, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1446, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1447, 0xff, 0xff, 0xff) },  

    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1448, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1449, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1450, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1451, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1452, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1453, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1454, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1455, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1456, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1457, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1458, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1459, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1460, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1461, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1462, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1463, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1464, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1465, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1466, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1467, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1468, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1469, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1470, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1471, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1472, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1473, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1474, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1475, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1476, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1477, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1478, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1479, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1480, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1481, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1482, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1483, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1484, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1485, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1486, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1487, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1488, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1489, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1490, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1491, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1492, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1493, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1494, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1495, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1496, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1497, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1498, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1499, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1500, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1501, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1502, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1503, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1504, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1505, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1506, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1507, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1508, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1509, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1510, 0xff, 0xff, 0xff) },       
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x2002, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x2003, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0xFFEC, 0xff, 0xff, 0xff) },
    { ZTE_USB_DEVICE_ID_MATCH_INT_CLASS_AND_SUBCLASS_INFO(0x19d2,0xff,0x86) },
    { ZTE_USB_DEVICE_ID_MATCH_INT_CLASS_AND_SUBCLASS_INFO(0x19d2,0xff,0x02) },
	
    { USB_DEVICE_AND_INTERFACE_INFO(TPLink_VENDOR_ID, 0x7E11, 0xff, 0xff, 0xff) },/*TPLink*/
    { USB_DEVICE_AND_INTERFACE_INFO(QUALCOMM_VENDOR_ID, 0x9001, 0xff, 0xff, 0xff) },/*QUALCOMM_VENDOR_ID*/
    { USB_DEVICE_AND_INTERFACE_INFO(QUALCOMM_VENDOR_ID, 0x9002, 0xff, 0xff, 0xff) },

	{ } /* Terminating entry */
};
MODULE_DEVICE_TABLE(usb, zte_ids);

static struct usb_driver zte_driver = {
	.name       = "zte",
	.probe      = usb_serial_probe,
	.disconnect = usb_serial_disconnect,
#ifdef CONFIG_PM
	.suspend    = usb_serial_suspend,
	.resume     = usb_serial_resume,
	.supports_autosuspend =	1,
#endif
	.id_table   = zte_ids,
	.no_dynamic_id = 	1,
};

/* The card has three separate interfaces, which the serial driver
 * recognizes separately, thus num_port=1.
 */

static struct usb_serial_driver zte_1port_device = {
	.driver = {
		.owner =	THIS_MODULE,
		.name =		"zte1",
	},
	.description       = "GSM modem (1-port)",
	.usb_driver        = &zte_driver,
	.id_table          = zte_ids,
	.num_ports         = 1,
	.probe             = zte_probe,
	.open              = usb_wwan_open,
	.close             = usb_wwan_close,
	.dtr_rts	   = usb_wwan_dtr_rts,
	.write             = usb_wwan_write,
	.write_room        = usb_wwan_write_room,
	.chars_in_buffer   = usb_wwan_chars_in_buffer,
	.set_termios       = usb_wwan_set_termios,
	.tiocmget          = usb_wwan_tiocmget,
	.tiocmset          = usb_wwan_tiocmset,
	.attach            = usb_wwan_startup,
	.disconnect        = usb_wwan_disconnect,
	.release           = usb_wwan_release,
	.read_int_callback = zte_instat_callback,
#ifdef CONFIG_PM
	.suspend           = usb_wwan_suspend,
	.resume            = usb_wwan_resume,
#endif
};

static int debug;

/* per port private data */

#define N_IN_URB 4
#define N_OUT_URB 4
#define IN_BUFLEN 4096
#define OUT_BUFLEN 4096

struct zte_port_private {
	/* Input endpoints and buffer for this port */
	struct urb *in_urbs[N_IN_URB];
	u8 *in_buffer[N_IN_URB];
	/* Output endpoints and buffer for this port */
	struct urb *out_urbs[N_OUT_URB];
	u8 *out_buffer[N_OUT_URB];
	unsigned long out_busy;		/* Bit vector of URBs in use */
	int opened;
	struct usb_anchor delayed;

	/* Settings for the port */
	int rts_state;	/* Handshaking pins (outputs) */
	int dtr_state;
	int cts_state;	/* Handshaking pins (inputs) */
	int dsr_state;
	int dcd_state;
	int ri_state;

	unsigned long tx_start_time[N_OUT_URB];
};

/* Functions used by new usb-serial code. */
static int __init zte_init(void)
{
	int retval;
	retval = usb_serial_register(&zte_1port_device);
	if (retval)
		goto failed_1port_device_register;
	retval = usb_register(&zte_driver);
	if (retval)
		goto failed_driver_register;

	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
	       DRIVER_DESC "\n");

	return 0;

failed_driver_register:
	usb_serial_deregister(&zte_1port_device);
failed_1port_device_register:
	return retval;
}

static void __exit zte_exit(void)
{
	usb_deregister(&zte_driver);
	usb_serial_deregister(&zte_1port_device);
}

module_init(zte_init);
module_exit(zte_exit);

static int zte_probe(struct usb_serial *serial,
			const struct usb_device_id *id)
{
	struct usb_wwan_intf_private *data;
	/* D-Link DWM 652 still exposes CD-Rom emulation interface in modem mode */
	/*if (serial->dev->descriptor.idVendor == DLINK_VENDOR_ID &&
		serial->dev->descriptor.idProduct == DLINK_PRODUCT_DWM_652 &&
		serial->interface->cur_altsetting->desc.bInterfaceClass == 0x8)
		return -ENODEV;*/

	/* Bandrich modem and AT command interface is 0xff */
	/*if ((serial->dev->descriptor.idVendor == BANDRICH_VENDOR_ID ||
		serial->dev->descriptor.idVendor == PIRELLI_VENDOR_ID) &&
		serial->interface->cur_altsetting->desc.bInterfaceClass != 0xff)
		return -ENODEV;*/

	data = serial->private = kzalloc(sizeof(struct usb_wwan_intf_private), GFP_KERNEL);

	if (!data)
		return -ENOMEM;
	data->send_setup = zte_send_setup;
	spin_lock_init(&data->susp_lock);
	data->private = (void *)id->driver_info;
	return 0;
}

static enum zte_blacklist_reason is_blacklisted(const u8 ifnum,
				const struct zte_blacklist_info *blacklist)
{
	const u8  *info;
	int i;

	if (blacklist) {
		info = blacklist->ifaceinfo;

		for (i = 0; i < blacklist->infolen; i++) {
			if (info[i] == ifnum)
				return blacklist->reason;
		}
	}
	return zte_BLACKLIST_NONE;
}

static void zte_instat_callback(struct urb *urb)
{
	int err;
	int status = urb->status;
	struct usb_serial_port *port =  urb->context;
	struct zte_port_private *portdata = usb_get_serial_port_data(port);

	dbg("%s", __func__);
	dbg("%s: urb %p port %p has data %p", __func__, urb, port, portdata);

	if (status == 0) {
		struct usb_ctrlrequest *req_pkt =
				(struct usb_ctrlrequest *)urb->transfer_buffer;

		if (!req_pkt) {
			dbg("%s: NULL req_pkt", __func__);
			return;
		}
		if ((req_pkt->bRequestType == 0xA1) &&
				(req_pkt->bRequest == 0x20)) {
			int old_dcd_state;
			unsigned char signals = *((unsigned char *)
					urb->transfer_buffer +
					sizeof(struct usb_ctrlrequest));

			dbg("%s: signal x%x", __func__, signals);

			old_dcd_state = portdata->dcd_state;
			portdata->cts_state = 1;
			portdata->dcd_state = ((signals & 0x01) ? 1 : 0);
			portdata->dsr_state = ((signals & 0x02) ? 1 : 0);
			portdata->ri_state = ((signals & 0x08) ? 1 : 0);

			if (old_dcd_state && !portdata->dcd_state) {
				struct tty_struct *tty =
						tty_port_tty_get(&port->port);
				if (tty && !C_CLOCAL(tty))
					tty_hangup(tty);
				tty_kref_put(tty);
			}
		} else {
			dbg("%s: type %x req %x", __func__,
				req_pkt->bRequestType, req_pkt->bRequest);
		}
	} else
		err("%s: error %d", __func__, status);

	/* Resubmit urb so we continue receiving IRQ data */
	if (status != -ESHUTDOWN && status != -ENOENT) {
		err = usb_submit_urb(urb, GFP_ATOMIC);
		if (err)
			dbg("%s: resubmit intr urb failed. (%d)",
				__func__, err);
	}
}



/** send RTS/DTR state to the port.
 *
 * This is exactly the same as SET_CONTROL_LINE_STATE from the PSTN
 * CDC.
*/
static int zte_send_setup(struct usb_serial_port *port)
{
	struct usb_serial *serial = port->serial;
	struct usb_wwan_intf_private *intfdata =
		(struct usb_wwan_intf_private *) serial->private;
	struct zte_port_private *portdata;
	int ifNum = serial->interface->cur_altsetting->desc.bInterfaceNumber;
	int val = 0;
	dbg("%s", __func__);

	if (is_blacklisted(ifNum,
			   (struct zte_blacklist_info *) intfdata->private)
	    == zte_BLACKLIST_SENDSETUP) {
		dbg("No send_setup on blacklisted interface #%d\n", ifNum);
		return -EIO;
	}

	portdata = usb_get_serial_port_data(port);

	if (portdata->dtr_state)
		val |= 0x01;
	if (portdata->rts_state)
		val |= 0x02;

	return usb_control_msg(serial->dev,
		usb_rcvctrlpipe(serial->dev, 0),
		0x22, 0x21, val, ifNum, NULL, 0, USB_CTRL_SET_TIMEOUT);
}

MODULE_AUTHOR(DRIVER_AUTHOR);
MODULE_DESCRIPTION(DRIVER_DESC);
MODULE_VERSION(DRIVER_VERSION);
MODULE_LICENSE("GPL");

module_param(debug, bool, S_IRUGO | S_IWUSR);
MODULE_PARM_DESC(debug, "Debug messages");


#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,39)//use  2.6.38 sourcecode
#include <linux/kernel.h>
#include <linux/jiffies.h>
#include <linux/errno.h>
#include <linux/tty.h>
#include <linux/tty_flip.h>
#include <linux/slab.h>
#include <linux/module.h>
#include <linux/bitops.h>
#include <linux/usb.h>
#include <linux/usb/serial.h>
#include "2638/usb-wwan.h"

/* Function prototypes */
static int  zte_probe(struct usb_serial *serial,
			const struct usb_device_id *id);
static int zte_send_setup(struct usb_serial_port *port);
static void zte_instat_callback(struct urb *urb);

/* Vendor and product IDs */
/* zte PRODUCTS */
#define zte_VENDOR_ID				0x19d2

/* some devices interfaces need special handling due to a number of reasons */
enum zte_blacklist_reason {
		zte_BLACKLIST_NONE = 0,
		zte_BLACKLIST_SENDSETUP = 1,
		zte_BLACKLIST_RESERVED_IF = 2
};

struct zte_blacklist_info {
	const u32 infolen;	/* number of interface numbers on blacklist */
	const u8  *ifaceinfo;	/* pointer to the array holding the numbers */
	enum zte_blacklist_reason reason;
};

static const u8 four_g_w14_no_sendsetup[] = { 0, 1 };
static const struct zte_blacklist_info four_g_w14_blacklist = {
	.infolen = ARRAY_SIZE(four_g_w14_no_sendsetup),
	.ifaceinfo = four_g_w14_no_sendsetup,
	.reason = zte_BLACKLIST_SENDSETUP
};


static const struct usb_device_id zte_ids[] = {
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0001, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0002, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0003, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0004, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0005, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0006, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0007, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0008, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0009, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0010, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0011, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0012, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0013, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0014, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0015, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0016, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0017, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0018, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0019, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0020, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0021, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0022, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0023, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0024, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0025, 0xff, 0xff, 0xff) },
    //   { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0026, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0027, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0028, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0029, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0030, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0031, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0032, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0033, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0034, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0035, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0036, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0037, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0038, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0039, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0040, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0041, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0042, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0043, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0044, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0045, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0046, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0047, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0048, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0049, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0050, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0051, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0052, 0xff, 0xff, 0xff) },
    //   { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0053, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0054, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0055, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0056, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0057, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0058, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0059, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0060, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0061, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0062, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0063, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0064, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0065, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0066, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0067, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0068, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0069, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0070, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0071, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0072, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0073, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0074, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0075, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0076, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0077, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0078, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0079, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0080, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0081, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0082, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0083, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0084, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0085, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0086, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0087, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0088, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0089, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0090, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0091, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0092, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0093, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0094, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0095, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0096, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0097, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0098, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0099, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0104, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0105, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0106, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0108, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0117, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0118, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0121, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0122, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0123, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0124, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0125, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0126, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0128, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0130, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0133, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0135, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0136, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0137, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0139, 0xff, 0xff, 0xff) }, 	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0141, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0144, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0145, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0147, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0148, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0151, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0152, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0153, 0xff, 0xff, 0xff) },
    //{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0154, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0155, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0156, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0157, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0158, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0159, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0160, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0161, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0162, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0164, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0165, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0167, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0168, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0170, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0176, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0178, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0189, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0191, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0196, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0197, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0199, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0200, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0201, 0xff, 0xff, 0xff) },		
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0254, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0257, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0265, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0284, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0317, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0330, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0395, 0xff, 0xff, 0xff) },      
 	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0414, 0xff, 0xff, 0xff) },   
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0417, 0xff, 0xff, 0xff) },

    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1008, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1010, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1012, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1018, 0xff, 0xff, 0xff) },		
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1057, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1058, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1059, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1060, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1061, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1062, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1063, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1064, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1065, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1066, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1067, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1068, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1069, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1070, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1071, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1072, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1073, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1074, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1075, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1076, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1077, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1078, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1079, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1080, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1081, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1082, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1083, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1084, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1085, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1086, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1087, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1088, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1089, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1090, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1091, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1092, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1093, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1094, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1095, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1096, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1097, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1098, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1099, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1100, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1101, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1102, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1103, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1104, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1105, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1106, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1107, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1108, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1109, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1110, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1111, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1112, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1113, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1114, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1115, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1116, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1117, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1118, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1119, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1120, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1121, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1122, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1123, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1124, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1125, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1126, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1127, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1128, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1129, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1130, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1131, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1132, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1133, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1134, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1135, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1136, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1137, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1138, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1139, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1140, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1141, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1142, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1143, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1144, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1145, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1146, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1147, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1148, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1149, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1150, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1151, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1152, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1153, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1154, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1155, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1156, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1157, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1158, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1159, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1160, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1161, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1162, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1163, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1164, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1165, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1166, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1167, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1168, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1169, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1170, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1244, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1245, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1246, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1247, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1248, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1249, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1250, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1251, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1252, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1253, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1254, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1255, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1256, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1257, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1258, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1259, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1260, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1261, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1262, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1263, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1264, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1265, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1266, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1267, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1268, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1269, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1270, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1271, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1272, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1273, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1274, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1275, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1276, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1277, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1278, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1279, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1280, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1281, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1282, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1283, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1284, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1285, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1286, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1287, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1288, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1289, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1290, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1291, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1292, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1293, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1294, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1295, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1296, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1297, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1298, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1299, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1300, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1301, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1302, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1303, 0xff, 0xff, 0xff) },	
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1333, 0xff, 0xff, 0xff) },	
	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1401, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1402, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1403, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1404, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1405, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1406, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1407, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1408, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1409, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1410, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1411, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1412, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1413, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1414, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1415, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1416, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1417, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1418, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1419, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1420, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1421, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1422, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1423, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1424, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1425, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1426, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1427, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1428, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1429, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1430, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1431, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1432, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1433, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1434, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1435, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1436, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1437, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1438, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1439, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1440, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1441, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1442, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1443, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1444, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1445, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1446, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1447, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1448, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1449, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1450, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1451, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1452, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1453, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1454, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1455, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1456, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1457, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1458, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1459, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1460, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1461, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1462, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1463, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1464, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1465, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1466, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1467, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1468, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1469, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1470, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1471, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1472, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1473, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1474, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1475, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1476, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1477, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1478, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1479, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1480, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1481, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1482, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1483, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1484, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1485, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1486, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1487, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1488, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1489, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1490, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1491, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1492, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1493, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1494, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1495, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1496, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1497, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1498, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1499, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1500, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1501, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1502, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1503, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1504, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1505, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1506, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1507, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1508, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1509, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1510, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1533, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1534, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1535, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1545, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1546, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1547, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1565, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1566, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1567, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1589, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1590, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1591, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1592, 0xff, 0xff, 0xff) }, 	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1594, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1596, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1598, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1600, 0xff, 0xff, 0xff) },  	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x2002, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x2003, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0xFFEC, 0xff, 0xff, 0xff) },
    { ZTE_USB_DEVICE_ID_MATCH_INT_CLASS_AND_SUBCLASS_INFO(0x19d2,0xff,0x86) },
    { ZTE_USB_DEVICE_ID_MATCH_INT_CLASS_AND_SUBCLASS_INFO(0x19d2,0xff,0x02) },
    { USB_DEVICE_AND_INTERFACE_INFO(TPLink_VENDOR_ID, 0x7E11, 0xff, 0xff, 0xff) },/*TPLink*/
    { USB_DEVICE_AND_INTERFACE_INFO(QUALCOMM_VENDOR_ID, 0x9001, 0xff, 0xff, 0xff) },/*QUALCOMM_VENDOR_ID*/
    { USB_DEVICE_AND_INTERFACE_INFO(QUALCOMM_VENDOR_ID, 0x9002, 0xff, 0xff, 0xff) },
	{ } /* Terminating entry */
};
MODULE_DEVICE_TABLE(usb, zte_ids);

static struct usb_driver zte_driver = {
	.name       = "zte",
	.probe      = usb_serial_probe,
	.disconnect = usb_serial_disconnect,
#ifdef CONFIG_PM
	.suspend    = usb_serial_suspend,
	.resume     = usb_serial_resume,
	.supports_autosuspend =	1,
#endif
	.id_table   = zte_ids,
	.no_dynamic_id = 	1,
};

/* The card has three separate interfaces, which the serial driver
 * recognizes separately, thus num_port=1.
 */

static struct usb_serial_driver zte_1port_device = {
	.driver = {
		.owner =	THIS_MODULE,
		.name =		"zte1",
	},
	.description       = "GSM modem (1-port)",
	.usb_driver        = &zte_driver,
	.id_table          = zte_ids,
	.num_ports         = 1,
	.probe             = zte_probe,
	.open              = usb_wwan_open,
	.close             = usb_wwan_close,
	.dtr_rts	   = usb_wwan_dtr_rts,
	.write             = usb_wwan_write,
	.write_room        = usb_wwan_write_room,
	.chars_in_buffer   = usb_wwan_chars_in_buffer,
	.set_termios       = usb_wwan_set_termios,
	.tiocmget          = usb_wwan_tiocmget,
	.tiocmset          = usb_wwan_tiocmset,
	.ioctl             = usb_wwan_ioctl,
	.attach            = usb_wwan_startup,
	.disconnect        = usb_wwan_disconnect,
	.release           = usb_wwan_release,
	.read_int_callback = zte_instat_callback,
#ifdef CONFIG_PM
	.suspend           = usb_wwan_suspend,
	.resume            = usb_wwan_resume,
#endif
};

static int debug;

/* per port private data */

#define N_IN_URB 4
#define N_OUT_URB 4
#define IN_BUFLEN 4096
#define OUT_BUFLEN 4096

struct zte_port_private {
	/* Input endpoints and buffer for this port */
	struct urb *in_urbs[N_IN_URB];
	u8 *in_buffer[N_IN_URB];
	/* Output endpoints and buffer for this port */
	struct urb *out_urbs[N_OUT_URB];
	u8 *out_buffer[N_OUT_URB];
	unsigned long out_busy;		/* Bit vector of URBs in use */
	int opened;
	struct usb_anchor delayed;

	/* Settings for the port */
	int rts_state;	/* Handshaking pins (outputs) */
	int dtr_state;
	int cts_state;	/* Handshaking pins (inputs) */
	int dsr_state;
	int dcd_state;
	int ri_state;

	unsigned long tx_start_time[N_OUT_URB];
};

/* Functions used by new usb-serial code. */
static int __init zte_init(void)
{
	int retval;
	retval = usb_serial_register(&zte_1port_device);
	if (retval)
		goto failed_1port_device_register;
	retval = usb_register(&zte_driver);
	if (retval)
		goto failed_driver_register;

	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
	       DRIVER_DESC "\n");

	return 0;

failed_driver_register:
	usb_serial_deregister(&zte_1port_device);
failed_1port_device_register:
	return retval;
}

static void __exit zte_exit(void)
{
	usb_deregister(&zte_driver);
	usb_serial_deregister(&zte_1port_device);
}

module_init(zte_init);
module_exit(zte_exit);

static int zte_probe(struct usb_serial *serial,
			const struct usb_device_id *id)
{
	struct usb_wwan_intf_private *data;
	/* D-Link DWM 652 still exposes CD-Rom emulation interface in modem mode */
	/*if (serial->dev->descriptor.idVendor == DLINK_VENDOR_ID &&
		serial->dev->descriptor.idProduct == DLINK_PRODUCT_DWM_652 &&
		serial->interface->cur_altsetting->desc.bInterfaceClass == 0x8)
		return -ENODEV;*/

	/* Bandrich modem and AT command interface is 0xff */
	/*if ((serial->dev->descriptor.idVendor == BANDRICH_VENDOR_ID ||
		serial->dev->descriptor.idVendor == PIRELLI_VENDOR_ID) &&
		serial->interface->cur_altsetting->desc.bInterfaceClass != 0xff)
		return -ENODEV;*/

	data = serial->private = kzalloc(sizeof(struct usb_wwan_intf_private), GFP_KERNEL);

	if (!data)
		return -ENOMEM;
	data->send_setup = zte_send_setup;
	spin_lock_init(&data->susp_lock);
	data->private = (void *)id->driver_info;
	return 0;
}

static enum zte_blacklist_reason is_blacklisted(const u8 ifnum,
				const struct zte_blacklist_info *blacklist)
{
	const u8  *info;
	int i;

	if (blacklist) {
		info = blacklist->ifaceinfo;

		for (i = 0; i < blacklist->infolen; i++) {
			if (info[i] == ifnum)
				return blacklist->reason;
		}
	}
	return zte_BLACKLIST_NONE;
}

static void zte_instat_callback(struct urb *urb)
{
	int err;
	int status = urb->status;
	struct usb_serial_port *port =  urb->context;
	struct zte_port_private *portdata = usb_get_serial_port_data(port);

	dbg("%s", __func__);
	dbg("%s: urb %p port %p has data %p", __func__, urb, port, portdata);

	if (status == 0) {
		struct usb_ctrlrequest *req_pkt =
				(struct usb_ctrlrequest *)urb->transfer_buffer;

		if (!req_pkt) {
			dbg("%s: NULL req_pkt", __func__);
			return;
		}
		if ((req_pkt->bRequestType == 0xA1) &&
				(req_pkt->bRequest == 0x20)) {
			int old_dcd_state;
			unsigned char signals = *((unsigned char *)
					urb->transfer_buffer +
					sizeof(struct usb_ctrlrequest));

			dbg("%s: signal x%x", __func__, signals);

			old_dcd_state = portdata->dcd_state;
			portdata->cts_state = 1;
			portdata->dcd_state = ((signals & 0x01) ? 1 : 0);
			portdata->dsr_state = ((signals & 0x02) ? 1 : 0);
			portdata->ri_state = ((signals & 0x08) ? 1 : 0);

			if (old_dcd_state && !portdata->dcd_state) {
				struct tty_struct *tty =
						tty_port_tty_get(&port->port);
				if (tty && !C_CLOCAL(tty))
					tty_hangup(tty);
				tty_kref_put(tty);
			}
		} else {
			dbg("%s: type %x req %x", __func__,
				req_pkt->bRequestType, req_pkt->bRequest);
		}
	} else
		err("%s: error %d", __func__, status);

	/* Resubmit urb so we continue receiving IRQ data */
	if (status != -ESHUTDOWN && status != -ENOENT) {
		err = usb_submit_urb(urb, GFP_ATOMIC);
		if (err)
			dbg("%s: resubmit intr urb failed. (%d)",
				__func__, err);
	}
}

/** send RTS/DTR state to the port.
 *
 * This is exactly the same as SET_CONTROL_LINE_STATE from the PSTN
 * CDC.
*/
static int zte_send_setup(struct usb_serial_port *port)
{
	struct usb_serial *serial = port->serial;
	struct usb_wwan_intf_private *intfdata =
		(struct usb_wwan_intf_private *) serial->private;
	struct zte_port_private *portdata;
	int ifNum = serial->interface->cur_altsetting->desc.bInterfaceNumber;
	int val = 0;
	dbg("%s", __func__);

	if (is_blacklisted(ifNum,
			   (struct zte_blacklist_info *) intfdata->private)
	    == zte_BLACKLIST_SENDSETUP) {
		dbg("No send_setup on blacklisted interface #%d\n", ifNum);
		return -EIO;
	}

	portdata = usb_get_serial_port_data(port);

	if (portdata->dtr_state)
		val |= 0x01;
	if (portdata->rts_state)
		val |= 0x02;

	return usb_control_msg(serial->dev,
		usb_rcvctrlpipe(serial->dev, 0),
		0x22, 0x21, val, ifNum, NULL, 0, USB_CTRL_SET_TIMEOUT);
}

MODULE_AUTHOR(DRIVER_AUTHOR);
MODULE_DESCRIPTION(DRIVER_DESC);
MODULE_VERSION(DRIVER_VERSION);
MODULE_LICENSE("GPL");

module_param(debug, bool, S_IRUGO | S_IWUSR);
MODULE_PARM_DESC(debug, "Debug messages");


#elif LINUX_VERSION_CODE < KERNEL_VERSION(3,1,0)//use  3.0.8 sourcecode
#include <linux/kernel.h>
#include <linux/jiffies.h>
#include <linux/errno.h>
#include <linux/tty.h>
#include <linux/tty_flip.h>
#include <linux/slab.h>
#include <linux/module.h>
#include <linux/bitops.h>
#include <linux/usb.h>
#include <linux/usb/serial.h>
#include "usb-wwan.h"

/* Function prototypes */
static int  zte_probe(struct usb_serial *serial,
			const struct usb_device_id *id);
static int zte_send_setup(struct usb_serial_port *port);
static void zte_instat_callback(struct urb *urb);

/* ZTE PRODUCTS */
#define zte_VENDOR_ID				0x19d2

/* some devices interfaces need special handling due to a number of reasons */
enum zte_blacklist_reason {
		OPTION_BLACKLIST_NONE = 0,
		OPTION_BLACKLIST_SENDSETUP = 1,
		OPTION_BLACKLIST_RESERVED_IF = 2
};

struct zte_blacklist_info {
	const u32 infolen;	/* number of interface numbers on blacklist */
	const u8  *ifaceinfo;	/* pointer to the array holding the numbers */
	enum zte_blacklist_reason reason;
};

static const u8 four_g_w14_no_sendsetup[] = { 0, 1 };
static const struct zte_blacklist_info four_g_w14_blacklist = {
	.infolen = ARRAY_SIZE(four_g_w14_no_sendsetup),
	.ifaceinfo = four_g_w14_no_sendsetup,
	.reason = OPTION_BLACKLIST_SENDSETUP
};

static const u8 alcatel_x200_no_sendsetup[] = { 0, 1 };
static const struct zte_blacklist_info alcatel_x200_blacklist = {
	.infolen = ARRAY_SIZE(alcatel_x200_no_sendsetup),
	.ifaceinfo = alcatel_x200_no_sendsetup,
	.reason = OPTION_BLACKLIST_SENDSETUP
};

static const u8 zte_k3765_z_no_sendsetup[] = { 0, 1, 2 };
static const struct zte_blacklist_info zte_k3765_z_blacklist = {
	.infolen = ARRAY_SIZE(zte_k3765_z_no_sendsetup),
	.ifaceinfo = zte_k3765_z_no_sendsetup,
	.reason = OPTION_BLACKLIST_SENDSETUP
};

static const struct usb_device_id zte_ids[] = {
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0001, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0002, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0003, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0004, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0005, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0006, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0007, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0008, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0009, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0010, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0011, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0012, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0013, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0014, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0015, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0016, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0017, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0018, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0019, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0020, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0021, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0022, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0023, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0024, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0025, 0xff, 0xff, 0xff) },
    //   { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0026, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0027, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0028, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0029, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0030, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0031, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0032, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0033, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0034, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0035, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0036, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0037, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0038, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0039, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0040, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0041, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0042, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0043, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0044, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0045, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0046, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0047, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0048, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0049, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0050, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0051, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0052, 0xff, 0xff, 0xff) },
    //   { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0053, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0054, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0055, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0056, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0057, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0058, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0059, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0060, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0061, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0062, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0063, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0064, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0065, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0066, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0067, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0068, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0069, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0070, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0071, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0072, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0073, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0074, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0075, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0076, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0077, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0078, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0079, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0080, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0081, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0082, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0083, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0084, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0085, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0086, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0087, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0088, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0089, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0090, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0091, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0092, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0093, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0094, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0095, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0096, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0097, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0098, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0099, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0104, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0105, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0106, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0108, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0117, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0118, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0121, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0122, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0123, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0124, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0125, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0126, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0128, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0130, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0133, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0135, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0136, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0137, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0139, 0xff, 0xff, 0xff) }, 	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0141, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0144, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0145, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0147, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0148, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0151, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0152, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0153, 0xff, 0xff, 0xff) },
    //{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0154, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0155, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0156, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0157, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0158, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0159, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0160, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0161, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0162, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0164, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0165, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0167, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0168, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0170, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0176, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0178, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0189, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0191, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0196, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0197, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0199, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0200, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0201, 0xff, 0xff, 0xff) },		
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0254, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0257, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0265, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0284, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0317, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0330, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0395, 0xff, 0xff, 0xff) },      
 	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0414, 0xff, 0xff, 0xff) },   
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0417, 0xff, 0xff, 0xff) },

    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1008, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1010, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1012, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1018, 0xff, 0xff, 0xff) },		
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1057, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1058, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1059, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1060, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1061, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1062, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1063, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1064, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1065, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1066, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1067, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1068, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1069, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1070, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1071, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1072, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1073, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1074, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1075, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1076, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1077, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1078, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1079, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1080, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1081, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1082, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1083, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1084, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1085, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1086, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1087, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1088, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1089, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1090, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1091, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1092, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1093, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1094, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1095, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1096, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1097, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1098, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1099, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1100, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1101, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1102, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1103, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1104, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1105, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1106, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1107, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1108, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1109, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1110, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1111, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1112, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1113, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1114, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1115, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1116, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1117, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1118, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1119, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1120, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1121, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1122, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1123, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1124, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1125, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1126, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1127, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1128, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1129, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1130, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1131, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1132, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1133, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1134, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1135, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1136, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1137, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1138, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1139, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1140, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1141, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1142, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1143, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1144, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1145, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1146, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1147, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1148, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1149, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1150, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1151, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1152, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1153, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1154, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1155, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1156, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1157, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1158, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1159, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1160, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1161, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1162, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1163, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1164, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1165, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1166, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1167, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1168, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1169, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1170, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1244, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1245, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1246, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1247, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1248, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1249, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1250, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1251, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1252, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1253, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1254, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1255, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1256, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1257, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1258, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1259, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1260, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1261, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1262, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1263, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1264, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1265, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1266, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1267, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1268, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1269, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1270, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1271, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1272, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1273, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1274, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1275, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1276, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1277, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1278, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1279, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1280, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1281, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1282, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1283, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1284, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1285, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1286, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1287, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1288, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1289, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1290, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1291, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1292, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1293, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1294, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1295, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1296, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1297, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1298, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1299, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1300, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1301, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1302, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1303, 0xff, 0xff, 0xff) },	
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1333, 0xff, 0xff, 0xff) },	
	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1401, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1402, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1403, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1404, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1405, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1406, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1407, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1408, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1409, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1410, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1411, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1412, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1413, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1414, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1415, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1416, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1417, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1418, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1419, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1420, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1421, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1422, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1423, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1424, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1425, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1426, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1427, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1428, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1429, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1430, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1431, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1432, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1433, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1434, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1435, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1436, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1437, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1438, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1439, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1440, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1441, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1442, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1443, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1444, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1445, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1446, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1447, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1448, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1449, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1450, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1451, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1452, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1453, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1454, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1455, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1456, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1457, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1458, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1459, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1460, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1461, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1462, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1463, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1464, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1465, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1466, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1467, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1468, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1469, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1470, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1471, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1472, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1473, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1474, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1475, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1476, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1477, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1478, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1479, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1480, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1481, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1482, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1483, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1484, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1485, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1486, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1487, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1488, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1489, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1490, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1491, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1492, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1493, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1494, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1495, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1496, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1497, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1498, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1499, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1500, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1501, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1502, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1503, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1504, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1505, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1506, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1507, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1508, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1509, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1510, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1533, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1534, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1535, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1545, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1546, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1547, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1565, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1566, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1567, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1589, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1590, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1591, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1592, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1594, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1596, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1598, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1600, 0xff, 0xff, 0xff) },  		
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x2002, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x2003, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0xFFEC, 0xff, 0xff, 0xff) },
    { ZTE_USB_DEVICE_ID_MATCH_INT_CLASS_AND_SUBCLASS_INFO(0x19d2,0xff,0x86) },
    { ZTE_USB_DEVICE_ID_MATCH_INT_CLASS_AND_SUBCLASS_INFO(0x19d2,0xff,0x02) },
    { USB_DEVICE_AND_INTERFACE_INFO(TPLink_VENDOR_ID, 0x7E11, 0xff, 0xff, 0xff) },/*TPLink*/
    { USB_DEVICE_AND_INTERFACE_INFO(QUALCOMM_VENDOR_ID, 0x9001, 0xff, 0xff, 0xff) },/*QUALCOMM_VENDOR_ID*/
    { USB_DEVICE_AND_INTERFACE_INFO(QUALCOMM_VENDOR_ID, 0x9002, 0xff, 0xff, 0xff) },
	{ } /* Terminating entry */
};
MODULE_DEVICE_TABLE(usb, zte_ids);

static struct usb_driver zte_driver = {
	.name       = "zte",
	.probe      = usb_serial_probe,
	.disconnect = usb_serial_disconnect,
#ifdef CONFIG_PM
	.suspend    = usb_serial_suspend,
	.resume     = usb_serial_resume,
	.supports_autosuspend =	1,
#endif
	.id_table   = zte_ids,
	.no_dynamic_id = 	1,
};

/* The card has three separate interfaces, which the serial driver
 * recognizes separately, thus num_port=1.
 */

static struct usb_serial_driver zte_1port_device = {
	.driver = {
		.owner =	THIS_MODULE,
		.name =		"zte1",
	},
	.description       = "GSM modem (1-port)",
	.usb_driver        = &zte_driver,
	.id_table          = zte_ids,
	.num_ports         = 1,
	.probe             = zte_probe,
	.open              = usb_wwan_open,
	.close             = usb_wwan_close,
	.dtr_rts	   = usb_wwan_dtr_rts,
	.write             = usb_wwan_write,
	.write_room        = usb_wwan_write_room,
	.chars_in_buffer   = usb_wwan_chars_in_buffer,
	.set_termios       = usb_wwan_set_termios,
	.tiocmget          = usb_wwan_tiocmget,
	.tiocmset          = usb_wwan_tiocmset,
	.ioctl             = usb_wwan_ioctl,
	.attach            = usb_wwan_startup,
	.disconnect        = usb_wwan_disconnect,
	.release           = usb_wwan_release,
	.read_int_callback = zte_instat_callback,
#ifdef CONFIG_PM
	.suspend           = usb_wwan_suspend,
	.resume            = usb_wwan_resume,
#endif
};

static int debug;

/* per port private data */

#define N_IN_URB 4
#define N_OUT_URB 4
#define IN_BUFLEN 4096
#define OUT_BUFLEN 4096

struct zte_port_private {
	/* Input endpoints and buffer for this port */
	struct urb *in_urbs[N_IN_URB];
	u8 *in_buffer[N_IN_URB];
	/* Output endpoints and buffer for this port */
	struct urb *out_urbs[N_OUT_URB];
	u8 *out_buffer[N_OUT_URB];
	unsigned long out_busy;		/* Bit vector of URBs in use */
	int opened;
	struct usb_anchor delayed;

	/* Settings for the port */
	int rts_state;	/* Handshaking pins (outputs) */
	int dtr_state;
	int cts_state;	/* Handshaking pins (inputs) */
	int dsr_state;
	int dcd_state;
	int ri_state;

	unsigned long tx_start_time[N_OUT_URB];
};

/* Functions used by new usb-serial code. */
static int __init zte_init(void)
{
	int retval;
	retval = usb_serial_register(&zte_1port_device);
	if (retval)
		goto failed_1port_device_register;
	retval = usb_register(&zte_driver);
	if (retval)
		goto failed_driver_register;

	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
	       DRIVER_DESC "\n");

	return 0;

failed_driver_register:
	usb_serial_deregister(&zte_1port_device);
failed_1port_device_register:
	return retval;
}

static void __exit zte_exit(void)
{
	usb_deregister(&zte_driver);
	usb_serial_deregister(&zte_1port_device);
}

module_init(zte_init);
module_exit(zte_exit);

static int zte_probe(struct usb_serial *serial,
			const struct usb_device_id *id)
{
	struct usb_wwan_intf_private *data;
	/* D-Link DWM 652 still exposes CD-Rom emulation interface in modem mode */
	/*if (serial->dev->descriptor.idVendor == DLINK_VENDOR_ID &&
		serial->dev->descriptor.idProduct == DLINK_PRODUCT_DWM_652 &&
		serial->interface->cur_altsetting->desc.bInterfaceClass == 0x8)
		return -ENODEV;*/

	/* Bandrich modem and AT command interface is 0xff */
	/*if ((serial->dev->descriptor.idVendor == BANDRICH_VENDOR_ID ||
		serial->dev->descriptor.idVendor == PIRELLI_VENDOR_ID) &&
		serial->interface->cur_altsetting->desc.bInterfaceClass != 0xff)
		return -ENODEV;*/

	/* Don't bind network interfaces on Huawei K3765, K4505 & K4605 */
	/*if (serial->dev->descriptor.idVendor == HUAWEI_VENDOR_ID &&
		(serial->dev->descriptor.idProduct == HUAWEI_PRODUCT_K3765 ||
			serial->dev->descriptor.idProduct == HUAWEI_PRODUCT_K4505 ||
			serial->dev->descriptor.idProduct == HUAWEI_PRODUCT_K4605) &&
		(serial->interface->cur_altsetting->desc.bInterfaceNumber == 1 ||
			serial->interface->cur_altsetting->desc.bInterfaceNumber == 2))
		return -ENODEV;*/

	/* Don't bind network interface on Samsung GT-B3730, it is handled by a separate module */
	/*if (serial->dev->descriptor.idVendor == SAMSUNG_VENDOR_ID &&
		serial->dev->descriptor.idProduct == SAMSUNG_PRODUCT_GT_B3730 &&
		serial->interface->cur_altsetting->desc.bInterfaceClass != USB_CLASS_CDC_DATA)
		return -ENODEV;*/

	data = serial->private = kzalloc(sizeof(struct usb_wwan_intf_private), GFP_KERNEL);

	if (!data)
		return -ENOMEM;
	data->send_setup = zte_send_setup;
	spin_lock_init(&data->susp_lock);
	data->private = (void *)id->driver_info;
	return 0;
}

static enum zte_blacklist_reason is_blacklisted(const u8 ifnum,
				const struct zte_blacklist_info *blacklist)
{
	const u8  *info;
	int i;

	if (blacklist) {
		info = blacklist->ifaceinfo;

		for (i = 0; i < blacklist->infolen; i++) {
			if (info[i] == ifnum)
				return blacklist->reason;
		}
	}
	return OPTION_BLACKLIST_NONE;
}

static void zte_instat_callback(struct urb *urb)
{
	int err;
	int status = urb->status;
	struct usb_serial_port *port =  urb->context;
	struct zte_port_private *portdata = usb_get_serial_port_data(port);

	dbg("%s", __func__);
	dbg("%s: urb %p port %p has data %p", __func__, urb, port, portdata);

	if (status == 0) {
		struct usb_ctrlrequest *req_pkt =
				(struct usb_ctrlrequest *)urb->transfer_buffer;

		if (!req_pkt) {
			dbg("%s: NULL req_pkt", __func__);
			return;
		}
		if ((req_pkt->bRequestType == 0xA1) &&
				(req_pkt->bRequest == 0x20)) {
			int old_dcd_state;
			unsigned char signals = *((unsigned char *)
					urb->transfer_buffer +
					sizeof(struct usb_ctrlrequest));

			dbg("%s: signal x%x", __func__, signals);

			old_dcd_state = portdata->dcd_state;
			portdata->cts_state = 1;
			portdata->dcd_state = ((signals & 0x01) ? 1 : 0);
			portdata->dsr_state = ((signals & 0x02) ? 1 : 0);
			portdata->ri_state = ((signals & 0x08) ? 1 : 0);

			if (old_dcd_state && !portdata->dcd_state) {
				struct tty_struct *tty =
						tty_port_tty_get(&port->port);
				if (tty && !C_CLOCAL(tty))
					tty_hangup(tty);
				tty_kref_put(tty);
			}
		} else {
			dbg("%s: type %x req %x", __func__,
				req_pkt->bRequestType, req_pkt->bRequest);
		}
	} else
		err("%s: error %d", __func__, status);

	/* Resubmit urb so we continue receiving IRQ data */
	if (status != -ESHUTDOWN && status != -ENOENT) {
		err = usb_submit_urb(urb, GFP_ATOMIC);
		if (err)
			dbg("%s: resubmit intr urb failed. (%d)",
				__func__, err);
	}
}

/** send RTS/DTR state to the port.
 *
 * This is exactly the same as SET_CONTROL_LINE_STATE from the PSTN
 * CDC.
*/
static int zte_send_setup(struct usb_serial_port *port)
{
	struct usb_serial *serial = port->serial;
	struct usb_wwan_intf_private *intfdata =
		(struct usb_wwan_intf_private *) serial->private;
	struct zte_port_private *portdata;
	int ifNum = serial->interface->cur_altsetting->desc.bInterfaceNumber;
	int val = 0;
	dbg("%s", __func__);

	if (is_blacklisted(ifNum,
			   (struct zte_blacklist_info *) intfdata->private)
	    == OPTION_BLACKLIST_SENDSETUP) {
		dbg("No send_setup on blacklisted interface #%d\n", ifNum);
		return -EIO;
	}

	portdata = usb_get_serial_port_data(port);

	if (portdata->dtr_state)
		val |= 0x01;
	if (portdata->rts_state)
		val |= 0x02;

	return usb_control_msg(serial->dev,
		usb_rcvctrlpipe(serial->dev, 0),
		0x22, 0x21, val, ifNum, NULL, 0, USB_CTRL_SET_TIMEOUT);
}

MODULE_AUTHOR(DRIVER_AUTHOR);
MODULE_DESCRIPTION(DRIVER_DESC);
MODULE_VERSION(DRIVER_VERSION);
MODULE_LICENSE("GPL");

module_param(debug, bool, S_IRUGO | S_IWUSR);
MODULE_PARM_DESC(debug, "Debug messages");

#elif LINUX_VERSION_CODE < KERNEL_VERSION(3,2,0)//use  3.1.1 sourcecode
#include <linux/kernel.h>
#include <linux/jiffies.h>
#include <linux/errno.h>
#include <linux/tty.h>
#include <linux/tty_flip.h>
#include <linux/slab.h>
#include <linux/module.h>
#include <linux/bitops.h>
#include <linux/usb.h>
#include <linux/usb/serial.h>
#include "usb-wwan.h"

/* Function prototypes */
static int  zte_probe(struct usb_serial *serial,
			const struct usb_device_id *id);
static int zte_send_setup(struct usb_serial_port *port);
static void zte_instat_callback(struct urb *urb);

/* Vendor and product IDs */
/* ZTE PRODUCTS */
#define zte_VENDOR_ID				0x19d2



/* some devices interfaces need special handling due to a number of reasons */
enum zte_blacklist_reason {
		OPTION_BLACKLIST_NONE = 0,
		OPTION_BLACKLIST_SENDSETUP = 1,
		OPTION_BLACKLIST_RESERVED_IF = 2
};

#define MAX_BL_NUM  8
struct zte_blacklist_info {
	/* bitfield of interface numbers for OPTION_BLACKLIST_SENDSETUP */
	const unsigned long sendsetup;
	/* bitfield of interface numbers for OPTION_BLACKLIST_RESERVED_IF */
	const unsigned long reserved;
};

static const struct zte_blacklist_info four_g_w14_blacklist = {
	.sendsetup = BIT(0) | BIT(1),
};

static const struct zte_blacklist_info alcatel_x200_blacklist = {
	.sendsetup = BIT(0) | BIT(1),
};

static const struct zte_blacklist_info zte_0037_blacklist = {
	.sendsetup = BIT(0) | BIT(1),
};

static const struct zte_blacklist_info zte_k3765_z_blacklist = {
	.sendsetup = BIT(0) | BIT(1) | BIT(2),
	.reserved = BIT(4),
};

static const struct zte_blacklist_info huawei_cdc12_blacklist = {
	.reserved = BIT(1) | BIT(2),
};

static const struct zte_blacklist_info net_intf1_blacklist = {
	.reserved = BIT(1),
};

static const struct zte_blacklist_info net_intf3_blacklist = {
	.reserved = BIT(3),
};

static const struct zte_blacklist_info net_intf4_blacklist = {
	.reserved = BIT(4),
};

static const struct zte_blacklist_info net_intf5_blacklist = {
	.reserved = BIT(5),
};

static const struct zte_blacklist_info zte_mf626_blacklist = {
	.sendsetup = BIT(0) | BIT(1),
	.reserved = BIT(4),
};

static const struct usb_device_id zte_ids[] = {
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0001, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0002, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0003, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0004, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0005, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0006, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0007, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0008, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0009, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0010, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0011, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0012, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0013, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0014, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0015, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0016, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0017, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0018, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0019, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0020, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0021, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0022, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0023, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0024, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0025, 0xff, 0xff, 0xff) },
    //   { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0026, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0027, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0028, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0029, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0030, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0031, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0032, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0033, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0034, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0035, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0036, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0037, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0038, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0039, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0040, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0041, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0042, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0043, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0044, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0045, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0046, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0047, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0048, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0049, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0050, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0051, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0052, 0xff, 0xff, 0xff) },
    //   { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0053, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0054, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0055, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0056, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0057, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0058, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0059, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0060, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0061, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0062, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0063, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0064, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0065, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0066, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0067, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0068, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0069, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0070, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0071, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0072, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0073, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0074, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0075, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0076, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0077, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0078, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0079, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0080, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0081, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0082, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0083, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0084, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0085, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0086, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0087, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0088, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0089, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0090, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0091, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0092, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0093, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0094, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0095, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0096, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0097, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0098, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0099, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0104, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0105, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0106, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0108, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0117, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0118, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0121, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0122, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0123, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0124, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0125, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0126, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0128, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0130, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0133, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0135, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0136, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0137, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0139, 0xff, 0xff, 0xff) }, 	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0141, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0144, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0145, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0147, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0148, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0151, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0152, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0153, 0xff, 0xff, 0xff) },
    //{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0154, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0155, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0156, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0157, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0158, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0159, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0160, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0161, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0162, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0164, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0165, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0167, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0168, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0170, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0176, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0178, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0189, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0191, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0196, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0197, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0199, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0200, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0201, 0xff, 0xff, 0xff) },		
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0254, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0257, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0265, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0284, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0317, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0330, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0395, 0xff, 0xff, 0xff) },      
 	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0414, 0xff, 0xff, 0xff) },   
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0417, 0xff, 0xff, 0xff) },

    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1008, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1010, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1012, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1018, 0xff, 0xff, 0xff) },		
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1057, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1058, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1059, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1060, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1061, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1062, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1063, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1064, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1065, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1066, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1067, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1068, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1069, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1070, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1071, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1072, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1073, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1074, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1075, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1076, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1077, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1078, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1079, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1080, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1081, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1082, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1083, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1084, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1085, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1086, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1087, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1088, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1089, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1090, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1091, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1092, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1093, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1094, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1095, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1096, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1097, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1098, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1099, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1100, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1101, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1102, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1103, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1104, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1105, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1106, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1107, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1108, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1109, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1110, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1111, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1112, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1113, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1114, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1115, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1116, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1117, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1118, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1119, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1120, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1121, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1122, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1123, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1124, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1125, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1126, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1127, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1128, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1129, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1130, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1131, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1132, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1133, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1134, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1135, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1136, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1137, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1138, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1139, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1140, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1141, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1142, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1143, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1144, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1145, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1146, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1147, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1148, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1149, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1150, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1151, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1152, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1153, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1154, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1155, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1156, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1157, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1158, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1159, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1160, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1161, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1162, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1163, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1164, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1165, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1166, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1167, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1168, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1169, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1170, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1244, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1245, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1246, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1247, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1248, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1249, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1250, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1251, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1252, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1253, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1254, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1255, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1256, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1257, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1258, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1259, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1260, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1261, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1262, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1263, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1264, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1265, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1266, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1267, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1268, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1269, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1270, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1271, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1272, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1273, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1274, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1275, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1276, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1277, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1278, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1279, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1280, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1281, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1282, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1283, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1284, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1285, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1286, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1287, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1288, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1289, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1290, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1291, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1292, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1293, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1294, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1295, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1296, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1297, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1298, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1299, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1300, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1301, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1302, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1303, 0xff, 0xff, 0xff) },	
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1333, 0xff, 0xff, 0xff) },	
	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1401, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1402, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1403, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1404, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1405, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1406, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1407, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1408, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1409, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1410, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1411, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1412, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1413, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1414, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1415, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1416, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1417, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1418, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1419, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1420, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1421, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1422, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1423, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1424, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1425, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1426, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1427, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1428, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1429, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1430, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1431, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1432, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1433, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1434, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1435, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1436, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1437, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1438, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1439, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1440, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1441, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1442, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1443, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1444, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1445, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1446, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1447, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1448, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1449, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1450, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1451, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1452, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1453, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1454, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1455, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1456, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1457, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1458, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1459, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1460, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1461, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1462, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1463, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1464, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1465, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1466, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1467, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1468, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1469, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1470, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1471, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1472, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1473, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1474, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1475, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1476, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1477, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1478, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1479, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1480, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1481, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1482, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1483, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1484, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1485, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1486, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1487, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1488, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1489, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1490, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1491, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1492, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1493, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1494, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1495, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1496, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1497, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1498, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1499, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1500, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1501, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1502, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1503, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1504, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1505, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1506, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1507, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1508, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1509, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1510, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1533, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1534, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1535, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1545, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1546, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1547, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1565, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1566, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1567, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1589, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1590, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1591, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1592, 0xff, 0xff, 0xff) }, 	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1594, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1596, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1598, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1600, 0xff, 0xff, 0xff) },  	    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x2002, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x2003, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0xFFEC, 0xff, 0xff, 0xff) },
    { ZTE_USB_DEVICE_ID_MATCH_INT_CLASS_AND_SUBCLASS_INFO(0x19d2,0xff,0x86) },
    { ZTE_USB_DEVICE_ID_MATCH_INT_CLASS_AND_SUBCLASS_INFO(0x19d2,0xff,0x02) },
    { USB_DEVICE_AND_INTERFACE_INFO(TPLink_VENDOR_ID, 0x7E11, 0xff, 0xff, 0xff) },/*TPLink*/
    { USB_DEVICE_AND_INTERFACE_INFO(QUALCOMM_VENDOR_ID, 0x9001, 0xff, 0xff, 0xff) },/*QUALCOMM_VENDOR_ID*/
    { USB_DEVICE_AND_INTERFACE_INFO(QUALCOMM_VENDOR_ID, 0x9002, 0xff, 0xff, 0xff) },
	{ } /* Terminating entry */
};
MODULE_DEVICE_TABLE(usb, zte_ids);

static struct usb_driver zte_driver = {
	.name       = "zte",
	.probe      = usb_serial_probe,
	.disconnect = usb_serial_disconnect,
#ifdef CONFIG_PM
	.suspend    = usb_serial_suspend,
	.resume     = usb_serial_resume,
	.supports_autosuspend =	1,
#endif
	.id_table   = zte_ids,
	.no_dynamic_id = 	1,
};

/* The card has three separate interfaces, which the serial driver
 * recognizes separately, thus num_port=1.
 */

static struct usb_serial_driver zte_1port_device = {
	.driver = {
		.owner =	THIS_MODULE,
		.name =		"zte1",
	},
	.description       = "GSM modem (1-port)",
	.usb_driver        = &zte_driver,
	.id_table          = zte_ids,
	.num_ports         = 1,
	.probe             = zte_probe,
	.open              = usb_wwan_open,
	.close             = usb_wwan_close,
	.dtr_rts	   = usb_wwan_dtr_rts,
	.write             = usb_wwan_write,
	.write_room        = usb_wwan_write_room,
	.chars_in_buffer   = usb_wwan_chars_in_buffer,
	.set_termios       = usb_wwan_set_termios,
	.tiocmget          = usb_wwan_tiocmget,
	.tiocmset          = usb_wwan_tiocmset,
	.ioctl             = usb_wwan_ioctl,
	.attach            = usb_wwan_startup,
	.disconnect        = usb_wwan_disconnect,
	.release           = usb_wwan_release,
	.read_int_callback = zte_instat_callback,
#ifdef CONFIG_PM
	.suspend           = usb_wwan_suspend,
	.resume            = usb_wwan_resume,
#endif
};

static int debug;

/* per port private data */

#define N_IN_URB 4
#define N_OUT_URB 4
#define IN_BUFLEN 4096
#define OUT_BUFLEN 4096

struct zte_port_private {
	/* Input endpoints and buffer for this port */
	struct urb *in_urbs[N_IN_URB];
	u8 *in_buffer[N_IN_URB];
	/* Output endpoints and buffer for this port */
	struct urb *out_urbs[N_OUT_URB];
	u8 *out_buffer[N_OUT_URB];
	unsigned long out_busy;		/* Bit vector of URBs in use */
	int opened;
	struct usb_anchor delayed;

	/* Settings for the port */
	int rts_state;	/* Handshaking pins (outputs) */
	int dtr_state;
	int cts_state;	/* Handshaking pins (inputs) */
	int dsr_state;
	int dcd_state;
	int ri_state;

	unsigned long tx_start_time[N_OUT_URB];
};

/* Functions used by new usb-serial code. */
static int __init zte_init(void)
{
	int retval;
	retval = usb_serial_register(&zte_1port_device);
	if (retval)
		goto failed_1port_device_register;
	retval = usb_register(&zte_driver);
	if (retval)
		goto failed_driver_register;

	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
	       DRIVER_DESC "\n");

	return 0;

failed_driver_register:
	usb_serial_deregister(&zte_1port_device);
failed_1port_device_register:
	return retval;
}

static void __exit zte_exit(void)
{
	usb_deregister(&zte_driver);
	usb_serial_deregister(&zte_1port_device);
}

module_init(zte_init);
module_exit(zte_exit);

static bool is_blacklisted(const u8 ifnum, enum zte_blacklist_reason reason,
			   const struct zte_blacklist_info *blacklist)
{
	unsigned long num;
	const unsigned long *intf_list;

	if (blacklist) {
		if (reason == OPTION_BLACKLIST_SENDSETUP)
			intf_list = &blacklist->sendsetup;
		else if (reason == OPTION_BLACKLIST_RESERVED_IF)
			intf_list = &blacklist->reserved;
		else {
			BUG_ON(reason);
			return false;
		}

		for_each_set_bit(num, intf_list, MAX_BL_NUM + 1) {
			if (num == ifnum)
				return true;
		}
	}
	return false;
}

static int zte_probe(struct usb_serial *serial,
			const struct usb_device_id *id)
{
	struct usb_wwan_intf_private *data;

	/* D-Link DWM 652 still exposes CD-Rom emulation interface in modem mode */
/*	if (serial->dev->descriptor.idVendor == DLINK_VENDOR_ID &&
		serial->dev->descriptor.idProduct == DLINK_PRODUCT_DWM_652 &&
		serial->interface->cur_altsetting->desc.bInterfaceClass == 0x8)
		return -ENODEV;*/

	/* Bandrich modem and AT command interface is 0xff */
	/*if ((serial->dev->descriptor.idVendor == BANDRICH_VENDOR_ID ||
		serial->dev->descriptor.idVendor == PIRELLI_VENDOR_ID) &&
		serial->interface->cur_altsetting->desc.bInterfaceClass != 0xff)
		return -ENODEV;*/

	/* Don't bind reserved interfaces (like network ones) which often have
	 * the same class/subclass/protocol as the serial interfaces.  Look at
	 * the Windows driver .INF files for reserved interface numbers.
	 */
	/*if (is_blacklisted(
		serial->interface->cur_altsetting->desc.bInterfaceNumber,
		OPTION_BLACKLIST_RESERVED_IF,
		(const struct zte_blacklist_info *) id->driver_info))*/

	/* Don't bind network interface on Samsung GT-B3730, it is handled by a separate module */
	/*if (serial->dev->descriptor.idVendor == SAMSUNG_VENDOR_ID &&
		serial->dev->descriptor.idProduct == SAMSUNG_PRODUCT_GT_B3730 &&
		serial->interface->cur_altsetting->desc.bInterfaceClass != USB_CLASS_CDC_DATA)
		return -ENODEV;*/

	data = serial->private = kzalloc(sizeof(struct usb_wwan_intf_private), GFP_KERNEL);
	if (!data)
		return -ENOMEM;
	data->send_setup = zte_send_setup;
	spin_lock_init(&data->susp_lock);
	data->private = (void *)id->driver_info;
	return 0;
}

static void zte_instat_callback(struct urb *urb)
{
	int err;
	int status = urb->status;
	struct usb_serial_port *port =  urb->context;
	struct zte_port_private *portdata = usb_get_serial_port_data(port);

	dbg("%s", __func__);
	dbg("%s: urb %p port %p has data %p", __func__, urb, port, portdata);

	if (status == 0) {
		struct usb_ctrlrequest *req_pkt =
				(struct usb_ctrlrequest *)urb->transfer_buffer;

		if (!req_pkt) {
			dbg("%s: NULL req_pkt", __func__);
			return;
		}
		if ((req_pkt->bRequestType == 0xA1) &&
				(req_pkt->bRequest == 0x20)) {
			int old_dcd_state;
			unsigned char signals = *((unsigned char *)
					urb->transfer_buffer +
					sizeof(struct usb_ctrlrequest));

			dbg("%s: signal x%x", __func__, signals);

			old_dcd_state = portdata->dcd_state;
			portdata->cts_state = 1;
			portdata->dcd_state = ((signals & 0x01) ? 1 : 0);
			portdata->dsr_state = ((signals & 0x02) ? 1 : 0);
			portdata->ri_state = ((signals & 0x08) ? 1 : 0);

			if (old_dcd_state && !portdata->dcd_state) {
				struct tty_struct *tty =
						tty_port_tty_get(&port->port);
				if (tty && !C_CLOCAL(tty))
					tty_hangup(tty);
				tty_kref_put(tty);
			}
		} else {
			dbg("%s: type %x req %x", __func__,
				req_pkt->bRequestType, req_pkt->bRequest);
		}
	} else
		err("%s: error %d", __func__, status);

	/* Resubmit urb so we continue receiving IRQ data */
	if (status != -ESHUTDOWN && status != -ENOENT) {
		err = usb_submit_urb(urb, GFP_ATOMIC);
		if (err)
			dbg("%s: resubmit intr urb failed. (%d)",
				__func__, err);
	}
}

/** send RTS/DTR state to the port.
 *
 * This is exactly the same as SET_CONTROL_LINE_STATE from the PSTN
 * CDC.
*/
static int zte_send_setup(struct usb_serial_port *port)
{
	struct usb_serial *serial = port->serial;
	struct usb_wwan_intf_private *intfdata =
		(struct usb_wwan_intf_private *) serial->private;
	struct zte_port_private *portdata;
	int ifNum = serial->interface->cur_altsetting->desc.bInterfaceNumber;
	int val = 0;
	dbg("%s", __func__);

	if (is_blacklisted(ifNum, OPTION_BLACKLIST_SENDSETUP,
			(struct zte_blacklist_info *) intfdata->private)) {
		dbg("No send_setup on blacklisted interface #%d\n", ifNum);
		return -EIO;
	}

	portdata = usb_get_serial_port_data(port);

	if (portdata->dtr_state)
		val |= 0x01;
	if (portdata->rts_state)
		val |= 0x02;

	return usb_control_msg(serial->dev,
		usb_rcvctrlpipe(serial->dev, 0),
		0x22, 0x21, val, ifNum, NULL, 0, USB_CTRL_SET_TIMEOUT);
}

MODULE_AUTHOR(DRIVER_AUTHOR);
MODULE_DESCRIPTION(DRIVER_DESC);
MODULE_VERSION(DRIVER_VERSION);
MODULE_LICENSE("GPL");

module_param(debug, bool, S_IRUGO | S_IWUSR);
MODULE_PARM_DESC(debug, "Debug messages");


#elif LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0)//use  3.2.33 sourcecode

#include <linux/kernel.h>
#include <linux/jiffies.h>
#include <linux/errno.h>
#include <linux/tty.h>
#include <linux/tty_flip.h>
#include <linux/slab.h>
#include <linux/module.h>
#include <linux/bitops.h>
#include <linux/usb.h>
#include <linux/usb/serial.h>
#include <linux/uaccess.h>
#include <linux/serial.h>

/* Function prototypes */
static int  zte_probe(struct usb_serial *serial,
			const struct usb_device_id *id);
static void zte_release(struct usb_serial *serial);
static int zte_send_setup(struct usb_serial_port *port);
static void zte_instat_callback(struct urb *urb);
void zte_dtr_rts(struct usb_serial_port *port, int on);
int zte_open(struct tty_struct *tty, struct usb_serial_port *port);
void zte_close(struct usb_serial_port *port);
int zte_startup(struct usb_serial *serial);
void zte_disconnect(struct usb_serial *serial);
int zte_write_room(struct tty_struct *tty);
void zte_set_termios(struct tty_struct *tty,
				 struct usb_serial_port *port,
				 struct ktermios *old);
int zte_tiocmget(struct tty_struct *tty);
int zte_tiocmset(struct tty_struct *tty,
			     unsigned int set, unsigned int clear);
int zte_ioctl(struct tty_struct *tty,
			  unsigned int cmd, unsigned long arg);
int zte_send_setup(struct usb_serial_port *port);
int zte_write(struct tty_struct *tty, struct usb_serial_port *port,
			  const unsigned char *buf, int count);
int zte_chars_in_buffer(struct tty_struct *tty);
#ifdef CONFIG_PM
int zte_suspend(struct usb_serial *serial, pm_message_t message);
int zte_resume(struct usb_serial *serial);
#endif

/* Vendor and product IDs */
/* ZTE PRODUCTS */
#define zte_VENDOR_ID				0x19d2

/* some devices interfaces need special handling due to a number of reasons */
enum zte_blacklist_reason {
		zte_BLACKLIST_NONE = 0,
		zte_BLACKLIST_SENDSETUP = 1,
		zte_BLACKLIST_RESERVED_IF = 2
};

#define MAX_BL_NUM  8
struct zte_blacklist_info {
	/* bitfield of interface numbers for zte_BLACKLIST_SENDSETUP */
	const unsigned long sendsetup;
	/* bitfield of interface numbers for zte_BLACKLIST_RESERVED_IF */
	const unsigned long reserved;
};

static const struct zte_blacklist_info four_g_w14_blacklist = {
	.sendsetup = BIT(0) | BIT(1),
};

static const struct zte_blacklist_info alcatel_x200_blacklist = {
	.sendsetup = BIT(0) | BIT(1),
};

static const struct zte_blacklist_info zte_0037_blacklist = {
	.sendsetup = BIT(0) | BIT(1),
};

static const struct zte_blacklist_info zte_k3765_z_blacklist = {
	.sendsetup = BIT(0) | BIT(1) | BIT(2),
	.reserved = BIT(4),
};

static const struct zte_blacklist_info zte_ad3812_z_blacklist = {
	.sendsetup = BIT(0) | BIT(1) | BIT(2),
};

static const struct zte_blacklist_info zte_mc2718_z_blacklist = {
	.sendsetup = BIT(1) | BIT(2) | BIT(3) | BIT(4),
};

static const struct zte_blacklist_info zte_mc2716_z_blacklist = {
	.sendsetup = BIT(1) | BIT(2) | BIT(3),
};

static const struct zte_blacklist_info huawei_cdc12_blacklist = {
	.reserved = BIT(1) | BIT(2),
};

static const struct zte_blacklist_info net_intf1_blacklist = {
	.reserved = BIT(1),
};

static const struct zte_blacklist_info net_intf2_blacklist = {
	.reserved = BIT(2),
};

static const struct zte_blacklist_info net_intf3_blacklist = {
	.reserved = BIT(3),
};

static const struct zte_blacklist_info net_intf4_blacklist = {
	.reserved = BIT(4),
};

static const struct zte_blacklist_info net_intf5_blacklist = {
	.reserved = BIT(5),
};

static const struct zte_blacklist_info net_intf6_blacklist = {
	.reserved = BIT(6),
};

static const struct zte_blacklist_info zte_mf626_blacklist = {
	.sendsetup = BIT(0) | BIT(1),
	.reserved = BIT(4),
};

static const struct zte_blacklist_info zte_1255_blacklist = {
	.reserved = BIT(3) | BIT(4),
};

static const struct usb_device_id zte_ids[] = {
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0001, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0002, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0003, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0004, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0005, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0006, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0007, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0008, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0009, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0010, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0011, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0012, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0013, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0014, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0015, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0016, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0017, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0018, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0019, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0020, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0021, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0022, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0023, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0024, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0025, 0xff, 0xff, 0xff) },
    //   { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0026, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0027, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0028, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0029, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0030, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0031, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0032, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0033, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0034, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0035, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0036, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0037, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0038, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0039, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0040, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0041, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0042, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0043, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0044, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0045, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0046, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0047, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0048, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0049, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0050, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0051, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0052, 0xff, 0xff, 0xff) },
    //   { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0053, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0054, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0055, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0056, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0057, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0058, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0059, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0060, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0061, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0062, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0063, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0064, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0065, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0066, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0067, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0068, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0069, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0070, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0071, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0072, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0073, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0074, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0075, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0076, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0077, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0078, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0079, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0080, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0081, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0082, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0083, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0084, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0085, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0086, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0087, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0088, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0089, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0090, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0091, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0092, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0093, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0094, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0095, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0096, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0097, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0098, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0099, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0104, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0105, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0106, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0108, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0117, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0118, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0121, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0122, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0123, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0124, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0125, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0126, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0128, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0130, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0133, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0135, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0136, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0137, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0139, 0xff, 0xff, 0xff) }, 	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0141, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0144, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0145, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0147, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0148, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0151, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0152, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0153, 0xff, 0xff, 0xff) },
    //{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0154, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0155, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0156, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0157, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0158, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0159, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0160, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0161, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0162, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0164, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0165, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0167, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0168, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0170, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0176, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0178, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0189, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0191, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0196, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0197, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0199, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0200, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0201, 0xff, 0xff, 0xff) },		
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0254, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0257, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0265, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0284, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0317, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0330, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0395, 0xff, 0xff, 0xff) },      
 	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0414, 0xff, 0xff, 0xff) },   
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0417, 0xff, 0xff, 0xff) },

    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1008, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1010, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1012, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1018, 0xff, 0xff, 0xff) },		
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1057, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1058, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1059, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1060, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1061, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1062, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1063, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1064, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1065, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1066, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1067, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1068, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1069, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1070, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1071, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1072, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1073, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1074, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1075, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1076, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1077, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1078, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1079, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1080, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1081, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1082, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1083, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1084, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1085, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1086, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1087, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1088, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1089, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1090, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1091, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1092, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1093, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1094, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1095, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1096, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1097, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1098, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1099, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1100, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1101, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1102, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1103, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1104, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1105, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1106, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1107, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1108, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1109, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1110, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1111, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1112, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1113, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1114, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1115, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1116, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1117, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1118, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1119, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1120, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1121, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1122, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1123, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1124, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1125, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1126, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1127, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1128, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1129, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1130, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1131, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1132, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1133, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1134, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1135, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1136, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1137, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1138, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1139, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1140, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1141, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1142, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1143, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1144, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1145, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1146, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1147, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1148, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1149, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1150, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1151, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1152, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1153, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1154, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1155, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1156, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1157, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1158, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1159, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1160, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1161, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1162, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1163, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1164, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1165, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1166, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1167, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1168, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1169, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1170, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1244, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1245, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1246, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1247, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1248, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1249, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1250, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1251, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1252, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1253, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1254, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1255, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1256, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1257, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1258, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1259, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1260, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1261, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1262, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1263, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1264, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1265, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1266, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1267, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1268, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1269, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1270, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1271, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1272, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1273, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1274, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1275, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1276, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1277, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1278, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1279, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1280, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1281, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1282, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1283, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1284, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1285, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1286, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1287, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1288, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1289, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1290, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1291, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1292, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1293, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1294, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1295, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1296, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1297, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1298, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1299, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1300, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1301, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1302, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1303, 0xff, 0xff, 0xff) },	
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1333, 0xff, 0xff, 0xff) },	
	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1401, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1402, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1403, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1404, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1405, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1406, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1407, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1408, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1409, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1410, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1411, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1412, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1413, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1414, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1415, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1416, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1417, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1418, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1419, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1420, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1421, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1422, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1423, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1424, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1425, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1426, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1427, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1428, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1429, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1430, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1431, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1432, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1433, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1434, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1435, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1436, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1437, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1438, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1439, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1440, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1441, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1442, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1443, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1444, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1445, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1446, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1447, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1448, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1449, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1450, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1451, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1452, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1453, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1454, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1455, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1456, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1457, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1458, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1459, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1460, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1461, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1462, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1463, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1464, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1465, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1466, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1467, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1468, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1469, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1470, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1471, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1472, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1473, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1474, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1475, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1476, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1477, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1478, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1479, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1480, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1481, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1482, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1483, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1484, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1485, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1486, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1487, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1488, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1489, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1490, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1491, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1492, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1493, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1494, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1495, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1496, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1497, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1498, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1499, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1500, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1501, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1502, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1503, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1504, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1505, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1506, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1507, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1508, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1509, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1510, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1533, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1534, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1535, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1545, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1546, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1547, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1565, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1566, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1567, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1589, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1590, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1591, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1592, 0xff, 0xff, 0xff) }, 	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1594, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1596, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1598, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1600, 0xff, 0xff, 0xff) },  		
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x2002, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x2003, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0xFFEC, 0xff, 0xff, 0xff) },
    { ZTE_USB_DEVICE_ID_MATCH_INT_CLASS_AND_SUBCLASS_INFO(0x19d2,0xff,0x86) },
    { ZTE_USB_DEVICE_ID_MATCH_INT_CLASS_AND_SUBCLASS_INFO(0x19d2,0xff,0x02) },
    { USB_DEVICE_AND_INTERFACE_INFO(TPLink_VENDOR_ID, 0x7E11, 0xff, 0xff, 0xff) },/*TPLink*/
    { USB_DEVICE_AND_INTERFACE_INFO(QUALCOMM_VENDOR_ID, 0x9001, 0xff, 0xff, 0xff) },/*QUALCOMM_VENDOR_ID*/
    { USB_DEVICE_AND_INTERFACE_INFO(QUALCOMM_VENDOR_ID, 0x9002, 0xff, 0xff, 0xff) },
	{ } /* Terminating entry */
};
MODULE_DEVICE_TABLE(usb, zte_ids);

static struct usb_driver zte_driver = {
	.name       = "zte",
	.probe      = usb_serial_probe,
	.disconnect = usb_serial_disconnect,
#ifdef CONFIG_PM
	.suspend    = usb_serial_suspend,
	.resume     = usb_serial_resume,
	.supports_autosuspend =	1,
#endif
	.id_table   = zte_ids,
	.no_dynamic_id = 	1,
};

/* The card has three separate interfaces, which the serial driver
 * recognizes separately, thus num_port=1.
 */

static struct usb_serial_driver zte_1port_device = {
	.driver = {
		.owner =	THIS_MODULE,
		.name =		"zte1",
	},
	.description       = "GSM modem (1-port)",
	.usb_driver        = &zte_driver,
	.id_table          = zte_ids,
	.num_ports         = 1,
	.probe             = zte_probe,
	.open              = zte_open,
	.close             = zte_close,
	.dtr_rts	   = zte_dtr_rts,
	.write             = zte_write,
	.write_room        = zte_write_room,
	.chars_in_buffer   = zte_chars_in_buffer,
	.set_termios       = zte_set_termios,
	.tiocmget          = zte_tiocmget,
	.tiocmset          = zte_tiocmset,
	.ioctl             = zte_ioctl,
	.attach            = zte_startup,
	.disconnect        = zte_disconnect,
	.release           = zte_release,
	.read_int_callback = zte_instat_callback,
#ifdef CONFIG_PM
	.suspend           = zte_suspend,
	.resume            = zte_resume,
#endif
};

static int debug;

/* per port private data */

#define N_IN_URB 4
#define N_OUT_URB 4
#define IN_BUFLEN 4096
#define OUT_BUFLEN 4096
struct zte_intf_private {
	spinlock_t susp_lock;
	unsigned int suspended:1;
	int in_flight;
	int (*send_setup) (struct usb_serial_port *port);
	void *private;
};

struct zte_port_private {
	/* Input endpoints and buffer for this port */
	struct urb *in_urbs[N_IN_URB];
	u8 *in_buffer[N_IN_URB];
	/* Output endpoints and buffer for this port */
	struct urb *out_urbs[N_OUT_URB];
	u8 *out_buffer[N_OUT_URB];
	unsigned long out_busy;	/* Bit vector of URBs in use */
	int opened;
	struct usb_anchor delayed;

	/* Settings for the port */
	int rts_state;		/* Handshaking pins (outputs) */
	int dtr_state;
	int cts_state;		/* Handshaking pins (inputs) */
	int dsr_state;
	int dcd_state;
	int ri_state;

	unsigned long tx_start_time[N_OUT_URB];
};
/* Functions used by new usb-serial code. */
static int __init zte_init(void)
{
	int retval;
	retval = usb_serial_register(&zte_1port_device);
	if (retval)
		goto failed_1port_device_register;
	retval = usb_register(&zte_driver);
	if (retval)
		goto failed_driver_register;

	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
	       DRIVER_DESC "\n");

	return 0;

failed_driver_register:
	usb_serial_deregister(&zte_1port_device);
failed_1port_device_register:
	return retval;
}

static void __exit zte_exit(void)
{
	usb_deregister(&zte_driver);
	usb_serial_deregister(&zte_1port_device);
}

module_init(zte_init);
module_exit(zte_exit);

static int zte_probe(struct usb_serial *serial,
			const struct usb_device_id *id)
{
	struct zte_intf_private *data;

	data = serial->private = kzalloc(sizeof(struct zte_intf_private), GFP_KERNEL);
	if (!data)
		return -ENOMEM;
	data->send_setup = zte_send_setup;
	spin_lock_init(&data->susp_lock);
	data->private = (void *)id->driver_info;
	return 0;
}

static bool is_blacklisted(const u8 ifnum, enum zte_blacklist_reason reason,
			   const struct zte_blacklist_info *blacklist)
{
	unsigned long num;
	const unsigned long *intf_list;

	if (blacklist) {
		if (reason == zte_BLACKLIST_SENDSETUP)
			intf_list = &blacklist->sendsetup;
		else if (reason == zte_BLACKLIST_RESERVED_IF)
			intf_list = &blacklist->reserved;
		else {
			BUG_ON(reason);
			return false;
		}

		for_each_set_bit(num, intf_list, MAX_BL_NUM + 1) {
			if (num == ifnum)
				return true;
		}
	}
	return false;
}

static void zte_instat_callback(struct urb *urb)
{
	int err;
	int status = urb->status;
	struct usb_serial_port *port =  urb->context;
	struct zte_port_private *portdata =
					usb_get_serial_port_data(port);

	dbg("%s", __func__);
	dbg("%s: urb %p port %p has data %p", __func__, urb, port, portdata);

	if (status == 0) {
		struct usb_ctrlrequest *req_pkt =
				(struct usb_ctrlrequest *)urb->transfer_buffer;

		if (!req_pkt) {
			dbg("%s: NULL req_pkt", __func__);
			return;
		}
		if ((req_pkt->bRequestType == 0xA1) &&
				(req_pkt->bRequest == 0x20)) {
			int old_dcd_state;
			unsigned char signals = *((unsigned char *)
					urb->transfer_buffer +
					sizeof(struct usb_ctrlrequest));

			dbg("%s: signal x%x", __func__, signals);

			old_dcd_state = portdata->dcd_state;
			portdata->cts_state = 1;
			portdata->dcd_state = ((signals & 0x01) ? 1 : 0);
			portdata->dsr_state = ((signals & 0x02) ? 1 : 0);
			portdata->ri_state = ((signals & 0x08) ? 1 : 0);

			if (old_dcd_state && !portdata->dcd_state) {
				struct tty_struct *tty =
						tty_port_tty_get(&port->port);
				if (tty && !C_CLOCAL(tty))
					tty_hangup(tty);
				tty_kref_put(tty);
			}
		} else {
			dbg("%s: type %x req %x", __func__,
				req_pkt->bRequestType, req_pkt->bRequest);
		}
	} else
		err("%s: error %d", __func__, status);

	/* Resubmit urb so we continue receiving IRQ data */
	if (status != -ESHUTDOWN && status != -ENOENT) {
		err = usb_submit_urb(urb, GFP_ATOMIC);
		if (err)
			dbg("%s: resubmit intr urb failed. (%d)",
				__func__, err);
	}
}

/** send RTS/DTR state to the port.
 *
 * This is exactly the same as SET_CONTROL_LINE_STATE from the PSTN
 * CDC.
*/
static int zte_send_setup(struct usb_serial_port *port)
{
	struct usb_serial *serial = port->serial;
	struct zte_intf_private *intfdata =
		(struct zte_intf_private *) serial->private;
	struct zte_port_private *portdata;
	int ifNum = serial->interface->cur_altsetting->desc.bInterfaceNumber;
	int val = 0;
	dbg("%s", __func__);

	if (is_blacklisted(ifNum, zte_BLACKLIST_SENDSETUP,
			(struct zte_blacklist_info *) intfdata->private)) {
		dbg("No send_setup on blacklisted interface #%d\n", ifNum);
		return -EIO;
	}

	portdata = usb_get_serial_port_data(port);

	if (portdata->dtr_state)
		val |= 0x01;
	if (portdata->rts_state)
		val |= 0x02;

	return usb_control_msg(serial->dev,
		usb_rcvctrlpipe(serial->dev, 0),
		0x22, 0x21, val, ifNum, NULL, 0, USB_CTRL_SET_TIMEOUT);
}

void zte_dtr_rts(struct usb_serial_port *port, int on)
{
	struct usb_serial *serial = port->serial;
	struct zte_port_private *portdata;

	struct zte_intf_private *intfdata;

	dbg("%s", __func__);

	intfdata = port->serial->private;

	if (!intfdata->send_setup)
		return;

	portdata = usb_get_serial_port_data(port);
	mutex_lock(&serial->disc_mutex);
	portdata->rts_state = on;
	portdata->dtr_state = on;
	if (serial->dev)
		intfdata->send_setup(port);
	mutex_unlock(&serial->disc_mutex);
}


void zte_set_termios(struct tty_struct *tty,
			  struct usb_serial_port *port,
			  struct ktermios *old_termios)
{
	struct zte_intf_private *intfdata = port->serial->private;

	dbg("%s", __func__);

	/* Doesn't support option setting */
	tty_termios_copy_hw(tty->termios, old_termios);

	if (intfdata->send_setup)
		intfdata->send_setup(port);
}


int zte_tiocmget(struct tty_struct *tty)
{
	struct usb_serial_port *port = tty->driver_data;
	unsigned int value;
	struct zte_port_private *portdata;

	portdata = usb_get_serial_port_data(port);

	value = ((portdata->rts_state) ? TIOCM_RTS : 0) |
	    ((portdata->dtr_state) ? TIOCM_DTR : 0) |
	    ((portdata->cts_state) ? TIOCM_CTS : 0) |
	    ((portdata->dsr_state) ? TIOCM_DSR : 0) |
	    ((portdata->dcd_state) ? TIOCM_CAR : 0) |
	    ((portdata->ri_state) ? TIOCM_RNG : 0);

	return value;
}


int zte_tiocmset(struct tty_struct *tty,
		      unsigned int set, unsigned int clear)
{
	struct usb_serial_port *port = tty->driver_data;
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata;

	portdata = usb_get_serial_port_data(port);
	intfdata = port->serial->private;

	if (!intfdata->send_setup)
		return -EINVAL;

	/* FIXME: what locks portdata fields ? */
	if (set & TIOCM_RTS)
		portdata->rts_state = 1;
	if (set & TIOCM_DTR)
		portdata->dtr_state = 1;

	if (clear & TIOCM_RTS)
		portdata->rts_state = 0;
	if (clear & TIOCM_DTR)
		portdata->dtr_state = 0;
	return intfdata->send_setup(port);
}


static int get_serial_info(struct usb_serial_port *port,
			   struct serial_struct __user *retinfo)
{
	struct serial_struct tmp;

	if (!retinfo)
		return -EFAULT;

	memset(&tmp, 0, sizeof(tmp));
	tmp.line            = port->serial->minor;
	tmp.port            = port->number;
	tmp.baud_base       = tty_get_baud_rate(port->port.tty);
	tmp.close_delay	    = port->port.close_delay / 10;
	tmp.closing_wait    = port->port.closing_wait == ASYNC_CLOSING_WAIT_NONE ?
				 ASYNC_CLOSING_WAIT_NONE :
				 port->port.closing_wait / 10;

	if (copy_to_user(retinfo, &tmp, sizeof(*retinfo)))
		return -EFAULT;
	return 0;
}

static int set_serial_info(struct usb_serial_port *port,
			   struct serial_struct __user *newinfo)
{
	struct serial_struct new_serial;
	unsigned int closing_wait, close_delay;
	int retval = 0;

	if (copy_from_user(&new_serial, newinfo, sizeof(new_serial)))
		return -EFAULT;

	close_delay = new_serial.close_delay * 10;
	closing_wait = new_serial.closing_wait == ASYNC_CLOSING_WAIT_NONE ?
			ASYNC_CLOSING_WAIT_NONE : new_serial.closing_wait * 10;

	mutex_lock(&port->port.mutex);

	if (!capable(CAP_SYS_ADMIN)) {
		if ((close_delay != port->port.close_delay) ||
		    (closing_wait != port->port.closing_wait))
			retval = -EPERM;
		else
			retval = -EOPNOTSUPP;
	} else {
		port->port.close_delay  = close_delay;
		port->port.closing_wait = closing_wait;
	}

	mutex_unlock(&port->port.mutex);
	return retval;
}

int zte_ioctl(struct tty_struct *tty,
		   unsigned int cmd, unsigned long arg)
{
	struct usb_serial_port *port = tty->driver_data;

	dbg("%s cmd 0x%04x", __func__, cmd);

	switch (cmd) {
	case TIOCGSERIAL:
		return get_serial_info(port,
				       (struct serial_struct __user *) arg);
	case TIOCSSERIAL:
		return set_serial_info(port,
				       (struct serial_struct __user *) arg);
	default:
		break;
	}

	dbg("%s arg not supported", __func__);

	return -ENOIOCTLCMD;
}


/* Write */
int zte_write(struct tty_struct *tty, struct usb_serial_port *port,
		   const unsigned char *buf, int count)
{
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata;
	int i;
	int left, todo;
	struct urb *this_urb = NULL;	/* spurious */
	int err;
	unsigned long flags;

	portdata = usb_get_serial_port_data(port);
	intfdata = port->serial->private;

	dbg("%s: write (%d chars)", __func__, count);

	i = 0;
	left = count;
	for (i = 0; left > 0 && i < N_OUT_URB; i++) {
		todo = left;
		if (todo > OUT_BUFLEN)
			todo = OUT_BUFLEN;

		this_urb = portdata->out_urbs[i];
		if (test_and_set_bit(i, &portdata->out_busy)) {
			if (time_before(jiffies,
					portdata->tx_start_time[i] + 10 * HZ))
				continue;
			usb_unlink_urb(this_urb);
			continue;
		}
		dbg("%s: endpoint %d buf %d", __func__,
		    usb_pipeendpoint(this_urb->pipe), i);

		err = usb_autopm_get_interface_async(port->serial->interface);
		if (err < 0)
			break;

		/* send the data */
		memcpy(this_urb->transfer_buffer, buf, todo);
		this_urb->transfer_buffer_length = todo;

		spin_lock_irqsave(&intfdata->susp_lock, flags);
		if (intfdata->suspended) {
			usb_anchor_urb(this_urb, &portdata->delayed);
			spin_unlock_irqrestore(&intfdata->susp_lock, flags);
		} else {
			intfdata->in_flight++;
			spin_unlock_irqrestore(&intfdata->susp_lock, flags);
			err = usb_submit_urb(this_urb, GFP_ATOMIC);
			if (err) {
				dbg("usb_submit_urb %p (write bulk) failed "
				    "(%d)", this_urb, err);
				clear_bit(i, &portdata->out_busy);
				spin_lock_irqsave(&intfdata->susp_lock, flags);
				intfdata->in_flight--;
				spin_unlock_irqrestore(&intfdata->susp_lock,
						       flags);
				usb_autopm_put_interface_async(port->serial->interface);
				break;
			}
		}

		portdata->tx_start_time[i] = jiffies;
		buf += todo;
		left -= todo;
	}

	count -= left;
	dbg("%s: wrote (did %d)", __func__, count);
	return count;
}


static void zte_indat_callback(struct urb *urb)
{
	int err;
	int endpoint;
	struct usb_serial_port *port;
	struct tty_struct *tty;
	unsigned char *data = urb->transfer_buffer;
	int status = urb->status;

	dbg("%s: %p", __func__, urb);

	endpoint = usb_pipeendpoint(urb->pipe);
	port = urb->context;

	if (status) {
		dbg("%s: nonzero status: %d on endpoint %02x.",
		    __func__, status, endpoint);
	} else {
		tty = tty_port_tty_get(&port->port);
		if (tty) {
			if (urb->actual_length) {
				tty_insert_flip_string(tty, data,
						urb->actual_length);
				tty_flip_buffer_push(tty);
			} else
				dbg("%s: empty read urb received", __func__);
			tty_kref_put(tty);
		}

		/* Resubmit urb so we continue receiving */
		if (status != -ESHUTDOWN) {
			err = usb_submit_urb(urb, GFP_ATOMIC);
			if (err) {
				if (err != -EPERM) {
					printk(KERN_ERR "%s: resubmit read urb failed. "
						"(%d)", __func__, err);
					/* busy also in error unless we are killed */
					usb_mark_last_busy(port->serial->dev);
				}
			} else {
				usb_mark_last_busy(port->serial->dev);
			}
		}

	}
}

static void zte_outdat_callback(struct urb *urb)
{
	struct usb_serial_port *port;
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata;
	int i;

	dbg("%s", __func__);

	port = urb->context;
	intfdata = port->serial->private;

	usb_serial_port_softint(port);
	usb_autopm_put_interface_async(port->serial->interface);
	portdata = usb_get_serial_port_data(port);
	spin_lock(&intfdata->susp_lock);
	intfdata->in_flight--;
	spin_unlock(&intfdata->susp_lock);

	for (i = 0; i < N_OUT_URB; ++i) {
		if (portdata->out_urbs[i] == urb) {
			smp_mb__before_clear_bit();
			clear_bit(i, &portdata->out_busy);
			break;
		}
	}
}

int zte_write_room(struct tty_struct *tty)
{
	struct usb_serial_port *port = tty->driver_data;
	struct zte_port_private *portdata;
	int i;
	int data_len = 0;
	struct urb *this_urb;

	portdata = usb_get_serial_port_data(port);

	for (i = 0; i < N_OUT_URB; i++) {
		this_urb = portdata->out_urbs[i];
		if (this_urb && !test_bit(i, &portdata->out_busy))
			data_len += OUT_BUFLEN;
	}

	dbg("%s: %d", __func__, data_len);
	return data_len;
}


int zte_chars_in_buffer(struct tty_struct *tty)
{
	struct usb_serial_port *port = tty->driver_data;
	struct zte_port_private *portdata;
	int i;
	int data_len = 0;
	struct urb *this_urb;

	portdata = usb_get_serial_port_data(port);

	for (i = 0; i < N_OUT_URB; i++) {
		this_urb = portdata->out_urbs[i];
		/* FIXME: This locking is insufficient as this_urb may
		   go unused during the test */
		if (this_urb && test_bit(i, &portdata->out_busy))
			data_len += this_urb->transfer_buffer_length;
	}
	dbg("%s: %d", __func__, data_len);
	return data_len;
}


int zte_open(struct tty_struct *tty, struct usb_serial_port *port)
{
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata;
	struct usb_serial *serial = port->serial;
	int i, err;
	struct urb *urb;

	portdata = usb_get_serial_port_data(port);
	intfdata = serial->private;

	dbg("%s", __func__);

	/* Start reading from the IN endpoint */
	for (i = 0; i < N_IN_URB; i++) {
		urb = portdata->in_urbs[i];
		if (!urb)
			continue;
		err = usb_submit_urb(urb, GFP_KERNEL);
		if (err) {
			dbg("%s: submit urb %d failed (%d) %d",
			    __func__, i, err, urb->transfer_buffer_length);
		}
	}

	if (intfdata->send_setup)
		intfdata->send_setup(port);

	serial->interface->needs_remote_wakeup = 1;
	spin_lock_irq(&intfdata->susp_lock);
	portdata->opened = 1;
	spin_unlock_irq(&intfdata->susp_lock);
	/* this balances a get in the generic USB serial code */
	usb_autopm_put_interface(serial->interface);

	return 0;
}


void zte_close(struct usb_serial_port *port)
{
	int i;
	struct usb_serial *serial = port->serial;
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata = port->serial->private;

	dbg("%s", __func__);
	portdata = usb_get_serial_port_data(port);

	if (serial->dev) {
		/* Stop reading/writing urbs */
		spin_lock_irq(&intfdata->susp_lock);
		portdata->opened = 0;
		spin_unlock_irq(&intfdata->susp_lock);

		for (i = 0; i < N_IN_URB; i++)
			usb_kill_urb(portdata->in_urbs[i]);
		for (i = 0; i < N_OUT_URB; i++)
			usb_kill_urb(portdata->out_urbs[i]);
		/* balancing - important as an error cannot be handled*/
		usb_autopm_get_interface_no_resume(serial->interface);
		serial->interface->needs_remote_wakeup = 0;
	}
}


/* Helper functions used by zte_setup_urbs */
static struct urb *zte_setup_urb(struct usb_serial *serial, int endpoint,
				      int dir, void *ctx, char *buf, int len,
				      void (*callback) (struct urb *))
{
	struct urb *urb;

	if (endpoint == -1)
		return NULL;	/* endpoint not needed */

	urb = usb_alloc_urb(0, GFP_KERNEL);	/* No ISO */
	if (urb == NULL) {
		dbg("%s: alloc for endpoint %d failed.", __func__, endpoint);
		return NULL;
	}

	/* Fill URB using supplied data. */
	usb_fill_bulk_urb(urb, serial->dev,
			  usb_sndbulkpipe(serial->dev, endpoint) | dir,
			  buf, len, callback, ctx);

	return urb;
}

/* Setup urbs */
static void zte_setup_urbs(struct usb_serial *serial)
{
	int i, j;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;

	dbg("%s", __func__);

	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);

		/* Do indat endpoints first */
		for (j = 0; j < N_IN_URB; ++j) {
			portdata->in_urbs[j] = zte_setup_urb(serial,
								  port->
								  bulk_in_endpointAddress,
								  USB_DIR_IN,
								  port,
								  portdata->
								  in_buffer[j],
								  IN_BUFLEN,
								  zte_indat_callback);
		}

		/* outdat endpoints */
		for (j = 0; j < N_OUT_URB; ++j) {
			portdata->out_urbs[j] = zte_setup_urb(serial,
								   port->
								   bulk_out_endpointAddress,
								   USB_DIR_OUT,
								   port,
								   portdata->
								   out_buffer
								   [j],
								   OUT_BUFLEN,
								   zte_outdat_callback);
		}
	}
}

int zte_startup(struct usb_serial *serial)
{
	int i, j, err;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;
	u8 *buffer;

	dbg("%s", __func__);

	/* Now setup per port private data */
	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		portdata = kzalloc(sizeof(*portdata), GFP_KERNEL);
		if (!portdata) {
			dbg("%s: kmalloc for zte_port_private (%d) failed!.",
			    __func__, i);
			return 1;
		}
		init_usb_anchor(&portdata->delayed);

		for (j = 0; j < N_IN_URB; j++) {
			buffer = (u8 *) __get_free_page(GFP_KERNEL);
			if (!buffer)
				goto bail_out_error;
			portdata->in_buffer[j] = buffer;
		}

		for (j = 0; j < N_OUT_URB; j++) {
			buffer = kmalloc(OUT_BUFLEN, GFP_KERNEL);
			if (!buffer)
				goto bail_out_error2;
			portdata->out_buffer[j] = buffer;
		}

		usb_set_serial_port_data(port, portdata);

		if (!port->interrupt_in_urb)
			continue;
		err = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);
		if (err)
			dbg("%s: submit irq_in urb failed %d", __func__, err);
	}
	zte_setup_urbs(serial);
	return 0;

bail_out_error2:
	for (j = 0; j < N_OUT_URB; j++)
		kfree(portdata->out_buffer[j]);
bail_out_error:
	for (j = 0; j < N_IN_URB; j++)
		if (portdata->in_buffer[j])
			free_page((unsigned long)portdata->in_buffer[j]);
	kfree(portdata);
	return 1;
}


static void stop_read_write_urbs(struct usb_serial *serial)
{
	int i, j;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;

	/* Stop reading/writing urbs */
	for (i = 0; i < serial->num_ports; ++i) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);
		for (j = 0; j < N_IN_URB; j++)
			usb_kill_urb(portdata->in_urbs[j]);
		for (j = 0; j < N_OUT_URB; j++)
			usb_kill_urb(portdata->out_urbs[j]);
	}
}

void zte_disconnect(struct usb_serial *serial)
{
	dbg("%s", __func__);

	stop_read_write_urbs(serial);
}


void zte_release(struct usb_serial *serial)
{
	int i, j;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;

	dbg("%s", __func__);

	/* Now free them */
	for (i = 0; i < serial->num_ports; ++i) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);

		for (j = 0; j < N_IN_URB; j++) {
			usb_free_urb(portdata->in_urbs[j]);
			free_page((unsigned long)
				  portdata->in_buffer[j]);
			portdata->in_urbs[j] = NULL;
		}
		for (j = 0; j < N_OUT_URB; j++) {
			usb_free_urb(portdata->out_urbs[j]);
			kfree(portdata->out_buffer[j]);
			portdata->out_urbs[j] = NULL;
		}
	}

	/* Now free per port private data */
	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		kfree(usb_get_serial_port_data(port));
	}
}


#ifdef CONFIG_PM
int zte_suspend(struct usb_serial *serial, pm_message_t message)
{
	struct zte_intf_private *intfdata = serial->private;
	int b;

	dbg("%s entered", __func__);

	if (PMSG_IS_AUTO(message)) {
		spin_lock_irq(&intfdata->susp_lock);
		b = intfdata->in_flight;
		spin_unlock_irq(&intfdata->susp_lock);

		if (b)
			return -EBUSY;
	}

	spin_lock_irq(&intfdata->susp_lock);
	intfdata->suspended = 1;
	spin_unlock_irq(&intfdata->susp_lock);
	stop_read_write_urbs(serial);

	return 0;
}


static void unbusy_queued_urb(struct urb *urb, struct zte_port_private *portdata)
{
	int i;

	for (i = 0; i < N_OUT_URB; i++) {
		if (urb == portdata->out_urbs[i]) {
			clear_bit(i, &portdata->out_busy);
			break;
		}
	}
}

static void play_delayed(struct usb_serial_port *port)
{
	struct zte_intf_private *data;
	struct zte_port_private *portdata;
	struct urb *urb;
	int err;

	portdata = usb_get_serial_port_data(port);
	data = port->serial->private;
	while ((urb = usb_get_from_anchor(&portdata->delayed))) {
		err = usb_submit_urb(urb, GFP_ATOMIC);
		if (!err) {
			data->in_flight++;
		} else {
			/* we have to throw away the rest */
			do {
				unbusy_queued_urb(urb, portdata);
				usb_autopm_put_interface_no_suspend(port->serial->interface);
			} while ((urb = usb_get_from_anchor(&portdata->delayed)));
			break;
		}
	}
}

int zte_resume(struct usb_serial *serial)
{
	int i, j;
	struct usb_serial_port *port;
	struct zte_intf_private *intfdata = serial->private;
	struct zte_port_private *portdata;
	struct urb *urb;
	int err = 0;

	dbg("%s entered", __func__);
	/* get the interrupt URBs resubmitted unconditionally */
	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		if (!port->interrupt_in_urb) {
			dbg("%s: No interrupt URB for port %d", __func__, i);
			continue;
		}
		err = usb_submit_urb(port->interrupt_in_urb, GFP_NOIO);
		dbg("Submitted interrupt URB for port %d (result %d)", i, err);
		if (err < 0) {
			err("%s: Error %d for interrupt URB of port%d",
			    __func__, err, i);
			goto err_out;
		}
	}

	for (i = 0; i < serial->num_ports; i++) {
		/* walk all ports */
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);

		/* skip closed ports */
		spin_lock_irq(&intfdata->susp_lock);
		if (!portdata->opened) {
			spin_unlock_irq(&intfdata->susp_lock);
			continue;
		}

		for (j = 0; j < N_IN_URB; j++) {
			urb = portdata->in_urbs[j];
			err = usb_submit_urb(urb, GFP_ATOMIC);
			if (err < 0) {
				err("%s: Error %d for bulk URB %d",
				    __func__, err, i);
				spin_unlock_irq(&intfdata->susp_lock);
				goto err_out;
			}
		}
		play_delayed(port);
		spin_unlock_irq(&intfdata->susp_lock);
	}
	spin_lock_irq(&intfdata->susp_lock);
	intfdata->suspended = 0;
	spin_unlock_irq(&intfdata->susp_lock);
err_out:
	return err;
}

#endif

MODULE_AUTHOR(DRIVER_AUTHOR);
MODULE_DESCRIPTION(DRIVER_DESC);
MODULE_VERSION(DRIVER_VERSION);
MODULE_LICENSE("GPL");

module_param(debug, bool, S_IRUGO | S_IWUSR);
MODULE_PARM_DESC(debug, "Debug messages");

#elif LINUX_VERSION_CODE < KERNEL_VERSION(3,4,0)//use  3.3.8 sourcecode

#include <linux/kernel.h>
#include <linux/jiffies.h>
#include <linux/errno.h>
#include <linux/tty.h>
#include <linux/tty_flip.h>
#include <linux/slab.h>
#include <linux/module.h>
#include <linux/bitops.h>
#include <linux/usb.h>
#include <linux/usb/serial.h>
#include <linux/uaccess.h>
#include <linux/serial.h>


/* Function prototypes */
static int  zte_probe(struct usb_serial *serial,
			const struct usb_device_id *id);
static int zte_send_setup(struct usb_serial_port *port);
static void zte_instat_callback(struct urb *urb);
void zte_dtr_rts(struct usb_serial_port *port, int on);
int zte_open(struct tty_struct *tty, struct usb_serial_port *port);
void zte_close(struct usb_serial_port *port);
int zte_startup(struct usb_serial *serial);
void zte_disconnect(struct usb_serial *serial);
void zte_release(struct usb_serial *serial);
int zte_write_room(struct tty_struct *tty);
void zte_set_termios(struct tty_struct *tty,
				 struct usb_serial_port *port,
				 struct ktermios *old);
int zte_tiocmget(struct tty_struct *tty);
int zte_tiocmset(struct tty_struct *tty,
			     unsigned int set, unsigned int clear);
int zte_ioctl(struct tty_struct *tty,
			  unsigned int cmd, unsigned long arg);
int zte_send_setup(struct usb_serial_port *port);
int zte_write(struct tty_struct *tty, struct usb_serial_port *port,
			  const unsigned char *buf, int count);
int zte_chars_in_buffer(struct tty_struct *tty);
#ifdef CONFIG_PM
 int zte_suspend(struct usb_serial *serial, pm_message_t message);
 int zte_resume(struct usb_serial *serial);
#endif

/* Vendor and product IDs */
/* ZTE PRODUCTS */
#define zte_VENDOR_ID				0x19d2

/* some devices interfaces need special handling due to a number of reasons */
enum zte_blacklist_reason {
		zte_BLACKLIST_NONE = 0,
		zte_BLACKLIST_SENDSETUP = 1,
		zte_BLACKLIST_RESERVED_IF = 2
};

#define MAX_BL_NUM  8
struct zte_blacklist_info {
	/* bitfield of interface numbers for zte_BLACKLIST_SENDSETUP */
	const unsigned long sendsetup;
	/* bitfield of interface numbers for zte_BLACKLIST_RESERVED_IF */
	const unsigned long reserved;
};

static const struct zte_blacklist_info four_g_w14_blacklist = {
	.sendsetup = BIT(0) | BIT(1),
};

static const struct zte_blacklist_info alcatel_x200_blacklist = {
	.sendsetup = BIT(0) | BIT(1),
};

static const struct zte_blacklist_info zte_0037_blacklist = {
	.sendsetup = BIT(0) | BIT(1),
};

static const struct zte_blacklist_info zte_k3765_z_blacklist = {
	.sendsetup = BIT(0) | BIT(1) | BIT(2),
	.reserved = BIT(4),
};

static const struct zte_blacklist_info zte_ad3812_z_blacklist = {
	.sendsetup = BIT(0) | BIT(1) | BIT(2),
};

static const struct zte_blacklist_info zte_mc2718_z_blacklist = {
	.sendsetup = BIT(1) | BIT(2) | BIT(3) | BIT(4),
};

static const struct zte_blacklist_info zte_mc2716_z_blacklist = {
	.sendsetup = BIT(1) | BIT(2) | BIT(3),
};

static const struct zte_blacklist_info huawei_cdc12_blacklist = {
	.reserved = BIT(1) | BIT(2),
};

static const struct zte_blacklist_info net_intf1_blacklist = {
	.reserved = BIT(1),
};

static const struct zte_blacklist_info net_intf3_blacklist = {
	.reserved = BIT(3),
};

static const struct zte_blacklist_info net_intf4_blacklist = {
	.reserved = BIT(4),
};

static const struct zte_blacklist_info net_intf5_blacklist = {
	.reserved = BIT(5),
};

static const struct zte_blacklist_info zte_mf626_blacklist = {
	.sendsetup = BIT(0) | BIT(1),
	.reserved = BIT(4),
};

static const struct usb_device_id zte_ids[] = {
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0001, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0002, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0003, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0004, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0005, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0006, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0007, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0008, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0009, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0010, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0011, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0012, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0013, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0014, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0015, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0016, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0017, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0018, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0019, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0020, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0021, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0022, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0023, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0024, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0025, 0xff, 0xff, 0xff) },
    //   { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0026, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0027, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0028, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0029, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0030, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0031, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0032, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0033, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0034, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0035, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0036, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0037, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0038, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0039, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0040, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0041, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0042, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0043, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0044, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0045, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0046, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0047, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0048, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0049, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0050, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0051, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0052, 0xff, 0xff, 0xff) },
    //   { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0053, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0054, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0055, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0056, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0057, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0058, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0059, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0060, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0061, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0062, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0063, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0064, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0065, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0066, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0067, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0068, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0069, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0070, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0071, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0072, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0073, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0074, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0075, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0076, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0077, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0078, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0079, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0080, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0081, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0082, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0083, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0084, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0085, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0086, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0087, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0088, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0089, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0090, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0091, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0092, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0093, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0094, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0095, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0096, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0097, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0098, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0099, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0104, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0105, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0106, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0108, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0117, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0118, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0121, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0122, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0123, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0124, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0125, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0126, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0128, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0130, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0133, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0135, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0136, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0137, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0139, 0xff, 0xff, 0xff) }, 	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0141, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0144, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0145, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0147, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0148, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0151, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0152, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0153, 0xff, 0xff, 0xff) },
    //{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0154, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0155, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0156, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0157, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0158, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0159, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0160, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0161, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0162, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0164, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0165, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0167, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0168, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0170, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0176, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0178, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0189, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0191, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0196, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0197, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0199, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0200, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0201, 0xff, 0xff, 0xff) },		
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0254, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0257, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0265, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0284, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0317, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0330, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0395, 0xff, 0xff, 0xff) },      
 	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0414, 0xff, 0xff, 0xff) },   
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0417, 0xff, 0xff, 0xff) },

    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1008, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1010, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1012, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1018, 0xff, 0xff, 0xff) },		
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1057, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1058, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1059, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1060, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1061, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1062, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1063, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1064, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1065, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1066, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1067, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1068, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1069, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1070, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1071, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1072, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1073, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1074, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1075, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1076, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1077, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1078, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1079, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1080, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1081, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1082, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1083, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1084, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1085, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1086, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1087, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1088, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1089, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1090, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1091, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1092, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1093, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1094, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1095, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1096, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1097, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1098, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1099, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1100, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1101, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1102, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1103, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1104, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1105, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1106, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1107, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1108, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1109, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1110, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1111, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1112, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1113, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1114, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1115, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1116, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1117, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1118, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1119, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1120, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1121, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1122, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1123, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1124, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1125, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1126, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1127, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1128, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1129, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1130, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1131, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1132, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1133, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1134, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1135, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1136, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1137, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1138, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1139, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1140, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1141, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1142, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1143, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1144, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1145, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1146, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1147, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1148, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1149, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1150, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1151, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1152, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1153, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1154, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1155, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1156, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1157, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1158, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1159, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1160, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1161, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1162, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1163, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1164, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1165, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1166, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1167, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1168, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1169, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1170, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1244, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1245, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1246, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1247, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1248, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1249, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1250, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1251, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1252, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1253, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1254, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1255, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1256, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1257, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1258, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1259, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1260, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1261, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1262, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1263, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1264, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1265, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1266, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1267, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1268, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1269, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1270, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1271, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1272, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1273, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1274, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1275, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1276, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1277, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1278, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1279, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1280, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1281, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1282, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1283, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1284, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1285, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1286, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1287, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1288, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1289, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1290, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1291, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1292, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1293, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1294, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1295, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1296, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1297, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1298, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1299, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1300, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1301, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1302, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1303, 0xff, 0xff, 0xff) },	
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1333, 0xff, 0xff, 0xff) },	
	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1401, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1402, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1403, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1404, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1405, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1406, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1407, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1408, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1409, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1410, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1411, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1412, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1413, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1414, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1415, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1416, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1417, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1418, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1419, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1420, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1421, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1422, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1423, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1424, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1425, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1426, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1427, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1428, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1429, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1430, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1431, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1432, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1433, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1434, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1435, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1436, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1437, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1438, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1439, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1440, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1441, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1442, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1443, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1444, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1445, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1446, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1447, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1448, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1449, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1450, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1451, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1452, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1453, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1454, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1455, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1456, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1457, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1458, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1459, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1460, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1461, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1462, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1463, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1464, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1465, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1466, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1467, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1468, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1469, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1470, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1471, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1472, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1473, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1474, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1475, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1476, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1477, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1478, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1479, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1480, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1481, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1482, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1483, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1484, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1485, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1486, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1487, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1488, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1489, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1490, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1491, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1492, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1493, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1494, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1495, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1496, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1497, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1498, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1499, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1500, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1501, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1502, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1503, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1504, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1505, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1506, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1507, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1508, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1509, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1510, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1533, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1534, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1535, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1545, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1546, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1547, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1565, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1566, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1567, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1589, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1590, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1591, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1592, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1594, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1596, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1598, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1600, 0xff, 0xff, 0xff) },  		
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x2002, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x2003, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0xFFEC, 0xff, 0xff, 0xff) },
    { ZTE_USB_DEVICE_ID_MATCH_INT_CLASS_AND_SUBCLASS_INFO(0x19d2,0xff,0x86) },
    { ZTE_USB_DEVICE_ID_MATCH_INT_CLASS_AND_SUBCLASS_INFO(0x19d2,0xff,0x02) },
    { USB_DEVICE_AND_INTERFACE_INFO(TPLink_VENDOR_ID, 0x7E11, 0xff, 0xff, 0xff) },/*TPLink*/
    { USB_DEVICE_AND_INTERFACE_INFO(QUALCOMM_VENDOR_ID, 0x9001, 0xff, 0xff, 0xff) },/*QUALCOMM_VENDOR_ID*/
    { USB_DEVICE_AND_INTERFACE_INFO(QUALCOMM_VENDOR_ID, 0x9002, 0xff, 0xff, 0xff) },
	{ } /* Terminating entry */
};
MODULE_DEVICE_TABLE(usb, zte_ids);

static struct usb_driver zte_driver = {
	.name       = "zte",
	.probe      = usb_serial_probe,
	.disconnect = usb_serial_disconnect,
#ifdef CONFIG_PM
	.suspend    = usb_serial_suspend,
	.resume     = usb_serial_resume,
	.supports_autosuspend =	1,
#endif
	.id_table   = zte_ids,
	.no_dynamic_id = 	1,
};

/* The card has three separate interfaces, which the serial driver
 * recognizes separately, thus num_port=1.
 */

static struct usb_serial_driver zte_1port_device = {
	.driver = {
		.owner =	THIS_MODULE,
		.name =		"zte1",
	},
	.description       = "GSM modem (1-port)",
	.usb_driver        = &zte_driver,
	.id_table          = zte_ids,
	.num_ports         = 1,
	.probe             = zte_probe,
	.open              = zte_open,
	.close             = zte_close,
	.dtr_rts	   = zte_dtr_rts,
	.write             = zte_write,
	.write_room        = zte_write_room,
	.chars_in_buffer   = zte_chars_in_buffer,
	.set_termios       = zte_set_termios,
	.tiocmget          = zte_tiocmget,
	.tiocmset          = zte_tiocmset,
	.ioctl             = zte_ioctl,
	.attach            = zte_startup,
	.disconnect        = zte_disconnect,
	.release           = zte_release,
	.read_int_callback = zte_instat_callback,
#ifdef CONFIG_PM
	.suspend           = zte_suspend,
	.resume            = zte_resume,
#endif
};

static bool debug;

/* per port private data */

#define N_IN_URB 4
#define N_OUT_URB 4
#define IN_BUFLEN 4096
#define OUT_BUFLEN 4096

struct zte_intf_private {
	spinlock_t susp_lock;
	unsigned int suspended:1;
	int in_flight;
	int (*send_setup) (struct usb_serial_port *port);
	void *private;
};

struct zte_port_private {
	/* Input endpoints and buffer for this port */
	struct urb *in_urbs[N_IN_URB];
	u8 *in_buffer[N_IN_URB];
	/* Output endpoints and buffer for this port */
	struct urb *out_urbs[N_OUT_URB];
	u8 *out_buffer[N_OUT_URB];
	unsigned long out_busy;		/* Bit vector of URBs in use */
	int opened;
	struct usb_anchor delayed;

	/* Settings for the port */
	int rts_state;	/* Handshaking pins (outputs) */
	int dtr_state;
	int cts_state;	/* Handshaking pins (inputs) */
	int dsr_state;
	int dcd_state;
	int ri_state;

	unsigned long tx_start_time[N_OUT_URB];
};

/* Functions used by new usb-serial code. */
static int __init zte_init(void)
{
	int retval;
	retval = usb_serial_register(&zte_1port_device);
	if (retval)
		goto failed_1port_device_register;
	retval = usb_register(&zte_driver);
	if (retval)
		goto failed_driver_register;

	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
	       DRIVER_DESC "\n");

	return 0;

failed_driver_register:
	usb_serial_deregister(&zte_1port_device);
failed_1port_device_register:
	return retval;
}

static void __exit zte_exit(void)
{
	usb_deregister(&zte_driver);
	usb_serial_deregister(&zte_1port_device);
}

module_init(zte_init);
module_exit(zte_exit);

static int zte_probe(struct usb_serial *serial,
			const struct usb_device_id *id)
{
	struct zte_intf_private *data;
       
	data = serial->private = kzalloc(sizeof(struct zte_intf_private), GFP_KERNEL);
	if (!data)
		return -ENOMEM;
	data->send_setup = zte_send_setup;
	spin_lock_init(&data->susp_lock);
	data->private = (void *)id->driver_info;
	return 0;
}

static bool is_blacklisted(const u8 ifnum, enum zte_blacklist_reason reason,
			   const struct zte_blacklist_info *blacklist)
{
	unsigned long num;
	const unsigned long *intf_list;

	if (blacklist) {
		if (reason == zte_BLACKLIST_SENDSETUP)
			intf_list = &blacklist->sendsetup;
		else if (reason == zte_BLACKLIST_RESERVED_IF)
			intf_list = &blacklist->reserved;
		else {
			BUG_ON(reason);
			return false;
		}

		for_each_set_bit(num, intf_list, MAX_BL_NUM + 1) {
			if (num == ifnum)
				return true;
		}
	}
	return false;
}

static void zte_instat_callback(struct urb *urb)
{
	int err;
	int status = urb->status;
	struct usb_serial_port *port =  urb->context;
	struct zte_port_private *portdata = usb_get_serial_port_data(port);

	dbg("%s", __func__);
	dbg("%s: urb %p port %p has data %p", __func__, urb, port, portdata);

	if (status == 0) {
		struct usb_ctrlrequest *req_pkt =
				(struct usb_ctrlrequest *)urb->transfer_buffer;

		if (!req_pkt) {
			dbg("%s: NULL req_pkt", __func__);
			return;
		}
		if ((req_pkt->bRequestType == 0xA1) &&
				(req_pkt->bRequest == 0x20)) {
			int old_dcd_state;
			unsigned char signals = *((unsigned char *)
					urb->transfer_buffer +
					sizeof(struct usb_ctrlrequest));

			dbg("%s: signal x%x", __func__, signals);

			old_dcd_state = portdata->dcd_state;
			portdata->cts_state = 1;
			portdata->dcd_state = ((signals & 0x01) ? 1 : 0);
			portdata->dsr_state = ((signals & 0x02) ? 1 : 0);
			portdata->ri_state = ((signals & 0x08) ? 1 : 0);

			if (old_dcd_state && !portdata->dcd_state) {
				struct tty_struct *tty =
						tty_port_tty_get(&port->port);
				if (tty && !C_CLOCAL(tty))
					tty_hangup(tty);
				tty_kref_put(tty);
			}
		} else {
			dbg("%s: type %x req %x", __func__,
				req_pkt->bRequestType, req_pkt->bRequest);
		}
	} else
		err("%s: error %d", __func__, status);

	/* Resubmit urb so we continue receiving IRQ data */
	if (status != -ESHUTDOWN && status != -ENOENT) {
		err = usb_submit_urb(urb, GFP_ATOMIC);
		if (err)
			dbg("%s: resubmit intr urb failed. (%d)",
				__func__, err);
	}
}

/** send RTS/DTR state to the port.
 *
 * This is exactly the same as SET_CONTROL_LINE_STATE from the PSTN
 * CDC.
*/
static int zte_send_setup(struct usb_serial_port *port)
{
	struct usb_serial *serial = port->serial;
	struct zte_intf_private *intfdata =
		(struct zte_intf_private *) serial->private;
	struct zte_port_private *portdata;
	int ifNum = serial->interface->cur_altsetting->desc.bInterfaceNumber;
	int val = 0;
	dbg("%s", __func__);

	if (is_blacklisted(ifNum, zte_BLACKLIST_SENDSETUP,
			(struct zte_blacklist_info *) intfdata->private)) {
		dbg("No send_setup on blacklisted interface #%d\n", ifNum);
		return -EIO;
	}

	portdata = usb_get_serial_port_data(port);

	if (portdata->dtr_state)
		val |= 0x01;
	if (portdata->rts_state)
		val |= 0x02;

	return usb_control_msg(serial->dev,
		usb_rcvctrlpipe(serial->dev, 0),
		0x22, 0x21, val, ifNum, NULL, 0, USB_CTRL_SET_TIMEOUT);
}

void zte_dtr_rts(struct usb_serial_port *port, int on)
{
	struct usb_serial *serial = port->serial;
	struct zte_port_private *portdata;

	struct zte_intf_private *intfdata;

	dbg("%s", __func__);

	intfdata = port->serial->private;

	if (!intfdata->send_setup)
		return;

	portdata = usb_get_serial_port_data(port);
	mutex_lock(&serial->disc_mutex);
	portdata->rts_state = on;
	portdata->dtr_state = on;
	if (serial->dev)
		intfdata->send_setup(port);
	mutex_unlock(&serial->disc_mutex);
}


void zte_set_termios(struct tty_struct *tty,
			  struct usb_serial_port *port,
			  struct ktermios *old_termios)
{
	struct zte_intf_private *intfdata = port->serial->private;

	dbg("%s", __func__);

	/* Doesn't support option setting */
	tty_termios_copy_hw(tty->termios, old_termios);

	if (intfdata->send_setup)
		intfdata->send_setup(port);
}


int zte_tiocmget(struct tty_struct *tty)
{
	struct usb_serial_port *port = tty->driver_data;
	unsigned int value;
	struct zte_port_private *portdata;

	portdata = usb_get_serial_port_data(port);

	value = ((portdata->rts_state) ? TIOCM_RTS : 0) |
	    ((portdata->dtr_state) ? TIOCM_DTR : 0) |
	    ((portdata->cts_state) ? TIOCM_CTS : 0) |
	    ((portdata->dsr_state) ? TIOCM_DSR : 0) |
	    ((portdata->dcd_state) ? TIOCM_CAR : 0) |
	    ((portdata->ri_state) ? TIOCM_RNG : 0);

	return value;
}


int zte_tiocmset(struct tty_struct *tty,
		      unsigned int set, unsigned int clear)
{
	struct usb_serial_port *port = tty->driver_data;
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata;

	portdata = usb_get_serial_port_data(port);
	intfdata = port->serial->private;

	if (!intfdata->send_setup)
		return -EINVAL;

	/* FIXME: what locks portdata fields ? */
	if (set & TIOCM_RTS)
		portdata->rts_state = 1;
	if (set & TIOCM_DTR)
		portdata->dtr_state = 1;

	if (clear & TIOCM_RTS)
		portdata->rts_state = 0;
	if (clear & TIOCM_DTR)
		portdata->dtr_state = 0;
	return intfdata->send_setup(port);
}


static int get_serial_info(struct usb_serial_port *port,
			   struct serial_struct __user *retinfo)
{
	struct serial_struct tmp;

	if (!retinfo)
		return -EFAULT;

	memset(&tmp, 0, sizeof(tmp));
	tmp.line            = port->serial->minor;
	tmp.port            = port->number;
	tmp.baud_base       = tty_get_baud_rate(port->port.tty);
	tmp.close_delay	    = port->port.close_delay / 10;
	tmp.closing_wait    = port->port.closing_wait == ASYNC_CLOSING_WAIT_NONE ?
				 ASYNC_CLOSING_WAIT_NONE :
				 port->port.closing_wait / 10;

	if (copy_to_user(retinfo, &tmp, sizeof(*retinfo)))
		return -EFAULT;
	return 0;
}

static int set_serial_info(struct usb_serial_port *port,
			   struct serial_struct __user *newinfo)
{
	struct serial_struct new_serial;
	unsigned int closing_wait, close_delay;
	int retval = 0;

	if (copy_from_user(&new_serial, newinfo, sizeof(new_serial)))
		return -EFAULT;

	close_delay = new_serial.close_delay * 10;
	closing_wait = new_serial.closing_wait == ASYNC_CLOSING_WAIT_NONE ?
			ASYNC_CLOSING_WAIT_NONE : new_serial.closing_wait * 10;

	mutex_lock(&port->port.mutex);

	if (!capable(CAP_SYS_ADMIN)) {
		if ((close_delay != port->port.close_delay) ||
		    (closing_wait != port->port.closing_wait))
			retval = -EPERM;
		else
			retval = -EOPNOTSUPP;
	} else {
		port->port.close_delay  = close_delay;
		port->port.closing_wait = closing_wait;
	}

	mutex_unlock(&port->port.mutex);
	return retval;
}

int zte_ioctl(struct tty_struct *tty,
		   unsigned int cmd, unsigned long arg)
{
	struct usb_serial_port *port = tty->driver_data;

	dbg("%s cmd 0x%04x", __func__, cmd);

	switch (cmd) {
	case TIOCGSERIAL:
		return get_serial_info(port,
				       (struct serial_struct __user *) arg);
	case TIOCSSERIAL:
		return set_serial_info(port,
				       (struct serial_struct __user *) arg);
	default:
		break;
	}

	dbg("%s arg not supported", __func__);

	return -ENOIOCTLCMD;
}


/* Write */
int zte_write(struct tty_struct *tty, struct usb_serial_port *port,
		   const unsigned char *buf, int count)
{
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata;
	int i;
	int left, todo;
	struct urb *this_urb = NULL;	/* spurious */
	int err;
	unsigned long flags;

	portdata = usb_get_serial_port_data(port);
	intfdata = port->serial->private;

	dbg("%s: write (%d chars)", __func__, count);

	i = 0;
	left = count;
	for (i = 0; left > 0 && i < N_OUT_URB; i++) {
		todo = left;
		if (todo > OUT_BUFLEN)
			todo = OUT_BUFLEN;

		this_urb = portdata->out_urbs[i];
		if (test_and_set_bit(i, &portdata->out_busy)) {
			if (time_before(jiffies,
					portdata->tx_start_time[i] + 10 * HZ))
				continue;
			usb_unlink_urb(this_urb);
			continue;
		}
		dbg("%s: endpoint %d buf %d", __func__,
		    usb_pipeendpoint(this_urb->pipe), i);

		err = usb_autopm_get_interface_async(port->serial->interface);
		if (err < 0)
			break;

		/* send the data */
		memcpy(this_urb->transfer_buffer, buf, todo);
		this_urb->transfer_buffer_length = todo;

		spin_lock_irqsave(&intfdata->susp_lock, flags);
		if (intfdata->suspended) {
			usb_anchor_urb(this_urb, &portdata->delayed);
			spin_unlock_irqrestore(&intfdata->susp_lock, flags);
		} else {
			intfdata->in_flight++;
			spin_unlock_irqrestore(&intfdata->susp_lock, flags);
			err = usb_submit_urb(this_urb, GFP_ATOMIC);
			if (err) {
				dbg("usb_submit_urb %p (write bulk) failed "
				    "(%d)", this_urb, err);
				clear_bit(i, &portdata->out_busy);
				spin_lock_irqsave(&intfdata->susp_lock, flags);
				intfdata->in_flight--;
				spin_unlock_irqrestore(&intfdata->susp_lock,
						       flags);
				usb_autopm_put_interface_async(port->serial->interface);
				break;
			}
		}

		portdata->tx_start_time[i] = jiffies;
		buf += todo;
		left -= todo;
	}

	count -= left;
	dbg("%s: wrote (did %d)", __func__, count);
	return count;
}


static void zte_indat_callback(struct urb *urb)
{
	int err;
	int endpoint;
	struct usb_serial_port *port;
	struct tty_struct *tty;
	unsigned char *data = urb->transfer_buffer;
	int status = urb->status;

	dbg("%s: %p", __func__, urb);

	endpoint = usb_pipeendpoint(urb->pipe);
	port = urb->context;

	if (status) {
		dbg("%s: nonzero status: %d on endpoint %02x.",
		    __func__, status, endpoint);
	} else {
		tty = tty_port_tty_get(&port->port);
		if (tty) {
			if (urb->actual_length) {
				tty_insert_flip_string(tty, data,
						urb->actual_length);
				tty_flip_buffer_push(tty);
			} else
				dbg("%s: empty read urb received", __func__);
			tty_kref_put(tty);
		}

		/* Resubmit urb so we continue receiving */
		if (status != -ESHUTDOWN) {
			err = usb_submit_urb(urb, GFP_ATOMIC);
			if (err) {
				if (err != -EPERM) {
					printk(KERN_ERR "%s: resubmit read urb failed. "
						"(%d)", __func__, err);
					/* busy also in error unless we are killed */
					usb_mark_last_busy(port->serial->dev);
				}
			} else {
				usb_mark_last_busy(port->serial->dev);
			}
		}

	}
}

static void zte_outdat_callback(struct urb *urb)
{
	struct usb_serial_port *port;
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata;
	int i;

	dbg("%s", __func__);

	port = urb->context;
	intfdata = port->serial->private;

	usb_serial_port_softint(port);
	usb_autopm_put_interface_async(port->serial->interface);
	portdata = usb_get_serial_port_data(port);
	spin_lock(&intfdata->susp_lock);
	intfdata->in_flight--;
	spin_unlock(&intfdata->susp_lock);

	for (i = 0; i < N_OUT_URB; ++i) {
		if (portdata->out_urbs[i] == urb) {
			smp_mb__before_clear_bit();
			clear_bit(i, &portdata->out_busy);
			break;
		}
	}
}

int zte_write_room(struct tty_struct *tty)
{
	struct usb_serial_port *port = tty->driver_data;
	struct zte_port_private *portdata;
	int i;
	int data_len = 0;
	struct urb *this_urb;

	portdata = usb_get_serial_port_data(port);

	for (i = 0; i < N_OUT_URB; i++) {
		this_urb = portdata->out_urbs[i];
		if (this_urb && !test_bit(i, &portdata->out_busy))
			data_len += OUT_BUFLEN;
	}

	dbg("%s: %d", __func__, data_len);
	return data_len;
}


int zte_chars_in_buffer(struct tty_struct *tty)
{
	struct usb_serial_port *port = tty->driver_data;
	struct zte_port_private *portdata;
	int i;
	int data_len = 0;
	struct urb *this_urb;

	portdata = usb_get_serial_port_data(port);

	for (i = 0; i < N_OUT_URB; i++) {
		this_urb = portdata->out_urbs[i];
		/* FIXME: This locking is insufficient as this_urb may
		   go unused during the test */
		if (this_urb && test_bit(i, &portdata->out_busy))
			data_len += this_urb->transfer_buffer_length;
	}
	dbg("%s: %d", __func__, data_len);
	return data_len;
}


int zte_open(struct tty_struct *tty, struct usb_serial_port *port)
{
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata;
	struct usb_serial *serial = port->serial;
	int i, err;
	struct urb *urb;

	portdata = usb_get_serial_port_data(port);
	intfdata = serial->private;

	dbg("%s", __func__);

	/* Start reading from the IN endpoint */
	for (i = 0; i < N_IN_URB; i++) {
		urb = portdata->in_urbs[i];
		if (!urb)
			continue;
		err = usb_submit_urb(urb, GFP_KERNEL);
		if (err) {
			dbg("%s: submit urb %d failed (%d) %d",
			    __func__, i, err, urb->transfer_buffer_length);
		}
	}

	if (intfdata->send_setup)
		intfdata->send_setup(port);

	serial->interface->needs_remote_wakeup = 1;
	spin_lock_irq(&intfdata->susp_lock);
	portdata->opened = 1;
	spin_unlock_irq(&intfdata->susp_lock);
	/* this balances a get in the generic USB serial code */
	usb_autopm_put_interface(serial->interface);

	return 0;
}


void zte_close(struct usb_serial_port *port)
{
	int i;
	struct usb_serial *serial = port->serial;
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata = port->serial->private;

	dbg("%s", __func__);
	portdata = usb_get_serial_port_data(port);

	if (serial->dev) {
		/* Stop reading/writing urbs */
		spin_lock_irq(&intfdata->susp_lock);
		portdata->opened = 0;
		spin_unlock_irq(&intfdata->susp_lock);

		for (i = 0; i < N_IN_URB; i++)
			usb_kill_urb(portdata->in_urbs[i]);
		for (i = 0; i < N_OUT_URB; i++)
			usb_kill_urb(portdata->out_urbs[i]);
		/* balancing - important as an error cannot be handled*/
		usb_autopm_get_interface_no_resume(serial->interface);
		serial->interface->needs_remote_wakeup = 0;
	}
}


/* Helper functions used by zte_setup_urbs */
static struct urb *zte_setup_urb(struct usb_serial *serial, int endpoint,
				      int dir, void *ctx, char *buf, int len,
				      void (*callback) (struct urb *))
{
	struct urb *urb;

	if (endpoint == -1)
		return NULL;	/* endpoint not needed */

	urb = usb_alloc_urb(0, GFP_KERNEL);	/* No ISO */
	if (urb == NULL) {
		dbg("%s: alloc for endpoint %d failed.", __func__, endpoint);
		return NULL;
	}

	/* Fill URB using supplied data. */
	usb_fill_bulk_urb(urb, serial->dev,
			  usb_sndbulkpipe(serial->dev, endpoint) | dir,
			  buf, len, callback, ctx);

	return urb;
}

/* Setup urbs */
static void zte_setup_urbs(struct usb_serial *serial)
{
	int i, j;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;

	dbg("%s", __func__);

	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);

		/* Do indat endpoints first */
		for (j = 0; j < N_IN_URB; ++j) {
			portdata->in_urbs[j] = zte_setup_urb(serial,
								  port->
								  bulk_in_endpointAddress,
								  USB_DIR_IN,
								  port,
								  portdata->
								  in_buffer[j],
								  IN_BUFLEN,
								  zte_indat_callback);
		}

		/* outdat endpoints */
		for (j = 0; j < N_OUT_URB; ++j) {
			portdata->out_urbs[j] = zte_setup_urb(serial,
								   port->
								   bulk_out_endpointAddress,
								   USB_DIR_OUT,
								   port,
								   portdata->
								   out_buffer
								   [j],
								   OUT_BUFLEN,
								   zte_outdat_callback);
		}
	}
}

int zte_startup(struct usb_serial *serial)
{
	int i, j, err;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;
	u8 *buffer;

	dbg("%s", __func__);

	/* Now setup per port private data */
	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		portdata = kzalloc(sizeof(*portdata), GFP_KERNEL);
		if (!portdata) {
			dbg("%s: kmalloc for zte_port_private (%d) failed!.",
			    __func__, i);
			return 1;
		}
		init_usb_anchor(&portdata->delayed);

		for (j = 0; j < N_IN_URB; j++) {
			buffer = (u8 *) __get_free_page(GFP_KERNEL);
			if (!buffer)
				goto bail_out_error;
			portdata->in_buffer[j] = buffer;
		}

		for (j = 0; j < N_OUT_URB; j++) {
			buffer = kmalloc(OUT_BUFLEN, GFP_KERNEL);
			if (!buffer)
				goto bail_out_error2;
			portdata->out_buffer[j] = buffer;
		}

		usb_set_serial_port_data(port, portdata);

		if (!port->interrupt_in_urb)
			continue;
		err = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);
		if (err)
			dbg("%s: submit irq_in urb failed %d", __func__, err);
	}
	zte_setup_urbs(serial);
	return 0;

bail_out_error2:
	for (j = 0; j < N_OUT_URB; j++)
		kfree(portdata->out_buffer[j]);
bail_out_error:
	for (j = 0; j < N_IN_URB; j++)
		if (portdata->in_buffer[j])
			free_page((unsigned long)portdata->in_buffer[j]);
	kfree(portdata);
	return 1;
}


static void stop_read_write_urbs(struct usb_serial *serial)
{
	int i, j;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;

	/* Stop reading/writing urbs */
	for (i = 0; i < serial->num_ports; ++i) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);
		for (j = 0; j < N_IN_URB; j++)
			usb_kill_urb(portdata->in_urbs[j]);
		for (j = 0; j < N_OUT_URB; j++)
			usb_kill_urb(portdata->out_urbs[j]);
	}
}

void zte_disconnect(struct usb_serial *serial)
{
	dbg("%s", __func__);

	stop_read_write_urbs(serial);
}


void zte_release(struct usb_serial *serial)
{
	int i, j;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;

	dbg("%s", __func__);

	/* Now free them */
	for (i = 0; i < serial->num_ports; ++i) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);

		for (j = 0; j < N_IN_URB; j++) {
			usb_free_urb(portdata->in_urbs[j]);
			free_page((unsigned long)
				  portdata->in_buffer[j]);
			portdata->in_urbs[j] = NULL;
		}
		for (j = 0; j < N_OUT_URB; j++) {
			usb_free_urb(portdata->out_urbs[j]);
			kfree(portdata->out_buffer[j]);
			portdata->out_urbs[j] = NULL;
		}
	}

	/* Now free per port private data */
	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		kfree(usb_get_serial_port_data(port));
	}
}


#ifdef CONFIG_PM
int zte_suspend(struct usb_serial *serial, pm_message_t message)
{
	struct zte_intf_private *intfdata = serial->private;
	int b;

	dbg("%s entered", __func__);

	if (PMSG_IS_AUTO(message)) {
		spin_lock_irq(&intfdata->susp_lock);
		b = intfdata->in_flight;
		spin_unlock_irq(&intfdata->susp_lock);

		if (b)
			return -EBUSY;
	}

	spin_lock_irq(&intfdata->susp_lock);
	intfdata->suspended = 1;
	spin_unlock_irq(&intfdata->susp_lock);
	stop_read_write_urbs(serial);

	return 0;
}


static void unbusy_queued_urb(struct urb *urb, struct zte_port_private *portdata)
{
	int i;

	for (i = 0; i < N_OUT_URB; i++) {
		if (urb == portdata->out_urbs[i]) {
			clear_bit(i, &portdata->out_busy);
			break;
		}
	}
}

static void play_delayed(struct usb_serial_port *port)
{
	struct zte_intf_private *data;
	struct zte_port_private *portdata;
	struct urb *urb;
	int err;

	portdata = usb_get_serial_port_data(port);
	data = port->serial->private;
	while ((urb = usb_get_from_anchor(&portdata->delayed))) {
		err = usb_submit_urb(urb, GFP_ATOMIC);
		if (!err) {
			data->in_flight++;
		} else {
			/* we have to throw away the rest */
			do {
				unbusy_queued_urb(urb, portdata);
				usb_autopm_put_interface_no_suspend(port->serial->interface);
			} while ((urb = usb_get_from_anchor(&portdata->delayed)));
			break;
		}
	}
}

int zte_resume(struct usb_serial *serial)
{
	int i, j;
	struct usb_serial_port *port;
	struct zte_intf_private *intfdata = serial->private;
	struct zte_port_private *portdata;
	struct urb *urb;
	int err = 0;

	dbg("%s entered", __func__);
	/* get the interrupt URBs resubmitted unconditionally */
	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		if (!port->interrupt_in_urb) {
			dbg("%s: No interrupt URB for port %d", __func__, i);
			continue;
		}
		err = usb_submit_urb(port->interrupt_in_urb, GFP_NOIO);
		dbg("Submitted interrupt URB for port %d (result %d)", i, err);
		if (err < 0) {
			err("%s: Error %d for interrupt URB of port%d",
			    __func__, err, i);
			goto err_out;
		}
	}

	for (i = 0; i < serial->num_ports; i++) {
		/* walk all ports */
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);

		/* skip closed ports */
		spin_lock_irq(&intfdata->susp_lock);
		if (!portdata->opened) {
			spin_unlock_irq(&intfdata->susp_lock);
			continue;
		}

		for (j = 0; j < N_IN_URB; j++) {
			urb = portdata->in_urbs[j];
			err = usb_submit_urb(urb, GFP_ATOMIC);
			if (err < 0) {
				err("%s: Error %d for bulk URB %d",
				    __func__, err, i);
				spin_unlock_irq(&intfdata->susp_lock);
				goto err_out;
			}
		}
		play_delayed(port);
		spin_unlock_irq(&intfdata->susp_lock);
	}
	spin_lock_irq(&intfdata->susp_lock);
	intfdata->suspended = 0;
	spin_unlock_irq(&intfdata->susp_lock);
err_out:
	return err;
}

#endif

MODULE_AUTHOR(DRIVER_AUTHOR);
MODULE_DESCRIPTION(DRIVER_DESC);
MODULE_VERSION(DRIVER_VERSION);
MODULE_LICENSE("GPL");

module_param(debug, bool, S_IRUGO | S_IWUSR);
MODULE_PARM_DESC(debug, "Debug messages");

#elif LINUX_VERSION_CODE < KERNEL_VERSION(3,6,0)//use  3.5 source code
#include <linux/kernel.h>
#include <linux/jiffies.h>
#include <linux/errno.h>
#include <linux/tty.h>
#include <linux/tty_flip.h>
#include <linux/slab.h>
#include <linux/module.h>
#include <linux/bitops.h>
#include <linux/usb.h>
#include <linux/usb/serial.h>
#include <linux/uaccess.h>
#include <linux/serial.h>
/* Function prototypes */
static int  zte_probe(struct usb_serial *serial,
			const struct usb_device_id *id);
static int zte_send_setup(struct usb_serial_port *port);
static void zte_instat_callback(struct urb *urb);
void zte_dtr_rts(struct usb_serial_port *port, int on);
int zte_open(struct tty_struct *tty, struct usb_serial_port *port);
void zte_close(struct usb_serial_port *port);
int zte_startup(struct usb_serial *serial);
void zte_disconnect(struct usb_serial *serial);
static void zte_release(struct usb_serial *serial);
int zte_write_room(struct tty_struct *tty);
void zte_set_termios(struct tty_struct *tty,
				 struct usb_serial_port *port,
				 struct ktermios *old);
int zte_tiocmget(struct tty_struct *tty);
int zte_tiocmset(struct tty_struct *tty,
			     unsigned int set, unsigned int clear);
int zte_ioctl(struct tty_struct *tty,
			  unsigned int cmd, unsigned long arg);
int zte_send_setup(struct usb_serial_port *port);
int zte_write(struct tty_struct *tty, struct usb_serial_port *port,
			  const unsigned char *buf, int count);
int zte_chars_in_buffer(struct tty_struct *tty);
#ifdef CONFIG_PM
int zte_suspend(struct usb_serial *serial, pm_message_t message);
int zte_resume(struct usb_serial *serial);
#endif

/* Vendor and product IDs */
/* ZTE PRODUCTS */
#define zte_VENDOR_ID				0x19d2

/* some devices interfaces need special handling due to a number of reasons */
enum zte_blacklist_reason {
		ZTE_BLACKLIST_NONE = 0,
		ZTE_BLACKLIST_SENDSETUP = 1,
		ZTE_BLACKLIST_RESERVED_IF = 2
};

#define MAX_BL_NUM  8
struct zte_blacklist_info {
	/* bitfield of interface numbers for ZTE_BLACKLIST_SENDSETUP */
	const unsigned long sendsetup;
	/* bitfield of interface numbers for ZTE_BLACKLIST_RESERVED_IF */
	const unsigned long reserved;
};

static const struct zte_blacklist_info four_g_w14_blacklist = {
	.sendsetup = BIT(0) | BIT(1),
};

static const struct zte_blacklist_info alcatel_x200_blacklist = {
	.sendsetup = BIT(0) | BIT(1),
};

static const struct zte_blacklist_info zte_0037_blacklist = {
	.sendsetup = BIT(0) | BIT(1),
};

static const struct zte_blacklist_info zte_k3765_z_blacklist = {
	.sendsetup = BIT(0) | BIT(1) | BIT(2),
	.reserved = BIT(4),
};

static const struct zte_blacklist_info zte_ad3812_z_blacklist = {
	.sendsetup = BIT(0) | BIT(1) | BIT(2),
};

static const struct zte_blacklist_info zte_mc2718_z_blacklist = {
	.sendsetup = BIT(1) | BIT(2) | BIT(3) | BIT(4),
};

static const struct zte_blacklist_info zte_mc2716_z_blacklist = {
	.sendsetup = BIT(1) | BIT(2) | BIT(3),
};

static const struct zte_blacklist_info huawei_cdc12_blacklist = {
	.reserved = BIT(1) | BIT(2),
};

static const struct zte_blacklist_info net_intf1_blacklist = {
	.reserved = BIT(1),
};

static const struct zte_blacklist_info net_intf2_blacklist = {
	.reserved = BIT(2),
};

static const struct zte_blacklist_info net_intf3_blacklist = {
	.reserved = BIT(3),
};

static const struct zte_blacklist_info net_intf4_blacklist = {
	.reserved = BIT(4),
};

static const struct zte_blacklist_info net_intf5_blacklist = {
	.reserved = BIT(5),
};

static const struct zte_blacklist_info net_intf6_blacklist = {
	.reserved = BIT(6),
};

static const struct zte_blacklist_info zte_mf626_blacklist = {
	.sendsetup = BIT(0) | BIT(1),
	.reserved = BIT(4),
};

static const struct zte_blacklist_info zte_1255_blacklist = {
	.reserved = BIT(3) | BIT(4),
};

static const struct zte_blacklist_info telit_le920_blacklist = {
	.sendsetup = BIT(0),
	.reserved = BIT(1) | BIT(5),
};

static const struct usb_device_id zte_ids[] = {
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0001, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0002, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0003, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0004, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0005, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0006, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0007, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0008, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0009, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0010, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0011, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0012, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0013, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0014, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0015, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0016, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0017, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0018, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0019, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0020, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0021, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0022, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0023, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0024, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0025, 0xff, 0xff, 0xff) },
    //   { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0026, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0027, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0028, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0029, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0030, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0031, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0032, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0033, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0034, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0035, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0036, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0037, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0038, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0039, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0040, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0041, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0042, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0043, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0044, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0045, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0046, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0047, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0048, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0049, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0050, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0051, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0052, 0xff, 0xff, 0xff) },
    //   { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0053, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0054, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0055, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0056, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0057, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0058, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0059, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0060, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0061, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0062, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0063, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0064, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0065, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0066, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0067, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0068, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0069, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0070, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0071, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0072, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0073, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0074, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0075, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0076, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0077, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0078, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0079, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0080, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0081, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0082, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0083, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0084, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0085, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0086, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0087, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0088, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0089, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0090, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0091, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0092, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0093, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0094, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0095, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0096, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0097, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0098, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0099, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0104, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0105, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0106, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0108, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0117, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0118, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0121, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0122, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0123, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0124, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0125, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0126, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0128, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0130, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0133, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0135, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0136, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0137, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0139, 0xff, 0xff, 0xff) }, 	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0141, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0144, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0145, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0147, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0148, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0151, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0152, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0153, 0xff, 0xff, 0xff) },
    //{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0154, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0155, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0156, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0157, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0158, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0159, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0160, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0161, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0162, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0164, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0165, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0167, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0168, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0170, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0176, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0178, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0189, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0191, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0196, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0197, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0199, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0200, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0201, 0xff, 0xff, 0xff) },		
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0254, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0257, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0265, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0284, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0317, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0330, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0395, 0xff, 0xff, 0xff) },      
 	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0414, 0xff, 0xff, 0xff) },   
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0417, 0xff, 0xff, 0xff) },

    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1008, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1010, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1012, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1018, 0xff, 0xff, 0xff) },		
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1057, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1058, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1059, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1060, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1061, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1062, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1063, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1064, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1065, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1066, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1067, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1068, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1069, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1070, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1071, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1072, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1073, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1074, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1075, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1076, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1077, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1078, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1079, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1080, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1081, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1082, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1083, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1084, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1085, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1086, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1087, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1088, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1089, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1090, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1091, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1092, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1093, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1094, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1095, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1096, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1097, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1098, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1099, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1100, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1101, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1102, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1103, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1104, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1105, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1106, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1107, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1108, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1109, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1110, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1111, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1112, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1113, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1114, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1115, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1116, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1117, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1118, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1119, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1120, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1121, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1122, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1123, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1124, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1125, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1126, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1127, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1128, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1129, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1130, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1131, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1132, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1133, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1134, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1135, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1136, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1137, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1138, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1139, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1140, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1141, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1142, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1143, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1144, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1145, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1146, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1147, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1148, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1149, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1150, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1151, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1152, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1153, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1154, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1155, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1156, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1157, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1158, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1159, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1160, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1161, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1162, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1163, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1164, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1165, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1166, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1167, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1168, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1169, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1170, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1244, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1245, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1246, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1247, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1248, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1249, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1250, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1251, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1252, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1253, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1254, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1255, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1256, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1257, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1258, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1259, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1260, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1261, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1262, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1263, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1264, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1265, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1266, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1267, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1268, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1269, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1270, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1271, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1272, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1273, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1274, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1275, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1276, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1277, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1278, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1279, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1280, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1281, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1282, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1283, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1284, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1285, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1286, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1287, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1288, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1289, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1290, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1291, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1292, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1293, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1294, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1295, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1296, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1297, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1298, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1299, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1300, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1301, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1302, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1303, 0xff, 0xff, 0xff) },	
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1333, 0xff, 0xff, 0xff) },	
	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1401, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1402, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1403, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1404, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1405, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1406, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1407, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1408, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1409, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1410, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1411, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1412, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1413, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1414, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1415, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1416, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1417, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1418, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1419, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1420, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1421, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1422, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1423, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1424, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1425, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1426, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1427, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1428, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1429, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1430, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1431, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1432, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1433, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1434, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1435, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1436, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1437, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1438, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1439, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1440, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1441, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1442, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1443, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1444, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1445, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1446, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1447, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1448, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1449, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1450, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1451, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1452, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1453, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1454, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1455, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1456, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1457, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1458, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1459, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1460, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1461, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1462, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1463, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1464, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1465, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1466, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1467, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1468, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1469, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1470, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1471, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1472, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1473, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1474, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1475, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1476, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1477, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1478, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1479, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1480, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1481, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1482, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1483, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1484, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1485, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1486, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1487, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1488, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1489, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1490, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1491, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1492, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1493, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1494, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1495, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1496, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1497, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1498, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1499, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1500, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1501, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1502, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1503, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1504, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1505, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1506, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1507, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1508, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1509, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1510, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1533, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1534, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1535, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1545, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1546, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1547, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1565, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1566, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1567, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1589, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1590, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1591, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1592, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1594, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1596, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1598, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1600, 0xff, 0xff, 0xff) },  		
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x2002, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x2003, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0xFFEC, 0xff, 0xff, 0xff) },
    { ZTE_USB_DEVICE_ID_MATCH_INT_CLASS_AND_SUBCLASS_INFO(0x19d2,0xff,0x86) },
    { ZTE_USB_DEVICE_ID_MATCH_INT_CLASS_AND_SUBCLASS_INFO(0x19d2,0xff,0x02) },
    { USB_DEVICE_AND_INTERFACE_INFO(TPLink_VENDOR_ID, 0x7E11, 0xff, 0xff, 0xff) },/*TPLink*/
    { USB_DEVICE_AND_INTERFACE_INFO(QUALCOMM_VENDOR_ID, 0x9001, 0xff, 0xff, 0xff) },/*QUALCOMM_VENDOR_ID*/
    { USB_DEVICE_AND_INTERFACE_INFO(QUALCOMM_VENDOR_ID, 0x9002, 0xff, 0xff, 0xff) },
	{ } /* Terminating entry */
};
MODULE_DEVICE_TABLE(usb, zte_ids);

/* The card has three separate interfaces, which the serial driver
 * recognizes separately, thus num_port=1.
 */

static struct usb_serial_driver zte_1port_device = {
	.driver = {
		.owner =	THIS_MODULE,
		.name =		"zte1",
	},
	.description       = "GSM modem (1-port)",
	.id_table          = zte_ids,
	.num_ports         = 1,
	.probe             = zte_probe,
	.open              = zte_open,
	.close             = zte_close,
	.dtr_rts	   = zte_dtr_rts,
	.write             = zte_write,
	.write_room        = zte_write_room,
	.chars_in_buffer   = zte_chars_in_buffer,
	.set_termios       = zte_set_termios,
	.tiocmget          = zte_tiocmget,
	.tiocmset          = zte_tiocmset,
	.ioctl             = zte_ioctl,
	.attach            = zte_startup,
	.disconnect        = zte_disconnect,
	.release           = zte_release,
	.read_int_callback = zte_instat_callback,
#ifdef CONFIG_PM
	.suspend           = zte_suspend,
	.resume            = zte_resume,
#endif
};

static struct usb_serial_driver * const serial_drivers[] = {
	&zte_1port_device, NULL
};

static bool debug;
/* per port private data */

#define N_IN_URB 4
#define N_OUT_URB 4
#define IN_BUFLEN 4096
#define OUT_BUFLEN 4096

struct zte_intf_private {
	spinlock_t susp_lock;
	unsigned int suspended:1;
	int in_flight;
	int (*send_setup) (struct usb_serial_port *port);
	void *private;
};

struct zte_port_private {
	/* Input endpoints and buffer for this port */
	struct urb *in_urbs[N_IN_URB];
	u8 *in_buffer[N_IN_URB];
	/* Output endpoints and buffer for this port */
	struct urb *out_urbs[N_OUT_URB];
	u8 *out_buffer[N_OUT_URB];
	unsigned long out_busy;	/* Bit vector of URBs in use */
	int opened;
	struct usb_anchor delayed;

	/* Settings for the port */
	int rts_state;		/* Handshaking pins (outputs) */
	int dtr_state;
	int cts_state;		/* Handshaking pins (inputs) */
	int dsr_state;
	int dcd_state;
	int ri_state;

	unsigned long tx_start_time[N_OUT_URB];
};
void zte_dtr_rts(struct usb_serial_port *port, int on)
{
	struct usb_serial *serial = port->serial;
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata;

	intfdata = port->serial->private;

	if (!intfdata->send_setup)
		return;

	portdata = usb_get_serial_port_data(port);
	mutex_lock(&serial->disc_mutex);
	portdata->rts_state = on;
	portdata->dtr_state = on;
	if (serial->dev)
		intfdata->send_setup(port);
	mutex_unlock(&serial->disc_mutex);
}


void zte_set_termios(struct tty_struct *tty,
			  struct usb_serial_port *port,
			  struct ktermios *old_termios)
{
	struct zte_intf_private *intfdata = port->serial->private;

	/* Doesn't support option setting */
	tty_termios_copy_hw(tty->termios, old_termios);

	if (intfdata->send_setup)
		intfdata->send_setup(port);
}


int zte_tiocmget(struct tty_struct *tty)
{
	struct usb_serial_port *port = tty->driver_data;
	unsigned int value;
	struct zte_port_private *portdata;

	portdata = usb_get_serial_port_data(port);

	value = ((portdata->rts_state) ? TIOCM_RTS : 0) |
	    ((portdata->dtr_state) ? TIOCM_DTR : 0) |
	    ((portdata->cts_state) ? TIOCM_CTS : 0) |
	    ((portdata->dsr_state) ? TIOCM_DSR : 0) |
	    ((portdata->dcd_state) ? TIOCM_CAR : 0) |
	    ((portdata->ri_state) ? TIOCM_RNG : 0);

	return value;
}


int zte_tiocmset(struct tty_struct *tty,
		      unsigned int set, unsigned int clear)
{
	struct usb_serial_port *port = tty->driver_data;
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata;

	portdata = usb_get_serial_port_data(port);
	intfdata = port->serial->private;

	if (!intfdata->send_setup)
		return -EINVAL;

	/* FIXME: what locks portdata fields ? */
	if (set & TIOCM_RTS)
		portdata->rts_state = 1;
	if (set & TIOCM_DTR)
		portdata->dtr_state = 1;

	if (clear & TIOCM_RTS)
		portdata->rts_state = 0;
	if (clear & TIOCM_DTR)
		portdata->dtr_state = 0;
	return intfdata->send_setup(port);
}


static int get_serial_info(struct usb_serial_port *port,
			   struct serial_struct __user *retinfo)
{
	struct serial_struct tmp;

	if (!retinfo)
		return -EFAULT;

	memset(&tmp, 0, sizeof(tmp));
	tmp.line            = port->serial->minor;
	tmp.port            = port->number;
	tmp.baud_base       = tty_get_baud_rate(port->port.tty);
	tmp.close_delay	    = port->port.close_delay / 10;
	tmp.closing_wait    = port->port.closing_wait == ASYNC_CLOSING_WAIT_NONE ?
				 ASYNC_CLOSING_WAIT_NONE :
				 port->port.closing_wait / 10;

	if (copy_to_user(retinfo, &tmp, sizeof(*retinfo)))
		return -EFAULT;
	return 0;
}

static int set_serial_info(struct usb_serial_port *port,
			   struct serial_struct __user *newinfo)
{
	struct serial_struct new_serial;
	unsigned int closing_wait, close_delay;
	int retval = 0;

	if (copy_from_user(&new_serial, newinfo, sizeof(new_serial)))
		return -EFAULT;

	close_delay = new_serial.close_delay * 10;
	closing_wait = new_serial.closing_wait == ASYNC_CLOSING_WAIT_NONE ?
			ASYNC_CLOSING_WAIT_NONE : new_serial.closing_wait * 10;

	mutex_lock(&port->port.mutex);

	if (!capable(CAP_SYS_ADMIN)) {
		if ((close_delay != port->port.close_delay) ||
		    (closing_wait != port->port.closing_wait))
			retval = -EPERM;
		else
			retval = -EOPNOTSUPP;
	} else {
		port->port.close_delay  = close_delay;
		port->port.closing_wait = closing_wait;
	}

	mutex_unlock(&port->port.mutex);
	return retval;
}

int zte_ioctl(struct tty_struct *tty,
		   unsigned int cmd, unsigned long arg)
{
	struct usb_serial_port *port = tty->driver_data;

	dbg("%s cmd 0x%04x", __func__, cmd);

	switch (cmd) {
	case TIOCGSERIAL:
		return get_serial_info(port,
				       (struct serial_struct __user *) arg);
	case TIOCSSERIAL:
		return set_serial_info(port,
				       (struct serial_struct __user *) arg);
	default:
		break;
	}

	dbg("%s arg not supported", __func__);

	return -ENOIOCTLCMD;
}


/* Write */
int zte_write(struct tty_struct *tty, struct usb_serial_port *port,
		   const unsigned char *buf, int count)
{
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata;
	int i;
	int left, todo;
	struct urb *this_urb = NULL;	/* spurious */
	int err;
	unsigned long flags;

	portdata = usb_get_serial_port_data(port);
	intfdata = port->serial->private;

	dbg("%s: write (%d chars)", __func__, count);

	i = 0;
	left = count;
	for (i = 0; left > 0 && i < N_OUT_URB; i++) {
		todo = left;
		if (todo > OUT_BUFLEN)
			todo = OUT_BUFLEN;

		this_urb = portdata->out_urbs[i];
		if (test_and_set_bit(i, &portdata->out_busy)) {
			if (time_before(jiffies,
					portdata->tx_start_time[i] + 10 * HZ))
				continue;
			usb_unlink_urb(this_urb);
			continue;
		}
		dbg("%s: endpoint %d buf %d", __func__,
		    usb_pipeendpoint(this_urb->pipe), i);

		err = usb_autopm_get_interface_async(port->serial->interface);
		if (err < 0)
			break;

		/* send the data */
		memcpy(this_urb->transfer_buffer, buf, todo);
		this_urb->transfer_buffer_length = todo;

		spin_lock_irqsave(&intfdata->susp_lock, flags);
		if (intfdata->suspended) {
			usb_anchor_urb(this_urb, &portdata->delayed);
			spin_unlock_irqrestore(&intfdata->susp_lock, flags);
		} else {
			intfdata->in_flight++;
			spin_unlock_irqrestore(&intfdata->susp_lock, flags);
			err = usb_submit_urb(this_urb, GFP_ATOMIC);
			if (err) {
				dbg("usb_submit_urb %p (write bulk) failed "
				    "(%d)", this_urb, err);
				clear_bit(i, &portdata->out_busy);
				spin_lock_irqsave(&intfdata->susp_lock, flags);
				intfdata->in_flight--;
				spin_unlock_irqrestore(&intfdata->susp_lock,
						       flags);
				usb_autopm_put_interface_async(port->serial->interface);
				break;
			}
		}

		portdata->tx_start_time[i] = jiffies;
		buf += todo;
		left -= todo;
	}

	count -= left;
	dbg("%s: wrote (did %d)", __func__, count);
	return count;
}


static void zte_indat_callback(struct urb *urb)
{
	int err;
	int endpoint;
	struct usb_serial_port *port;
	struct tty_struct *tty;
	unsigned char *data = urb->transfer_buffer;
	int status = urb->status;

	endpoint = usb_pipeendpoint(urb->pipe);
	port = urb->context;

	if (status) {
		dbg("%s: nonzero status: %d on endpoint %02x.",
		    __func__, status, endpoint);
	} else {
		tty = tty_port_tty_get(&port->port);
		if (tty) {
			if (urb->actual_length) {
				tty_insert_flip_string(tty, data,
						urb->actual_length);
				tty_flip_buffer_push(tty);
			} else
				dbg("%s: empty read urb received", __func__);
			tty_kref_put(tty);
		}

		/* Resubmit urb so we continue receiving */
		err = usb_submit_urb(urb, GFP_ATOMIC);
		if (err) {
			if (err != -EPERM) {
				printk(KERN_ERR "%s: resubmit read urb failed. "
					"(%d)", __func__, err);
				/* busy also in error unless we are killed */
				usb_mark_last_busy(port->serial->dev);
			}
		} else {
			usb_mark_last_busy(port->serial->dev);
		}
	}
}

static void zte_outdat_callback(struct urb *urb)
{
	struct usb_serial_port *port;
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata;
	int i;

	port = urb->context;
	intfdata = port->serial->private;

	usb_serial_port_softint(port);
	usb_autopm_put_interface_async(port->serial->interface);
	portdata = usb_get_serial_port_data(port);
	spin_lock(&intfdata->susp_lock);
	intfdata->in_flight--;
	spin_unlock(&intfdata->susp_lock);

	for (i = 0; i < N_OUT_URB; ++i) {
		if (portdata->out_urbs[i] == urb) {
			smp_mb__before_clear_bit();
			clear_bit(i, &portdata->out_busy);
			break;
		}
	}
}

int zte_write_room(struct tty_struct *tty)
{
	struct usb_serial_port *port = tty->driver_data;
	struct zte_port_private *portdata;
	int i;
	int data_len = 0;
	struct urb *this_urb;

	portdata = usb_get_serial_port_data(port);

	for (i = 0; i < N_OUT_URB; i++) {
		this_urb = portdata->out_urbs[i];
		if (this_urb && !test_bit(i, &portdata->out_busy))
			data_len += OUT_BUFLEN;
	}

	dbg("%s: %d", __func__, data_len);
	return data_len;
}


int zte_chars_in_buffer(struct tty_struct *tty)
{
	struct usb_serial_port *port = tty->driver_data;
	struct zte_port_private *portdata;
	int i;
	int data_len = 0;
	struct urb *this_urb;

	portdata = usb_get_serial_port_data(port);

	for (i = 0; i < N_OUT_URB; i++) {
		this_urb = portdata->out_urbs[i];
		/* FIXME: This locking is insufficient as this_urb may
		   go unused during the test */
		if (this_urb && test_bit(i, &portdata->out_busy))
			data_len += this_urb->transfer_buffer_length;
	}
	dbg("%s: %d", __func__, data_len);
	return data_len;
}


int zte_open(struct tty_struct *tty, struct usb_serial_port *port)
{
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata;
	struct usb_serial *serial = port->serial;
	int i, err;
	struct urb *urb;

	portdata = usb_get_serial_port_data(port);
	intfdata = serial->private;

	/* Start reading from the IN endpoint */
	for (i = 0; i < N_IN_URB; i++) {
		urb = portdata->in_urbs[i];
		if (!urb)
			continue;
		err = usb_submit_urb(urb, GFP_KERNEL);
		if (err) {
			dbg("%s: submit urb %d failed (%d) %d",
			    __func__, i, err, urb->transfer_buffer_length);
		}
	}

	if (intfdata->send_setup)
		intfdata->send_setup(port);

	serial->interface->needs_remote_wakeup = 1;
	spin_lock_irq(&intfdata->susp_lock);
	portdata->opened = 1;
	spin_unlock_irq(&intfdata->susp_lock);
	/* this balances a get in the generic USB serial code */
	usb_autopm_put_interface(serial->interface);

	return 0;
}


void zte_close(struct usb_serial_port *port)
{
	int i;
	struct usb_serial *serial = port->serial;
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata = port->serial->private;

	portdata = usb_get_serial_port_data(port);

	if (serial->dev) {
		/* Stop reading/writing urbs */
		spin_lock_irq(&intfdata->susp_lock);
		portdata->opened = 0;
		spin_unlock_irq(&intfdata->susp_lock);

		for (i = 0; i < N_IN_URB; i++)
			usb_kill_urb(portdata->in_urbs[i]);
		for (i = 0; i < N_OUT_URB; i++)
			usb_kill_urb(portdata->out_urbs[i]);
		/* balancing - important as an error cannot be handled*/
		usb_autopm_get_interface_no_resume(serial->interface);
		serial->interface->needs_remote_wakeup = 0;
	}
}


/* Helper functions used by zte_setup_urbs */
static struct urb *zte_setup_urb(struct usb_serial *serial, int endpoint,
				      int dir, void *ctx, char *buf, int len,
				      void (*callback) (struct urb *))
{
	struct urb *urb;

	urb = usb_alloc_urb(0, GFP_KERNEL);	/* No ISO */
	if (urb == NULL) {
		dbg("%s: alloc for endpoint %d failed.", __func__, endpoint);
		return NULL;
	}

	/* Fill URB using supplied data. */
	usb_fill_bulk_urb(urb, serial->dev,
			  usb_sndbulkpipe(serial->dev, endpoint) | dir,
			  buf, len, callback, ctx);

	return urb;
}

/* Setup urbs */
static void zte_setup_urbs(struct usb_serial *serial)
{
	int i, j;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;

	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);

		/* Do indat endpoints first */
		for (j = 0; j < N_IN_URB; ++j) {
			if (!port->bulk_in_size)
				break;

			portdata->in_urbs[j] = zte_setup_urb(serial,
								  port->
								  bulk_in_endpointAddress,
								  USB_DIR_IN,
								  port,
								  portdata->
								  in_buffer[j],
								  IN_BUFLEN,
								  zte_indat_callback);
		}

		/* outdat endpoints */
		for (j = 0; j < N_OUT_URB; ++j) {
			if (!port->bulk_out_size)
				break;

			portdata->out_urbs[j] = zte_setup_urb(serial,
								   port->
								   bulk_out_endpointAddress,
								   USB_DIR_OUT,
								   port,
								   portdata->
								   out_buffer
								   [j],
								   OUT_BUFLEN,
								   zte_outdat_callback);
		}
	}
}

int zte_startup(struct usb_serial *serial)
{
	int i, j, err;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;
	u8 *buffer;

	/* Now setup per port private data */
	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		portdata = kzalloc(sizeof(*portdata), GFP_KERNEL);
		if (!portdata) {
			dbg("%s: kmalloc for zte_port_private (%d) failed!.",
			    __func__, i);
			return 1;
		}
		init_usb_anchor(&portdata->delayed);

		for (j = 0; j < N_IN_URB; j++) {
			if (!port->bulk_in_size)
				break;

			buffer = (u8 *) __get_free_page(GFP_KERNEL);
			if (!buffer)
				goto bail_out_error;
			portdata->in_buffer[j] = buffer;
		}

		for (j = 0; j < N_OUT_URB; j++) {
			if (!port->bulk_out_size)
				break;

			buffer = kmalloc(OUT_BUFLEN, GFP_KERNEL);
			if (!buffer)
				goto bail_out_error2;
			portdata->out_buffer[j] = buffer;
		}

		usb_set_serial_port_data(port, portdata);

		if (!port->interrupt_in_urb)
			continue;
		err = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);
		if (err)
			dbg("%s: submit irq_in urb failed %d", __func__, err);
	}
	zte_setup_urbs(serial);
	return 0;

bail_out_error2:
	for (j = 0; j < N_OUT_URB; j++)
		kfree(portdata->out_buffer[j]);
bail_out_error:
	for (j = 0; j < N_IN_URB; j++)
		if (portdata->in_buffer[j])
			free_page((unsigned long)portdata->in_buffer[j]);
	kfree(portdata);
	return 1;
}


static void stop_read_write_urbs(struct usb_serial *serial)
{
	int i, j;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;

	/* Stop reading/writing urbs */
	for (i = 0; i < serial->num_ports; ++i) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);
		for (j = 0; j < N_IN_URB; j++)
			usb_kill_urb(portdata->in_urbs[j]);
		for (j = 0; j < N_OUT_URB; j++)
			usb_kill_urb(portdata->out_urbs[j]);
	}
}

void zte_disconnect(struct usb_serial *serial)
{
	stop_read_write_urbs(serial);
}


static void zte_release(struct usb_serial *serial)
{
	int i, j;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;

	/* Now free them */
	for (i = 0; i < serial->num_ports; ++i) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);

		for (j = 0; j < N_IN_URB; j++) {
			usb_free_urb(portdata->in_urbs[j]);
			free_page((unsigned long)
				  portdata->in_buffer[j]);
			portdata->in_urbs[j] = NULL;
		}
		for (j = 0; j < N_OUT_URB; j++) {
			usb_free_urb(portdata->out_urbs[j]);
			kfree(portdata->out_buffer[j]);
			portdata->out_urbs[j] = NULL;
		}
	}

	/* Now free per port private data */
	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		kfree(usb_get_serial_port_data(port));
	}
}

module_usb_serial_driver(serial_drivers, zte_ids);

static bool is_blacklisted(const u8 ifnum, enum zte_blacklist_reason reason,
			   const struct zte_blacklist_info *blacklist)
{
	unsigned long num;
	const unsigned long *intf_list;

	if (blacklist) {
		if (reason == ZTE_BLACKLIST_SENDSETUP)
			intf_list = &blacklist->sendsetup;
		else if (reason == ZTE_BLACKLIST_RESERVED_IF)
			intf_list = &blacklist->reserved;
		else {
			BUG_ON(reason);
			return false;
		}

		for_each_set_bit(num, intf_list, MAX_BL_NUM + 1) {
			if (num == ifnum)
				return true;
		}
	}
	return false;
}

static int zte_probe(struct usb_serial *serial,
			const struct usb_device_id *id)
{
	struct zte_intf_private *data;

	data = serial->private = kzalloc(sizeof(struct zte_intf_private), GFP_KERNEL);
	if (!data)
		return -ENOMEM;
	data->send_setup = zte_send_setup;
	spin_lock_init(&data->susp_lock);
	data->private = (void *)id->driver_info;
	return 0;
}


static void zte_instat_callback(struct urb *urb)
{
	int err;
	int status = urb->status;
	struct usb_serial_port *port =  urb->context;
	struct zte_port_private *portdata =
					usb_get_serial_port_data(port);

	dbg("%s: urb %p port %p has data %p", __func__, urb, port, portdata);

	if (status == 0) {
		struct usb_ctrlrequest *req_pkt =
				(struct usb_ctrlrequest *)urb->transfer_buffer;

		if (!req_pkt) {
			dbg("%s: NULL req_pkt", __func__);
			return;
		}
		if ((req_pkt->bRequestType == 0xA1) &&
				(req_pkt->bRequest == 0x20)) {
			int old_dcd_state;
			unsigned char signals = *((unsigned char *)
					urb->transfer_buffer +
					sizeof(struct usb_ctrlrequest));

			dbg("%s: signal x%x", __func__, signals);

			old_dcd_state = portdata->dcd_state;
			portdata->cts_state = 1;
			portdata->dcd_state = ((signals & 0x01) ? 1 : 0);
			portdata->dsr_state = ((signals & 0x02) ? 1 : 0);
			portdata->ri_state = ((signals & 0x08) ? 1 : 0);

			if (old_dcd_state && !portdata->dcd_state) {
				struct tty_struct *tty =
						tty_port_tty_get(&port->port);
				if (tty && !C_CLOCAL(tty))
					tty_hangup(tty);
				tty_kref_put(tty);
			}
		} else {
			dbg("%s: type %x req %x", __func__,
				req_pkt->bRequestType, req_pkt->bRequest);
		}
	} else
		dev_err(&port->dev, "%s: error %d\n", __func__, status);

	/* Resubmit urb so we continue receiving IRQ data */
	if (status != -ESHUTDOWN && status != -ENOENT) {
		err = usb_submit_urb(urb, GFP_ATOMIC);
		if (err)
			dbg("%s: resubmit intr urb failed. (%d)",
				__func__, err);
	}
}

/** send RTS/DTR state to the port.
 *
 * This is exactly the same as SET_CONTROL_LINE_STATE from the PSTN
 * CDC.
*/
static int zte_send_setup(struct usb_serial_port *port)
{
	struct usb_serial *serial = port->serial;
	struct zte_intf_private *intfdata =
		(struct zte_intf_private *) serial->private;
	struct zte_port_private *portdata;
	int ifNum = serial->interface->cur_altsetting->desc.bInterfaceNumber;
	int val = 0;

	if (is_blacklisted(ifNum, ZTE_BLACKLIST_SENDSETUP,
			(struct zte_blacklist_info *) intfdata->private)) {
		dbg("No send_setup on blacklisted interface #%d\n", ifNum);
		return -EIO;
	}

	portdata = usb_get_serial_port_data(port);

	if (portdata->dtr_state)
		val |= 0x01;
	if (portdata->rts_state)
		val |= 0x02;

	return usb_control_msg(serial->dev,
		usb_rcvctrlpipe(serial->dev, 0),
		0x22, 0x21, val, ifNum, NULL, 0, USB_CTRL_SET_TIMEOUT);
}

#ifdef CONFIG_PM
int zte_suspend(struct usb_serial *serial, pm_message_t message)
{
	struct zte_intf_private *intfdata = serial->private;
	int b;

	if (PMSG_IS_AUTO(message)) {
		spin_lock_irq(&intfdata->susp_lock);
		b = intfdata->in_flight;
		spin_unlock_irq(&intfdata->susp_lock);

		if (b)
			return -EBUSY;
	}

	spin_lock_irq(&intfdata->susp_lock);
	intfdata->suspended = 1;
	spin_unlock_irq(&intfdata->susp_lock);
	stop_read_write_urbs(serial);

	return 0;
}


static void unbusy_queued_urb(struct urb *urb, struct zte_port_private *portdata)
{
	int i;

	for (i = 0; i < N_OUT_URB; i++) {
		if (urb == portdata->out_urbs[i]) {
			clear_bit(i, &portdata->out_busy);
			break;
		}
	}
}

static void play_delayed(struct usb_serial_port *port)
{
	struct zte_intf_private *data;
	struct zte_port_private *portdata;
	struct urb *urb;
	int err;

	portdata = usb_get_serial_port_data(port);
	data = port->serial->private;
	while ((urb = usb_get_from_anchor(&portdata->delayed))) {
		err = usb_submit_urb(urb, GFP_ATOMIC);
		if (!err) {
			data->in_flight++;
		} else {
			/* we have to throw away the rest */
			do {
				unbusy_queued_urb(urb, portdata);
				usb_autopm_put_interface_no_suspend(port->serial->interface);
			} while ((urb = usb_get_from_anchor(&portdata->delayed)));
			break;
		}
	}
}

int zte_resume(struct usb_serial *serial)
{
	int i, j;
	struct usb_serial_port *port;
	struct zte_intf_private *intfdata = serial->private;
	struct zte_port_private *portdata;
	struct urb *urb;
	int err = 0;

	/* get the interrupt URBs resubmitted unconditionally */
	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		if (!port->interrupt_in_urb) {
			dbg("%s: No interrupt URB for port %d", __func__, i);
			continue;
		}
		err = usb_submit_urb(port->interrupt_in_urb, GFP_NOIO);
		dbg("Submitted interrupt URB for port %d (result %d)", i, err);
		if (err < 0) {
			dev_err(&port->dev, "%s: Error %d for interrupt URB\n",
				__func__, err);
			goto err_out;
		}
	}

	for (i = 0; i < serial->num_ports; i++) {
		/* walk all ports */
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);

		/* skip closed ports */
		spin_lock_irq(&intfdata->susp_lock);
		if (!portdata->opened) {
			spin_unlock_irq(&intfdata->susp_lock);
			continue;
		}

		for (j = 0; j < N_IN_URB; j++) {
			urb = portdata->in_urbs[j];
			err = usb_submit_urb(urb, GFP_ATOMIC);
			if (err < 0) {
				dev_err(&port->dev, "%s: Error %d for bulk URB %d\n",
					__func__, err, i);
				spin_unlock_irq(&intfdata->susp_lock);
				goto err_out;
			}
		}
		play_delayed(port);
		spin_unlock_irq(&intfdata->susp_lock);
	}
	spin_lock_irq(&intfdata->susp_lock);
	intfdata->suspended = 0;
	spin_unlock_irq(&intfdata->susp_lock);
err_out:
	return err;
}

#endif


MODULE_AUTHOR(DRIVER_AUTHOR);
MODULE_DESCRIPTION(DRIVER_DESC);
MODULE_VERSION(DRIVER_VERSION);
MODULE_LICENSE("GPL");

module_param(debug, bool, S_IRUGO | S_IWUSR);
MODULE_PARM_DESC(debug, "Debug messages");

#elif LINUX_VERSION_CODE < KERNEL_VERSION(3,7,0)//use  3.6 .11 source code

#include <linux/kernel.h>
#include <linux/jiffies.h>
#include <linux/errno.h>
#include <linux/tty.h>
#include <linux/tty_flip.h>
#include <linux/slab.h>
#include <linux/module.h>
#include <linux/bitops.h>
#include <linux/usb.h>
#include <linux/usb/serial.h>
#include <linux/uaccess.h>
#include <linux/serial.h>

/* Function prototypes */
static int  zte_probe(struct usb_serial *serial,
			const struct usb_device_id *id);
static int zte_attach(struct usb_serial *serial);
static void zte_release(struct usb_serial *serial);
static int zte_send_setup(struct usb_serial_port *port);
static void zte_instat_callback(struct urb *urb);
void zte_dtr_rts(struct usb_serial_port *port, int on);
int zte_open(struct tty_struct *tty, struct usb_serial_port *port);
void zte_close(struct usb_serial_port *port);
int zte_port_probe(struct usb_serial_port *port);
int zte_port_remove(struct usb_serial_port *port);
int zte_write_room(struct tty_struct *tty);
void zte_set_termios(struct tty_struct *tty,
				 struct usb_serial_port *port,
				 struct ktermios *old);
int zte_tiocmget(struct tty_struct *tty);
int zte_tiocmset(struct tty_struct *tty,
			     unsigned int set, unsigned int clear);
int zte_ioctl(struct tty_struct *tty,
			  unsigned int cmd, unsigned long arg);
int zte_send_setup(struct usb_serial_port *port);
int zte_write(struct tty_struct *tty, struct usb_serial_port *port,
			  const unsigned char *buf, int count);
int zte_chars_in_buffer(struct tty_struct *tty);
#ifdef CONFIG_PM
int zte_suspend(struct usb_serial *serial, pm_message_t message);
int zte_resume(struct usb_serial *serial);
#endif
/* Vendor and product IDs */
/* ZTE PRODUCTS */
#define zte_VENDOR_ID				0x19d2

/* some devices interfaces need special handling due to a number of reasons */
enum zte_blacklist_reason {
		zte_BLACKLIST_NONE = 0,
		zte_BLACKLIST_SENDSETUP = 1,
		zte_BLACKLIST_RESERVED_IF = 2
};

#define MAX_BL_NUM  8
struct zte_blacklist_info {
	/* bitfield of interface numbers for zte_BLACKLIST_SENDSETUP */
	const unsigned long sendsetup;
	/* bitfield of interface numbers for zte_BLACKLIST_RESERVED_IF */
	const unsigned long reserved;
};

static const struct zte_blacklist_info four_g_w14_blacklist = {
	.sendsetup = BIT(0) | BIT(1),
};

static const struct zte_blacklist_info alcatel_x200_blacklist = {
	.sendsetup = BIT(0) | BIT(1),
};

static const struct zte_blacklist_info zte_0037_blacklist = {
	.sendsetup = BIT(0) | BIT(1),
};

static const struct zte_blacklist_info zte_k3765_z_blacklist = {
	.sendsetup = BIT(0) | BIT(1) | BIT(2),
	.reserved = BIT(4),
};

static const struct zte_blacklist_info zte_ad3812_z_blacklist = {
	.sendsetup = BIT(0) | BIT(1) | BIT(2),
};

static const struct zte_blacklist_info zte_mc2718_z_blacklist = {
	.sendsetup = BIT(1) | BIT(2) | BIT(3) | BIT(4),
};

static const struct zte_blacklist_info zte_mc2716_z_blacklist = {
	.sendsetup = BIT(1) | BIT(2) | BIT(3),
};

static const struct zte_blacklist_info huawei_cdc12_blacklist = {
	.reserved = BIT(1) | BIT(2),
};

static const struct zte_blacklist_info net_intf1_blacklist = {
	.reserved = BIT(1),
};

static const struct zte_blacklist_info net_intf2_blacklist = {
	.reserved = BIT(2),
};

static const struct zte_blacklist_info net_intf3_blacklist = {
	.reserved = BIT(3),
};

static const struct zte_blacklist_info net_intf4_blacklist = {
	.reserved = BIT(4),
};

static const struct zte_blacklist_info net_intf5_blacklist = {
	.reserved = BIT(5),
};

static const struct zte_blacklist_info net_intf6_blacklist = {
	.reserved = BIT(6),
};

static const struct zte_blacklist_info zte_mf626_blacklist = {
	.sendsetup = BIT(0) | BIT(1),
	.reserved = BIT(4),
};

static const struct zte_blacklist_info zte_1255_blacklist = {
	.reserved = BIT(3) | BIT(4),
};

static const struct usb_device_id zte_ids[] = {
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0001, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0002, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0003, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0004, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0005, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0006, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0007, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0008, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0009, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0010, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0011, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0012, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0013, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0014, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0015, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0016, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0017, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0018, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0019, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0020, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0021, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0022, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0023, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0024, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0025, 0xff, 0xff, 0xff) },
    //   { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0026, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0027, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0028, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0029, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0030, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0031, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0032, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0033, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0034, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0035, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0036, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0037, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0038, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0039, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0040, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0041, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0042, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0043, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0044, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0045, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0046, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0047, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0048, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0049, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0050, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0051, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0052, 0xff, 0xff, 0xff) },
    //   { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0053, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0054, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0055, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0056, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0057, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0058, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0059, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0060, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0061, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0062, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0063, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0064, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0065, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0066, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0067, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0068, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0069, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0070, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0071, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0072, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0073, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0074, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0075, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0076, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0077, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0078, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0079, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0080, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0081, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0082, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0083, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0084, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0085, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0086, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0087, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0088, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0089, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0090, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0091, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0092, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0093, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0094, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0095, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0096, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0097, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0098, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0099, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0104, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0105, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0106, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0108, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0117, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0118, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0121, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0122, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0123, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0124, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0125, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0126, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0128, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0130, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0133, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0135, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0136, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0137, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0139, 0xff, 0xff, 0xff) }, 	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0141, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0144, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0145, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0147, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0148, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0151, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0152, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0153, 0xff, 0xff, 0xff) },
    //{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0154, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0155, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0156, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0157, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0158, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0159, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0160, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0161, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0162, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0164, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0165, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0167, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0168, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0170, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0176, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0178, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0189, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0191, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0196, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0197, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0199, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0200, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0201, 0xff, 0xff, 0xff) },		
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0254, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0257, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0265, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0284, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0317, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0330, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0395, 0xff, 0xff, 0xff) },      
 	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0414, 0xff, 0xff, 0xff) },   
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0417, 0xff, 0xff, 0xff) },

    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1008, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1010, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1012, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1018, 0xff, 0xff, 0xff) },		
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1057, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1058, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1059, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1060, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1061, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1062, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1063, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1064, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1065, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1066, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1067, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1068, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1069, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1070, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1071, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1072, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1073, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1074, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1075, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1076, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1077, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1078, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1079, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1080, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1081, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1082, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1083, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1084, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1085, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1086, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1087, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1088, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1089, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1090, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1091, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1092, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1093, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1094, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1095, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1096, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1097, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1098, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1099, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1100, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1101, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1102, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1103, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1104, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1105, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1106, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1107, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1108, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1109, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1110, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1111, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1112, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1113, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1114, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1115, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1116, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1117, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1118, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1119, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1120, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1121, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1122, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1123, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1124, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1125, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1126, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1127, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1128, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1129, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1130, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1131, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1132, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1133, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1134, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1135, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1136, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1137, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1138, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1139, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1140, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1141, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1142, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1143, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1144, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1145, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1146, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1147, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1148, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1149, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1150, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1151, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1152, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1153, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1154, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1155, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1156, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1157, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1158, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1159, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1160, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1161, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1162, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1163, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1164, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1165, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1166, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1167, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1168, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1169, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1170, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1244, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1245, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1246, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1247, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1248, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1249, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1250, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1251, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1252, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1253, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1254, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1255, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1256, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1257, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1258, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1259, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1260, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1261, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1262, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1263, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1264, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1265, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1266, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1267, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1268, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1269, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1270, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1271, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1272, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1273, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1274, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1275, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1276, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1277, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1278, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1279, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1280, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1281, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1282, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1283, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1284, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1285, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1286, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1287, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1288, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1289, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1290, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1291, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1292, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1293, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1294, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1295, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1296, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1297, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1298, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1299, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1300, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1301, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1302, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1303, 0xff, 0xff, 0xff) },	
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1333, 0xff, 0xff, 0xff) },	
	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1401, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1402, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1403, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1404, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1405, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1406, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1407, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1408, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1409, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1410, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1411, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1412, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1413, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1414, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1415, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1416, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1417, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1418, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1419, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1420, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1421, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1422, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1423, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1424, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1425, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1426, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1427, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1428, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1429, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1430, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1431, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1432, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1433, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1434, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1435, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1436, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1437, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1438, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1439, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1440, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1441, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1442, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1443, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1444, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1445, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1446, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1447, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1448, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1449, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1450, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1451, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1452, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1453, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1454, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1455, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1456, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1457, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1458, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1459, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1460, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1461, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1462, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1463, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1464, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1465, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1466, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1467, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1468, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1469, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1470, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1471, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1472, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1473, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1474, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1475, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1476, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1477, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1478, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1479, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1480, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1481, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1482, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1483, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1484, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1485, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1486, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1487, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1488, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1489, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1490, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1491, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1492, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1493, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1494, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1495, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1496, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1497, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1498, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1499, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1500, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1501, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1502, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1503, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1504, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1505, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1506, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1507, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1508, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1509, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1510, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1533, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1534, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1535, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1545, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1546, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1547, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1565, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1566, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1567, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1589, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1590, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1591, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1592, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1594, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1596, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1598, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1600, 0xff, 0xff, 0xff) },  		
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x2002, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x2003, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0xFFEC, 0xff, 0xff, 0xff) },
    { ZTE_USB_DEVICE_ID_MATCH_INT_CLASS_AND_SUBCLASS_INFO(0x19d2,0xff,0x86) },
    { ZTE_USB_DEVICE_ID_MATCH_INT_CLASS_AND_SUBCLASS_INFO(0x19d2,0xff,0x02) },
    { USB_DEVICE_AND_INTERFACE_INFO(TPLink_VENDOR_ID, 0x7E11, 0xff, 0xff, 0xff) },/*TPLink*/
    { USB_DEVICE_AND_INTERFACE_INFO(QUALCOMM_VENDOR_ID, 0x9001, 0xff, 0xff, 0xff) },/*QUALCOMM_VENDOR_ID*/
    { USB_DEVICE_AND_INTERFACE_INFO(QUALCOMM_VENDOR_ID, 0x9002, 0xff, 0xff, 0xff) },
	{ } /* Terminating entry */
};
MODULE_DEVICE_TABLE(usb, zte_ids);

/* The card has three separate interfaces, which the serial driver
 * recognizes separately, thus num_port=1.
 */

static struct usb_serial_driver zte_1port_device = {
	.driver = {
		.owner =	THIS_MODULE,
		.name =		"zte1",
	},
	.description       = "GSM modem (1-port)",
	.id_table          = zte_ids,
	.num_ports         = 1,
	.probe             = zte_probe,
	.open              = zte_open,
	.close             = zte_close,
	.dtr_rts	   = zte_dtr_rts,
	.write             = zte_write,
	.write_room        = zte_write_room,
	.chars_in_buffer   = zte_chars_in_buffer,
	.set_termios       = zte_set_termios,
	.tiocmget          = zte_tiocmget,
	.tiocmset          = zte_tiocmset,
	.ioctl             = zte_ioctl,
	.attach            = zte_attach,
	.release           = zte_release,
	.port_probe        = zte_port_probe,
	.port_remove	   = zte_port_remove,
	.read_int_callback = zte_instat_callback,
#ifdef CONFIG_PM
	.suspend           = zte_suspend,
	.resume            = zte_resume,
#endif
};

static struct usb_serial_driver * const serial_drivers[] = {
	&zte_1port_device, NULL
};

static bool debug;
/* per port private data */

#define N_IN_URB 4
#define N_OUT_URB 4
#define IN_BUFLEN 4096
#define OUT_BUFLEN 4096

struct zte_intf_private {
	spinlock_t susp_lock;
	unsigned int suspended:1;
	int in_flight;
	int (*send_setup) (struct usb_serial_port *port);
	void *private;
};

struct zte_port_private {
	/* Input endpoints and buffer for this port */
	struct urb *in_urbs[N_IN_URB];
	u8 *in_buffer[N_IN_URB];
	/* Output endpoints and buffer for this port */
	struct urb *out_urbs[N_OUT_URB];
	u8 *out_buffer[N_OUT_URB];
	unsigned long out_busy;	/* Bit vector of URBs in use */
	int opened;
	struct usb_anchor delayed;

	/* Settings for the port */
	int rts_state;		/* Handshaking pins (outputs) */
	int dtr_state;
	int cts_state;		/* Handshaking pins (inputs) */
	int dsr_state;
	int dcd_state;
	int ri_state;

	unsigned long tx_start_time[N_OUT_URB];
};
void zte_dtr_rts(struct usb_serial_port *port, int on)
{
	struct usb_serial *serial = port->serial;
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata;

	intfdata = port->serial->private;

	if (!intfdata->send_setup)
		return;

	portdata = usb_get_serial_port_data(port);
	mutex_lock(&serial->disc_mutex);
	portdata->rts_state = on;
	portdata->dtr_state = on;
	if (serial->dev)
		intfdata->send_setup(port);
	mutex_unlock(&serial->disc_mutex);
}


void zte_set_termios(struct tty_struct *tty,
			  struct usb_serial_port *port,
			  struct ktermios *old_termios)
{
	struct zte_intf_private *intfdata = port->serial->private;

	/* Doesn't support option setting */
	tty_termios_copy_hw(tty->termios, old_termios);

	if (intfdata->send_setup)
		intfdata->send_setup(port);
}


int zte_tiocmget(struct tty_struct *tty)
{
	struct usb_serial_port *port = tty->driver_data;
	unsigned int value;
	struct zte_port_private *portdata;

	portdata = usb_get_serial_port_data(port);

	value = ((portdata->rts_state) ? TIOCM_RTS : 0) |
	    ((portdata->dtr_state) ? TIOCM_DTR : 0) |
	    ((portdata->cts_state) ? TIOCM_CTS : 0) |
	    ((portdata->dsr_state) ? TIOCM_DSR : 0) |
	    ((portdata->dcd_state) ? TIOCM_CAR : 0) |
	    ((portdata->ri_state) ? TIOCM_RNG : 0);

	return value;
}


int zte_tiocmset(struct tty_struct *tty,
		      unsigned int set, unsigned int clear)
{
	struct usb_serial_port *port = tty->driver_data;
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata;

	portdata = usb_get_serial_port_data(port);
	intfdata = port->serial->private;

	if (!intfdata->send_setup)
		return -EINVAL;

	/* FIXME: what locks portdata fields ? */
	if (set & TIOCM_RTS)
		portdata->rts_state = 1;
	if (set & TIOCM_DTR)
		portdata->dtr_state = 1;

	if (clear & TIOCM_RTS)
		portdata->rts_state = 0;
	if (clear & TIOCM_DTR)
		portdata->dtr_state = 0;
	return intfdata->send_setup(port);
}


static int get_serial_info(struct usb_serial_port *port,
			   struct serial_struct __user *retinfo)
{
	struct serial_struct tmp;

	if (!retinfo)
		return -EFAULT;

	memset(&tmp, 0, sizeof(tmp));
	tmp.line            = port->serial->minor;
	tmp.port            = port->number;
	tmp.baud_base       = tty_get_baud_rate(port->port.tty);
	tmp.close_delay	    = port->port.close_delay / 10;
	tmp.closing_wait    = port->port.closing_wait == ASYNC_CLOSING_WAIT_NONE ?
				 ASYNC_CLOSING_WAIT_NONE :
				 port->port.closing_wait / 10;

	if (copy_to_user(retinfo, &tmp, sizeof(*retinfo)))
		return -EFAULT;
	return 0;
}

static int set_serial_info(struct usb_serial_port *port,
			   struct serial_struct __user *newinfo)
{
	struct serial_struct new_serial;
	unsigned int closing_wait, close_delay;
	int retval = 0;

	if (copy_from_user(&new_serial, newinfo, sizeof(new_serial)))
		return -EFAULT;

	close_delay = new_serial.close_delay * 10;
	closing_wait = new_serial.closing_wait == ASYNC_CLOSING_WAIT_NONE ?
			ASYNC_CLOSING_WAIT_NONE : new_serial.closing_wait * 10;

	mutex_lock(&port->port.mutex);

	if (!capable(CAP_SYS_ADMIN)) {
		if ((close_delay != port->port.close_delay) ||
		    (closing_wait != port->port.closing_wait))
			retval = -EPERM;
		else
			retval = -EOPNOTSUPP;
	} else {
		port->port.close_delay  = close_delay;
		port->port.closing_wait = closing_wait;
	}

	mutex_unlock(&port->port.mutex);
	return retval;
}

int zte_ioctl(struct tty_struct *tty,
		   unsigned int cmd, unsigned long arg)
{
	struct usb_serial_port *port = tty->driver_data;

	dbg("%s cmd 0x%04x", __func__, cmd);

	switch (cmd) {
	case TIOCGSERIAL:
		return get_serial_info(port,
				       (struct serial_struct __user *) arg);
	case TIOCSSERIAL:
		return set_serial_info(port,
				       (struct serial_struct __user *) arg);
	default:
		break;
	}

	dbg("%s arg not supported", __func__);

	return -ENOIOCTLCMD;
}


/* Write */
int zte_write(struct tty_struct *tty, struct usb_serial_port *port,
		   const unsigned char *buf, int count)
{
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata;
	int i;
	int left, todo;
	struct urb *this_urb = NULL;	/* spurious */
	int err;
	unsigned long flags;

	portdata = usb_get_serial_port_data(port);
	intfdata = port->serial->private;

	dbg("%s: write (%d chars)", __func__, count);

	i = 0;
	left = count;
	for (i = 0; left > 0 && i < N_OUT_URB; i++) {
		todo = left;
		if (todo > OUT_BUFLEN)
			todo = OUT_BUFLEN;

		this_urb = portdata->out_urbs[i];
		if (test_and_set_bit(i, &portdata->out_busy)) {
			if (time_before(jiffies,
					portdata->tx_start_time[i] + 10 * HZ))
				continue;
			usb_unlink_urb(this_urb);
			continue;
		}
		dbg("%s: endpoint %d buf %d", __func__,
		    usb_pipeendpoint(this_urb->pipe), i);

		err = usb_autopm_get_interface_async(port->serial->interface);
		if (err < 0)
			break;

		/* send the data */
		memcpy(this_urb->transfer_buffer, buf, todo);
		this_urb->transfer_buffer_length = todo;

		spin_lock_irqsave(&intfdata->susp_lock, flags);
		if (intfdata->suspended) {
			usb_anchor_urb(this_urb, &portdata->delayed);
			spin_unlock_irqrestore(&intfdata->susp_lock, flags);
		} else {
			intfdata->in_flight++;
			spin_unlock_irqrestore(&intfdata->susp_lock, flags);
			err = usb_submit_urb(this_urb, GFP_ATOMIC);
			if (err) {
				dbg("usb_submit_urb %p (write bulk) failed "
				    "(%d)", this_urb, err);
				clear_bit(i, &portdata->out_busy);
				spin_lock_irqsave(&intfdata->susp_lock, flags);
				intfdata->in_flight--;
				spin_unlock_irqrestore(&intfdata->susp_lock,
						       flags);
				usb_autopm_put_interface_async(port->serial->interface);
				break;
			}
		}

		portdata->tx_start_time[i] = jiffies;
		buf += todo;
		left -= todo;
	}

	count -= left;
	dbg("%s: wrote (did %d)", __func__, count);
	return count;
}


static void zte_indat_callback(struct urb *urb)
{
	int err;
	int endpoint;
	struct usb_serial_port *port;
	struct tty_struct *tty;
	unsigned char *data = urb->transfer_buffer;
	int status = urb->status;

	endpoint = usb_pipeendpoint(urb->pipe);
	port = urb->context;

	if (status) {
		dbg("%s: nonzero status: %d on endpoint %02x.",
		    __func__, status, endpoint);
	} else {
		tty = tty_port_tty_get(&port->port);
		if (tty) {
			if (urb->actual_length) {
				tty_insert_flip_string(tty, data,
						urb->actual_length);
				tty_flip_buffer_push(tty);
			} else
				dbg("%s: empty read urb received", __func__);
			tty_kref_put(tty);
		}

		/* Resubmit urb so we continue receiving */
		err = usb_submit_urb(urb, GFP_ATOMIC);
		if (err) {
			if (err != -EPERM) {
				printk(KERN_ERR "%s: resubmit read urb failed. "
					"(%d)", __func__, err);
				/* busy also in error unless we are killed */
				usb_mark_last_busy(port->serial->dev);
			}
		} else {
			usb_mark_last_busy(port->serial->dev);
		}
	}
}

static void zte_outdat_callback(struct urb *urb)
{
	struct usb_serial_port *port;
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata;
	int i;

	port = urb->context;
	intfdata = port->serial->private;

	usb_serial_port_softint(port);
	usb_autopm_put_interface_async(port->serial->interface);
	portdata = usb_get_serial_port_data(port);
	spin_lock(&intfdata->susp_lock);
	intfdata->in_flight--;
	spin_unlock(&intfdata->susp_lock);

	for (i = 0; i < N_OUT_URB; ++i) {
		if (portdata->out_urbs[i] == urb) {
			smp_mb__before_clear_bit();
			clear_bit(i, &portdata->out_busy);
			break;
		}
	}
}

int zte_write_room(struct tty_struct *tty)
{
	struct usb_serial_port *port = tty->driver_data;
	struct zte_port_private *portdata;
	int i;
	int data_len = 0;
	struct urb *this_urb;

	portdata = usb_get_serial_port_data(port);

	for (i = 0; i < N_OUT_URB; i++) {
		this_urb = portdata->out_urbs[i];
		if (this_urb && !test_bit(i, &portdata->out_busy))
			data_len += OUT_BUFLEN;
	}

	dbg("%s: %d", __func__, data_len);
	return data_len;
}


int zte_chars_in_buffer(struct tty_struct *tty)
{
	struct usb_serial_port *port = tty->driver_data;
	struct zte_port_private *portdata;
	int i;
	int data_len = 0;
	struct urb *this_urb;

	portdata = usb_get_serial_port_data(port);

	for (i = 0; i < N_OUT_URB; i++) {
		this_urb = portdata->out_urbs[i];
		/* FIXME: This locking is insufficient as this_urb may
		   go unused during the test */
		if (this_urb && test_bit(i, &portdata->out_busy))
			data_len += this_urb->transfer_buffer_length;
	}
	dbg("%s: %d", __func__, data_len);
	return data_len;
}


int zte_open(struct tty_struct *tty, struct usb_serial_port *port)
{
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata;
	struct usb_serial *serial = port->serial;
	int i, err;
	struct urb *urb;

	portdata = usb_get_serial_port_data(port);
	intfdata = serial->private;

	/* Start reading from the IN endpoint */
	for (i = 0; i < N_IN_URB; i++) {
		urb = portdata->in_urbs[i];
		if (!urb)
			continue;
		err = usb_submit_urb(urb, GFP_KERNEL);
		if (err) {
			dbg("%s: submit urb %d failed (%d) %d",
			    __func__, i, err, urb->transfer_buffer_length);
		}
	}

	if (intfdata->send_setup)
		intfdata->send_setup(port);

	serial->interface->needs_remote_wakeup = 1;
	spin_lock_irq(&intfdata->susp_lock);
	portdata->opened = 1;
	spin_unlock_irq(&intfdata->susp_lock);
	/* this balances a get in the generic USB serial code */
	usb_autopm_put_interface(serial->interface);

	return 0;
}


void zte_close(struct usb_serial_port *port)
{
	int i;
	struct usb_serial *serial = port->serial;
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata = port->serial->private;

	portdata = usb_get_serial_port_data(port);

	if (serial->dev) {
		/* Stop reading/writing urbs */
		spin_lock_irq(&intfdata->susp_lock);
		portdata->opened = 0;
		spin_unlock_irq(&intfdata->susp_lock);

		for (i = 0; i < N_IN_URB; i++)
			usb_kill_urb(portdata->in_urbs[i]);
		for (i = 0; i < N_OUT_URB; i++)
			usb_kill_urb(portdata->out_urbs[i]);
		/* balancing - important as an error cannot be handled*/
		usb_autopm_get_interface_no_resume(serial->interface);
		serial->interface->needs_remote_wakeup = 0;
	}
}


/* Helper functions used by zte_setup_urbs */
static struct urb *zte_setup_urb(struct usb_serial_port *port,
				      int endpoint,
				      int dir, void *ctx, char *buf, int len,
				      void (*callback) (struct urb *))
{
	struct usb_serial *serial = port->serial;
	struct urb *urb;

	urb = usb_alloc_urb(0, GFP_KERNEL);	/* No ISO */
	if (urb == NULL) {
		dbg("%s: alloc for endpoint %d failed.", __func__, endpoint);
		return NULL;
	}

	/* Fill URB using supplied data. */
	usb_fill_bulk_urb(urb, serial->dev,
			  usb_sndbulkpipe(serial->dev, endpoint) | dir,
			  buf, len, callback, ctx);

	return urb;
}

int zte_port_probe(struct usb_serial_port *port)
{
	struct zte_port_private *portdata;
	struct urb *urb;
	u8 *buffer;
	int err;
	int i;

	portdata = kzalloc(sizeof(*portdata), GFP_KERNEL);
	if (!portdata)
		return -ENOMEM;

	init_usb_anchor(&portdata->delayed);

	for (i = 0; i < N_IN_URB; i++) {
		if (!port->bulk_in_size)
			break;

		buffer = (u8 *)__get_free_page(GFP_KERNEL);
		if (!buffer)
			goto bail_out_error;
		portdata->in_buffer[i] = buffer;

		urb = zte_setup_urb(port, port->bulk_in_endpointAddress,
						USB_DIR_IN, port,
						buffer, IN_BUFLEN,
						zte_indat_callback);
		portdata->in_urbs[i] = urb;
 	}
	for (i = 0; i < N_OUT_URB; i++) {
		if (!port->bulk_out_size)
			break;

		buffer = kmalloc(OUT_BUFLEN, GFP_KERNEL);
		if (!buffer)
			goto bail_out_error2;
		portdata->out_buffer[i] = buffer;

		urb = zte_setup_urb(port, port->bulk_out_endpointAddress,
						USB_DIR_OUT, port,
						buffer, OUT_BUFLEN,
						zte_outdat_callback);
		portdata->out_urbs[i] = urb;
	}

	usb_set_serial_port_data(port, portdata);

	if (port->interrupt_in_urb) {
		err = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);
		if (err)
			dev_dbg(&port->dev, "%s: submit irq_in urb failed %d\n",
				__func__, err);
	}

	return 0;

bail_out_error2:
	for (i = 0; i < N_OUT_URB; i++) {
		usb_free_urb(portdata->out_urbs[i]);
		kfree(portdata->out_buffer[i]);
	}
bail_out_error:
	for (i = 0; i < N_IN_URB; i++) {
		usb_free_urb(portdata->in_urbs[i]);
		free_page((unsigned long)portdata->in_buffer[i]);
	}
	kfree(portdata);

	return -ENOMEM;
}


int zte_port_remove(struct usb_serial_port *port)
{
	int i;
	struct zte_port_private *portdata;

	portdata = usb_get_serial_port_data(port);
	usb_set_serial_port_data(port, NULL);

	/* Stop reading/writing urbs and free them */
	for (i = 0; i < N_IN_URB; i++) {
		usb_kill_urb(portdata->in_urbs[i]);
		usb_free_urb(portdata->in_urbs[i]);
		free_page((unsigned long)portdata->in_buffer[i]);
	}
	for (i = 0; i < N_OUT_URB; i++) {
		usb_kill_urb(portdata->out_urbs[i]);
		usb_free_urb(portdata->out_urbs[i]);
		kfree(portdata->out_buffer[i]);
	}

	/* Now free port private data */
	kfree(portdata);
	return 0;
}

struct zte_private {
	u8 bInterfaceNumber;
};

module_usb_serial_driver(serial_drivers, zte_ids);

static bool is_blacklisted(const u8 ifnum, enum zte_blacklist_reason reason,
			   const struct zte_blacklist_info *blacklist)
{
	unsigned long num;
	const unsigned long *intf_list;

	if (blacklist) {
		if (reason == zte_BLACKLIST_SENDSETUP)
			intf_list = &blacklist->sendsetup;
		else if (reason == zte_BLACKLIST_RESERVED_IF)
			intf_list = &blacklist->reserved;
		else {
			BUG_ON(reason);
			return false;
		}

		for_each_set_bit(num, intf_list, MAX_BL_NUM + 1) {
			if (num == ifnum)
				return true;
		}
	}
	return false;
}

static int zte_probe(struct usb_serial *serial,
			const struct usb_device_id *id)
{
	struct usb_interface_descriptor *iface_desc =
				&serial->interface->cur_altsetting->desc;
	struct usb_device_descriptor *dev_desc = &serial->dev->descriptor;

	
	/* Store device id so we can use it during attach. */
	usb_set_serial_data(serial, (void *)id);

	return 0;
}

static int zte_attach(struct usb_serial *serial)
{
	struct usb_interface_descriptor *iface_desc;
	const struct usb_device_id *id;
	struct zte_intf_private *data;
	struct zte_private *priv;

	data = kzalloc(sizeof(struct zte_intf_private), GFP_KERNEL);
	if (!data)
		return -ENOMEM;

	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
	if (!priv) {
		kfree(data);
		return -ENOMEM;
	}

	/* Retrieve device id stored at probe. */
	id = usb_get_serial_data(serial);
	iface_desc = &serial->interface->cur_altsetting->desc;

	priv->bInterfaceNumber = iface_desc->bInterfaceNumber;
	data->private = priv;

	if (!is_blacklisted(iface_desc->bInterfaceNumber,
			zte_BLACKLIST_SENDSETUP,
			(struct zte_blacklist_info *)id->driver_info)) {
		data->send_setup = zte_send_setup;
	}
	spin_lock_init(&data->susp_lock);

	usb_set_serial_data(serial, data);

	return 0;
}
static void zte_release(struct usb_serial *serial)
{
	struct zte_intf_private *intfdata = usb_get_serial_data(serial);
	struct zte_private *priv = intfdata->private;

	kfree(priv);
	kfree(intfdata);
}
static void zte_instat_callback(struct urb *urb)
{
	int err;
	int status = urb->status;
	struct usb_serial_port *port =  urb->context;
	struct zte_port_private *portdata =
					usb_get_serial_port_data(port);

	dbg("%s: urb %p port %p has data %p", __func__, urb, port, portdata);

	if (status == 0) {
		struct usb_ctrlrequest *req_pkt =
				(struct usb_ctrlrequest *)urb->transfer_buffer;

		if (!req_pkt) {
			dbg("%s: NULL req_pkt", __func__);
			return;
		}
		if ((req_pkt->bRequestType == 0xA1) &&
				(req_pkt->bRequest == 0x20)) {
			int old_dcd_state;
			unsigned char signals = *((unsigned char *)
					urb->transfer_buffer +
					sizeof(struct usb_ctrlrequest));

			dbg("%s: signal x%x", __func__, signals);

			old_dcd_state = portdata->dcd_state;
			portdata->cts_state = 1;
			portdata->dcd_state = ((signals & 0x01) ? 1 : 0);
			portdata->dsr_state = ((signals & 0x02) ? 1 : 0);
			portdata->ri_state = ((signals & 0x08) ? 1 : 0);

			if (old_dcd_state && !portdata->dcd_state) {
				struct tty_struct *tty =
						tty_port_tty_get(&port->port);
				if (tty && !C_CLOCAL(tty))
					tty_hangup(tty);
				tty_kref_put(tty);
			}
		} else {
			dbg("%s: type %x req %x", __func__,
				req_pkt->bRequestType, req_pkt->bRequest);
		}
	} else
		dev_err(&port->dev, "%s: error %d\n", __func__, status);

	/* Resubmit urb so we continue receiving IRQ data */
	if (status != -ESHUTDOWN && status != -ENOENT) {
		err = usb_submit_urb(urb, GFP_ATOMIC);
		if (err)
			dbg("%s: resubmit intr urb failed. (%d)",
				__func__, err);
	}
}

/** send RTS/DTR state to the port.
 *
 * This is exactly the same as SET_CONTROL_LINE_STATE from the PSTN
 * CDC.
*/
static int zte_send_setup(struct usb_serial_port *port)
{
	struct usb_serial *serial = port->serial;
	struct zte_intf_private *intfdata = usb_get_serial_data(serial);
	struct zte_private *priv = intfdata->private;
	struct zte_port_private *portdata;
	int val = 0;

	portdata = usb_get_serial_port_data(port);

	if (portdata->dtr_state)
		val |= 0x01;
	if (portdata->rts_state)
		val |= 0x02;

	return usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),
				0x22, 0x21, val, priv->bInterfaceNumber, NULL,
				0, USB_CTRL_SET_TIMEOUT);
}
#ifdef CONFIG_PM
static void stop_read_write_urbs(struct usb_serial *serial)
{
	int i, j;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;

	/* Stop reading/writing urbs */
	for (i = 0; i < serial->num_ports; ++i) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);
		if (!portdata)
			continue;
		for (j = 0; j < N_IN_URB; j++)
			usb_kill_urb(portdata->in_urbs[j]);
		for (j = 0; j < N_OUT_URB; j++)
			usb_kill_urb(portdata->out_urbs[j]);
	}
}

int zte_suspend(struct usb_serial *serial, pm_message_t message)
{
	struct zte_intf_private *intfdata = serial->private;
	int b;

	if (PMSG_IS_AUTO(message)) {
		spin_lock_irq(&intfdata->susp_lock);
		b = intfdata->in_flight;
		spin_unlock_irq(&intfdata->susp_lock);

		if (b)
			return -EBUSY;
	}

	spin_lock_irq(&intfdata->susp_lock);
	intfdata->suspended = 1;
	spin_unlock_irq(&intfdata->susp_lock);
	stop_read_write_urbs(serial);

	return 0;
}


static void unbusy_queued_urb(struct urb *urb, struct zte_port_private *portdata)
{
	int i;

	for (i = 0; i < N_OUT_URB; i++) {
		if (urb == portdata->out_urbs[i]) {
			clear_bit(i, &portdata->out_busy);
			break;
		}
	}
}

static void play_delayed(struct usb_serial_port *port)
{
	struct zte_intf_private *data;
	struct zte_port_private *portdata;
	struct urb *urb;
	int err;

	portdata = usb_get_serial_port_data(port);
	data = port->serial->private;
	while ((urb = usb_get_from_anchor(&portdata->delayed))) {
		err = usb_submit_urb(urb, GFP_ATOMIC);
		if (!err) {
			data->in_flight++;
		} else {
			/* we have to throw away the rest */
			do {
				unbusy_queued_urb(urb, portdata);
				usb_autopm_put_interface_no_suspend(port->serial->interface);
			} while ((urb = usb_get_from_anchor(&portdata->delayed)));
			break;
		}
	}
}

int zte_resume(struct usb_serial *serial)
{
	int i, j;
	struct usb_serial_port *port;
	struct zte_intf_private *intfdata = serial->private;
	struct zte_port_private *portdata;
	struct urb *urb;
	int err = 0;

	/* get the interrupt URBs resubmitted unconditionally */
	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		if (!port->interrupt_in_urb) {
			dbg("%s: No interrupt URB for port %d", __func__, i);
			continue;
		}
		err = usb_submit_urb(port->interrupt_in_urb, GFP_NOIO);
		dbg("Submitted interrupt URB for port %d (result %d)", i, err);
		if (err < 0) {
			dev_err(&port->dev, "%s: Error %d for interrupt URB\n",
				__func__, err);
			goto err_out;
		}
	}

	for (i = 0; i < serial->num_ports; i++) {
		/* walk all ports */
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);

		/* skip closed ports */
		spin_lock_irq(&intfdata->susp_lock);
		if (!portdata || !portdata->opened) {
			spin_unlock_irq(&intfdata->susp_lock);
			continue;
		}

		for (j = 0; j < N_IN_URB; j++) {
			urb = portdata->in_urbs[j];
			err = usb_submit_urb(urb, GFP_ATOMIC);
			if (err < 0) {
				dev_err(&port->dev, "%s: Error %d for bulk URB %d\n",
					__func__, err, i);
				spin_unlock_irq(&intfdata->susp_lock);
				goto err_out;
			}
		}
		play_delayed(port);
		spin_unlock_irq(&intfdata->susp_lock);
	}
	spin_lock_irq(&intfdata->susp_lock);
	intfdata->suspended = 0;
	spin_unlock_irq(&intfdata->susp_lock);
err_out:
	return err;
}

#endif


MODULE_AUTHOR(DRIVER_AUTHOR);
MODULE_DESCRIPTION(DRIVER_DESC);
MODULE_VERSION(DRIVER_VERSION);
MODULE_LICENSE("GPL");

module_param(debug, bool, S_IRUGO | S_IWUSR);
MODULE_PARM_DESC(debug, "Debug messages");
#elif LINUX_VERSION_CODE < KERNEL_VERSION(3,9,0)//use  3.8 .13 source code
/*
  USB Driver for GSM modems

  Copyright (C) 2005  Matthias Urlichs <smurf@smurf.noris.de>

  This driver is free software; you can redistribute it and/or modify
  it under the terms of Version 2 of the GNU General Public License as
  published by the Free Software Foundation.

  Portions copied from the Keyspan driver by Hugh Blemings <hugh@blemings.org>

  History: see the git log.

  Work sponsored by: Sigos GmbH, Germany <info@sigos.de>

  This driver exists because the "normal" serial driver doesn't work too well
  with GSM modems. Issues:
  - data loss -- one single Receive URB is not nearly enough
  - nonstandard flow (zte devices) control
  - controlling the baud rate doesn't make sense

  This driver is named "zte" because the most common device it's
  used for is a PC-Card (with an internal OHCI-USB interface, behind
  which the GSM interface sits), made by zte Inc.

  Some of the "one port" devices actually exhibit multiple USB instances
  on the USB bus. This is not a bug, these ports are used for different
  device features.
*/

#define DRIVER_AUTHOR "Matthias Urlichs <smurf@smurf.noris.de>"
#define DRIVER_DESC "USB Driver for GSM modems"

#include <linux/kernel.h>
#include <linux/jiffies.h>
#include <linux/errno.h>
#include <linux/tty.h>
#include <linux/tty_flip.h>
#include <linux/slab.h>
#include <linux/module.h>
#include <linux/bitops.h>
#include <linux/usb.h>
#include <linux/usb/serial.h>
#include <linux/uaccess.h>
#include <linux/serial.h>
//#include "usb-wwan.h"

 void zte_dtr_rts(struct usb_serial_port *port, int on);
 int zte_open(struct tty_struct *tty, struct usb_serial_port *port);
 void zte_close(struct usb_serial_port *port);
 int zte_port_probe(struct usb_serial_port *port);
 int zte_port_remove(struct usb_serial_port *port);
 int zte_write_room(struct tty_struct *tty);
 void zte_set_termios(struct tty_struct *tty,
				 struct usb_serial_port *port,
				 struct ktermios *old);
 int zte_tiocmget(struct tty_struct *tty);
 int zte_tiocmset(struct tty_struct *tty,
			     unsigned int set, unsigned int clear);
 int zte_ioctl(struct tty_struct *tty,
			  unsigned int cmd, unsigned long arg);
 int zte_write(struct tty_struct *tty, struct usb_serial_port *port,
			  const unsigned char *buf, int count);
 int zte_chars_in_buffer(struct tty_struct *tty);
#ifdef CONFIG_PM
 int zte_suspend(struct usb_serial *serial, pm_message_t message);
 int zte_resume(struct usb_serial *serial);
#endif


/* Vendor and product IDs */
#define zte_VENDOR_ID			0x19d2


/* per port private data */

#define N_IN_URB 4
#define N_OUT_URB 4
#define IN_BUFLEN 4096
#define OUT_BUFLEN 4096

struct zte_intf_private {
	spinlock_t susp_lock;
	unsigned int suspended:1;
	int in_flight;
	int (*send_setup) (struct usb_serial_port *port);
	void *private;
};

struct zte_port_private {
	/* Input endpoints and buffer for this port */
	struct urb *in_urbs[N_IN_URB];
	u8 *in_buffer[N_IN_URB];
	/* Output endpoints and buffer for this port */
	struct urb *out_urbs[N_OUT_URB];
	u8 *out_buffer[N_OUT_URB];
	unsigned long out_busy;	/* Bit vector of URBs in use */
	int opened;
	struct usb_anchor delayed;

	/* Settings for the port */
	int rts_state;		/* Handshaking pins (outputs) */
	int dtr_state;
	int cts_state;		/* Handshaking pins (inputs) */
	int dsr_state;
	int dcd_state;
	int ri_state;

	unsigned long tx_start_time[N_OUT_URB];
};

/* Function prototypes */
static int  zte_probe(struct usb_serial *serial,
			const struct usb_device_id *id);
static int zte_attach(struct usb_serial *serial);
static void zte_release(struct usb_serial *serial);
static int zte_send_setup(struct usb_serial_port *port);
static void zte_instat_callback(struct urb *urb);
		 
/* some devices interfaces need special handling due to a number of reasons */
enum zte_blacklist_reason {
		zte_BLACKLIST_NONE = 0,
		zte_BLACKLIST_SENDSETUP = 1,
		zte_BLACKLIST_RESERVED_IF = 2
};

#define MAX_BL_NUM  8
struct zte_blacklist_info {
	/* bitfield of interface numbers for zte_BLACKLIST_SENDSETUP */
	const unsigned long sendsetup;
	/* bitfield of interface numbers for zte_BLACKLIST_RESERVED_IF */
	const unsigned long reserved;
};

static const struct zte_blacklist_info four_g_w14_blacklist = {
	.sendsetup = BIT(0) | BIT(1),
};

static const struct zte_blacklist_info alcatel_x200_blacklist = {
	.sendsetup = BIT(0) | BIT(1),
	.reserved = BIT(4),
};

static const struct zte_blacklist_info zte_0037_blacklist = {
	.sendsetup = BIT(0) | BIT(1),
};

static const struct zte_blacklist_info zte_k3765_z_blacklist = {
	.sendsetup = BIT(0) | BIT(1) | BIT(2),
	.reserved = BIT(4),
};

static const struct zte_blacklist_info zte_ad3812_z_blacklist = {
	.sendsetup = BIT(0) | BIT(1) | BIT(2),
};

static const struct zte_blacklist_info zte_mc2718_z_blacklist = {
	.sendsetup = BIT(1) | BIT(2) | BIT(3) | BIT(4),
};

static const struct zte_blacklist_info zte_mc2716_z_blacklist = {
	.sendsetup = BIT(1) | BIT(2) | BIT(3),
};

static const struct zte_blacklist_info huawei_cdc12_blacklist = {
	.reserved = BIT(1) | BIT(2),
};

static const struct zte_blacklist_info net_intf1_blacklist = {
	.reserved = BIT(1),
};

static const struct zte_blacklist_info net_intf2_blacklist = {
	.reserved = BIT(2),
};

static const struct zte_blacklist_info net_intf3_blacklist = {
	.reserved = BIT(3),
};

static const struct zte_blacklist_info net_intf4_blacklist = {
	.reserved = BIT(4),
};

static const struct zte_blacklist_info net_intf5_blacklist = {
	.reserved = BIT(5),
};

static const struct zte_blacklist_info net_intf6_blacklist = {
	.reserved = BIT(6),
};

static const struct zte_blacklist_info zte_mf626_blacklist = {
	.sendsetup = BIT(0) | BIT(1),
	.reserved = BIT(4),
};

static const struct zte_blacklist_info zte_1255_blacklist = {
	.reserved = BIT(3) | BIT(4),
};

static const struct zte_blacklist_info telit_le920_blacklist = {
	.sendsetup = BIT(0),
	.reserved = BIT(1) | BIT(5),
};
static const struct usb_device_id zte_ids[] = {
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0001, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0002, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0003, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0004, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0005, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0006, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0007, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0008, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0009, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0010, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0011, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0012, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0013, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0014, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0015, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0016, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0017, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0018, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0019, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0020, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0021, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0022, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0023, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0024, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0025, 0xff, 0xff, 0xff) },
    //   { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0026, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0027, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0028, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0029, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0030, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0031, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0032, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0033, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0034, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0035, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0036, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0037, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0038, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0039, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0040, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0041, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0042, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0043, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0044, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0045, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0046, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0047, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0048, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0049, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0050, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0051, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0052, 0xff, 0xff, 0xff) },
    //   { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0053, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0054, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0055, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0056, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0057, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0058, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0059, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0060, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0061, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0062, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0063, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0064, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0065, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0066, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0067, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0068, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0069, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0070, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0071, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0072, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0073, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0074, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0075, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0076, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0077, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0078, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0079, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0080, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0081, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0082, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0083, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0084, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0085, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0086, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0087, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0088, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0089, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0090, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0091, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0092, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0093, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0094, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0095, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0096, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0097, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0098, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0099, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0104, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0105, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0106, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0108, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0117, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0118, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0121, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0122, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0123, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0124, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0125, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0126, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0128, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0130, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0133, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0135, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0136, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0137, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0139, 0xff, 0xff, 0xff) }, 	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0141, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0144, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0145, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0147, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0148, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0151, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0152, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0153, 0xff, 0xff, 0xff) },
    //{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0154, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0155, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0156, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0157, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0158, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0159, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0160, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0161, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0162, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0164, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0165, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0167, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0168, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0170, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0176, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0178, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0189, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0191, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0196, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0197, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0199, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0200, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0201, 0xff, 0xff, 0xff) },		
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0254, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0257, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0265, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0284, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0317, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0330, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0395, 0xff, 0xff, 0xff) },      
 	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0414, 0xff, 0xff, 0xff) },   
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0417, 0xff, 0xff, 0xff) },

    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1008, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1010, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1012, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1018, 0xff, 0xff, 0xff) },		
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1057, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1058, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1059, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1060, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1061, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1062, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1063, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1064, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1065, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1066, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1067, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1068, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1069, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1070, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1071, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1072, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1073, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1074, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1075, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1076, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1077, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1078, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1079, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1080, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1081, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1082, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1083, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1084, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1085, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1086, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1087, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1088, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1089, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1090, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1091, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1092, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1093, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1094, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1095, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1096, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1097, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1098, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1099, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1100, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1101, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1102, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1103, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1104, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1105, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1106, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1107, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1108, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1109, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1110, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1111, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1112, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1113, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1114, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1115, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1116, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1117, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1118, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1119, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1120, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1121, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1122, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1123, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1124, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1125, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1126, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1127, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1128, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1129, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1130, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1131, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1132, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1133, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1134, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1135, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1136, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1137, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1138, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1139, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1140, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1141, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1142, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1143, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1144, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1145, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1146, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1147, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1148, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1149, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1150, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1151, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1152, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1153, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1154, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1155, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1156, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1157, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1158, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1159, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1160, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1161, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1162, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1163, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1164, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1165, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1166, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1167, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1168, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1169, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1170, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1244, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1245, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1246, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1247, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1248, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1249, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1250, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1251, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1252, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1253, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1254, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1255, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1256, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1257, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1258, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1259, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1260, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1261, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1262, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1263, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1264, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1265, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1266, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1267, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1268, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1269, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1270, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1271, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1272, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1273, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1274, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1275, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1276, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1277, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1278, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1279, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1280, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1281, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1282, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1283, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1284, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1285, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1286, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1287, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1288, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1289, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1290, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1291, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1292, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1293, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1294, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1295, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1296, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1297, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1298, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1299, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1300, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1301, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1302, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1303, 0xff, 0xff, 0xff) },	
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1333, 0xff, 0xff, 0xff) },	
	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1401, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1402, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1403, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1404, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1405, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1406, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1407, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1408, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1409, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1410, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1411, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1412, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1413, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1414, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1415, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1416, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1417, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1418, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1419, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1420, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1421, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1422, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1423, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1424, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1425, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1426, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1427, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1428, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1429, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1430, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1431, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1432, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1433, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1434, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1435, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1436, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1437, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1438, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1439, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1440, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1441, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1442, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1443, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1444, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1445, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1446, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1447, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1448, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1449, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1450, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1451, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1452, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1453, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1454, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1455, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1456, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1457, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1458, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1459, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1460, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1461, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1462, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1463, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1464, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1465, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1466, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1467, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1468, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1469, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1470, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1471, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1472, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1473, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1474, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1475, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1476, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1477, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1478, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1479, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1480, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1481, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1482, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1483, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1484, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1485, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1486, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1487, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1488, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1489, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1490, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1491, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1492, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1493, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1494, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1495, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1496, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1497, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1498, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1499, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1500, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1501, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1502, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1503, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1504, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1505, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1506, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1507, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1508, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1509, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1510, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1533, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1534, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1535, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1545, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1546, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1547, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1565, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1566, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1567, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1589, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1590, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1591, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1592, 0xff, 0xff, 0xff) }, 	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1594, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1596, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1598, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1600, 0xff, 0xff, 0xff) },  		
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x2002, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x2003, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0xFFEC, 0xff, 0xff, 0xff) },
    { ZTE_USB_DEVICE_ID_MATCH_INT_CLASS_AND_SUBCLASS_INFO(0x19d2,0xff,0x86) },
    { ZTE_USB_DEVICE_ID_MATCH_INT_CLASS_AND_SUBCLASS_INFO(0x19d2,0xff,0x02) },
    { USB_DEVICE_AND_INTERFACE_INFO(TPLink_VENDOR_ID, 0x7E11, 0xff, 0xff, 0xff) },/*TPLink*/
    { USB_DEVICE_AND_INTERFACE_INFO(QUALCOMM_VENDOR_ID, 0x9001, 0xff, 0xff, 0xff) },/*QUALCOMM_VENDOR_ID*/
    { USB_DEVICE_AND_INTERFACE_INFO(QUALCOMM_VENDOR_ID, 0x9002, 0xff, 0xff, 0xff) },
	{ } /* Terminating entry */
};
MODULE_DEVICE_TABLE(usb, zte_ids);

/* The card has three separate interfaces, which the serial driver
 * recognizes separately, thus num_port=1.
 */

static struct usb_serial_driver zte_1port_device = {
	.driver = {
		.owner =	THIS_MODULE,
		.name =		"zte1",
	},
	.description       = "GSM modem (1-port)",
	.id_table          = zte_ids,
	.num_ports         = 1,
	.probe             = zte_probe,
	.open              = zte_open,
	.close             = zte_close,
	.dtr_rts	   = zte_dtr_rts,
	.write             = zte_write,
	.write_room        = zte_write_room,
	.chars_in_buffer   = zte_chars_in_buffer,
	.set_termios       = zte_set_termios,
	.tiocmget          = zte_tiocmget,
	.tiocmset          = zte_tiocmset,
	.ioctl             = zte_ioctl,
	.attach            = zte_attach,
	.release           = zte_release,
	.port_probe        = zte_port_probe,
	.port_remove	   = zte_port_remove,
	.read_int_callback = zte_instat_callback,
#ifdef CONFIG_PM
	.suspend           = zte_suspend,
	.resume            = zte_resume,
#endif
};

static struct usb_serial_driver * const serial_drivers[] = {
	&zte_1port_device, NULL
};

struct zte_private {
	u8 bInterfaceNumber;
};

module_usb_serial_driver(serial_drivers, zte_ids);

static bool is_blacklisted(const u8 ifnum, enum zte_blacklist_reason reason,
			   const struct zte_blacklist_info *blacklist)
{
	unsigned long num;
	const unsigned long *intf_list;

	if (blacklist) {
		if (reason == zte_BLACKLIST_SENDSETUP)
			intf_list = &blacklist->sendsetup;
		else if (reason == zte_BLACKLIST_RESERVED_IF)
			intf_list = &blacklist->reserved;
		else {
			BUG_ON(reason);
			return false;
		}

		for_each_set_bit(num, intf_list, MAX_BL_NUM + 1) {
			if (num == ifnum)
				return true;
		}
	}
	return false;
}

static int zte_probe(struct usb_serial *serial,
			const struct usb_device_id *id)
{
	struct usb_interface_descriptor *iface_desc =
				&serial->interface->cur_altsetting->desc;
	//struct usb_device_descriptor *dev_desc = &serial->dev->descriptor;

	/* Never bind to the CD-Rom emulation interface	*/
	if (iface_desc->bInterfaceClass == 0x08)
		return -ENODEV;

	/*
	 * Don't bind reserved interfaces (like network ones) which often have
	 * the same class/subclass/protocol as the serial interfaces.  Look at
	 * the Windows driver .INF files for reserved interface numbers.
	 */
	if (is_blacklisted(
		iface_desc->bInterfaceNumber,
		zte_BLACKLIST_RESERVED_IF,
		(const struct zte_blacklist_info *) id->driver_info))
		return -ENODEV;
	/*
	 * Don't bind network interface on Samsung GT-B3730, it is handled by
	 * a separate module.
	 
	if (dev_desc->idVendor == cpu_to_le16(SAMSUNG_VENDOR_ID) &&
	    dev_desc->idProduct == cpu_to_le16(SAMSUNG_PRODUCT_GT_B3730) &&
	    iface_desc->bInterfaceClass != USB_CLASS_CDC_DATA)
		return -ENODEV;
	*/
	
	/* Store device id so we can use it during attach. */
	usb_set_serial_data(serial, (void *)id);

	return 0;
}

static int zte_attach(struct usb_serial *serial)
{
	struct usb_interface_descriptor *iface_desc;
	const struct usb_device_id *id;
	struct zte_intf_private *data;
	struct zte_private *priv;

	data = kzalloc(sizeof(struct zte_intf_private), GFP_KERNEL);
	if (!data)
		return -ENOMEM;

	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
	if (!priv) {
		kfree(data);
		return -ENOMEM;
	}

	/* Retrieve device id stored at probe. */
	id = usb_get_serial_data(serial);
	iface_desc = &serial->interface->cur_altsetting->desc;

	priv->bInterfaceNumber = iface_desc->bInterfaceNumber;
	data->private = priv;

	if (!is_blacklisted(iface_desc->bInterfaceNumber,
			zte_BLACKLIST_SENDSETUP,
			(struct zte_blacklist_info *)id->driver_info)) {
		data->send_setup = zte_send_setup;
	}
	spin_lock_init(&data->susp_lock);

	usb_set_serial_data(serial, data);

	return 0;
}

static void zte_release(struct usb_serial *serial)
{
	struct zte_intf_private *intfdata = usb_get_serial_data(serial);
	struct zte_private *priv = intfdata->private;

	kfree(priv);
	kfree(intfdata);
}

static void zte_instat_callback(struct urb *urb)
{
	int err;
	int status = urb->status;
	struct usb_serial_port *port = urb->context;
	struct device *dev = &port->dev;
	struct zte_port_private *portdata =
					usb_get_serial_port_data(port);

	dev_dbg(dev, "%s: urb %p port %p has data %p\n", __func__, urb, port, portdata);

	if (status == 0) {
		struct usb_ctrlrequest *req_pkt =
				(struct usb_ctrlrequest *)urb->transfer_buffer;

		if (!req_pkt) {
			dev_dbg(dev, "%s: NULL req_pkt\n", __func__);
			return;
		}
		if ((req_pkt->bRequestType == 0xA1) &&
				(req_pkt->bRequest == 0x20)) {
			int old_dcd_state;
			unsigned char signals = *((unsigned char *)
					urb->transfer_buffer +
					sizeof(struct usb_ctrlrequest));

			dev_dbg(dev, "%s: signal x%x\n", __func__, signals);

			old_dcd_state = portdata->dcd_state;
			portdata->cts_state = 1;
			portdata->dcd_state = ((signals & 0x01) ? 1 : 0);
			portdata->dsr_state = ((signals & 0x02) ? 1 : 0);
			portdata->ri_state = ((signals & 0x08) ? 1 : 0);

			if (old_dcd_state && !portdata->dcd_state) {
				struct tty_struct *tty =
						tty_port_tty_get(&port->port);
				if (tty && !C_CLOCAL(tty))
					tty_hangup(tty);
				tty_kref_put(tty);
			}
		} else {
			dev_dbg(dev, "%s: type %x req %x\n", __func__,
				req_pkt->bRequestType, req_pkt->bRequest);
		}
	} else
		dev_err(dev, "%s: error %d\n", __func__, status);

	/* Resubmit urb so we continue receiving IRQ data */
	if (status != -ESHUTDOWN && status != -ENOENT) {
		err = usb_submit_urb(urb, GFP_ATOMIC);
		if (err)
			dev_dbg(dev, "%s: resubmit intr urb failed. (%d)\n",
				__func__, err);
	}
}

/** send RTS/DTR state to the port.
 *
 * This is exactly the same as SET_CONTROL_LINE_STATE from the PSTN
 * CDC.
*/
static int zte_send_setup(struct usb_serial_port *port)
{
	struct usb_serial *serial = port->serial;
	struct zte_intf_private *intfdata = usb_get_serial_data(serial);
	struct zte_private *priv = intfdata->private;
	struct zte_port_private *portdata;
	int val = 0;

	portdata = usb_get_serial_port_data(port);

	if (portdata->dtr_state)
		val |= 0x01;
	if (portdata->rts_state)
		val |= 0x02;

	return usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),
				0x22, 0x21, val, priv->bInterfaceNumber, NULL,
				0, USB_CTRL_SET_TIMEOUT);
}

void zte_dtr_rts(struct usb_serial_port *port, int on)
{
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata;

	intfdata = port->serial->private;

	if (!intfdata->send_setup)
		return;

	portdata = usb_get_serial_port_data(port);
	/* FIXME: locking */
	portdata->rts_state = on;
	portdata->dtr_state = on;

	intfdata->send_setup(port);
}


void zte_set_termios(struct tty_struct *tty,
			  struct usb_serial_port *port,
			  struct ktermios *old_termios)
{
	struct zte_intf_private *intfdata = port->serial->private;

	/* Doesn't support option setting */
	tty_termios_copy_hw(&tty->termios, old_termios);

	if (intfdata->send_setup)
		intfdata->send_setup(port);
}
EXPORT_SYMBOL(zte_set_termios);

int zte_tiocmget(struct tty_struct *tty)
{
	struct usb_serial_port *port = tty->driver_data;
	unsigned int value;
	struct zte_port_private *portdata;

	portdata = usb_get_serial_port_data(port);

	value = ((portdata->rts_state) ? TIOCM_RTS : 0) |
	    ((portdata->dtr_state) ? TIOCM_DTR : 0) |
	    ((portdata->cts_state) ? TIOCM_CTS : 0) |
	    ((portdata->dsr_state) ? TIOCM_DSR : 0) |
	    ((portdata->dcd_state) ? TIOCM_CAR : 0) |
	    ((portdata->ri_state) ? TIOCM_RNG : 0);

	return value;
}

int zte_tiocmset(struct tty_struct *tty,
		      unsigned int set, unsigned int clear)
{
	struct usb_serial_port *port = tty->driver_data;
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata;

	portdata = usb_get_serial_port_data(port);
	intfdata = port->serial->private;

	if (!intfdata->send_setup)
		return -EINVAL;

	/* FIXME: what locks portdata fields ? */
	if (set & TIOCM_RTS)
		portdata->rts_state = 1;
	if (set & TIOCM_DTR)
		portdata->dtr_state = 1;

	if (clear & TIOCM_RTS)
		portdata->rts_state = 0;
	if (clear & TIOCM_DTR)
		portdata->dtr_state = 0;
	return intfdata->send_setup(port);
}

static int get_serial_info(struct usb_serial_port *port,
			   struct serial_struct __user *retinfo)
{
	struct serial_struct tmp;

	if (!retinfo)
		return -EFAULT;

	memset(&tmp, 0, sizeof(tmp));
	tmp.line            = port->serial->minor;
	tmp.port            = port->number;
	tmp.baud_base       = tty_get_baud_rate(port->port.tty);
	tmp.close_delay	    = port->port.close_delay / 10;
	tmp.closing_wait    = port->port.closing_wait == ASYNC_CLOSING_WAIT_NONE ?
				 ASYNC_CLOSING_WAIT_NONE :
				 port->port.closing_wait / 10;

	if (copy_to_user(retinfo, &tmp, sizeof(*retinfo)))
		return -EFAULT;
	return 0;
}

static int set_serial_info(struct usb_serial_port *port,
			   struct serial_struct __user *newinfo)
{
	struct serial_struct new_serial;
	unsigned int closing_wait, close_delay;
	int retval = 0;

	if (copy_from_user(&new_serial, newinfo, sizeof(new_serial)))
		return -EFAULT;

	close_delay = new_serial.close_delay * 10;
	closing_wait = new_serial.closing_wait == ASYNC_CLOSING_WAIT_NONE ?
			ASYNC_CLOSING_WAIT_NONE : new_serial.closing_wait * 10;

	mutex_lock(&port->port.mutex);

	if (!capable(CAP_SYS_ADMIN)) {
		if ((close_delay != port->port.close_delay) ||
		    (closing_wait != port->port.closing_wait))
			retval = -EPERM;
		else
			retval = -EOPNOTSUPP;
	} else {
		port->port.close_delay  = close_delay;
		port->port.closing_wait = closing_wait;
	}

	mutex_unlock(&port->port.mutex);
	return retval;
}

int zte_ioctl(struct tty_struct *tty,
		   unsigned int cmd, unsigned long arg)
{
	struct usb_serial_port *port = tty->driver_data;

	dev_dbg(&port->dev, "%s cmd 0x%04x\n", __func__, cmd);

	switch (cmd) {
	case TIOCGSERIAL:
		return get_serial_info(port,
				       (struct serial_struct __user *) arg);
	case TIOCSSERIAL:
		return set_serial_info(port,
				       (struct serial_struct __user *) arg);
	default:
		break;
	}

	dev_dbg(&port->dev, "%s arg not supported\n", __func__);

	return -ENOIOCTLCMD;
}


/* Write */
int zte_write(struct tty_struct *tty, struct usb_serial_port *port,
		   const unsigned char *buf, int count)
{
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata;
	int i;
	int left, todo;
	struct urb *this_urb = NULL;	/* spurious */
	int err;
	unsigned long flags;

	portdata = usb_get_serial_port_data(port);
	intfdata = port->serial->private;

	dev_dbg(&port->dev, "%s: write (%d chars)\n", __func__, count);

	i = 0;
	left = count;
	for (i = 0; left > 0 && i < N_OUT_URB; i++) {
		todo = left;
		if (todo > OUT_BUFLEN)
			todo = OUT_BUFLEN;

		this_urb = portdata->out_urbs[i];
		if (test_and_set_bit(i, &portdata->out_busy)) {
			if (time_before(jiffies,
					portdata->tx_start_time[i] + 10 * HZ))
				continue;
			usb_unlink_urb(this_urb);
			continue;
		}
		dev_dbg(&port->dev, "%s: endpoint %d buf %d\n", __func__,
			usb_pipeendpoint(this_urb->pipe), i);

		err = usb_autopm_get_interface_async(port->serial->interface);
		if (err < 0)
			break;

		/* send the data */
		memcpy(this_urb->transfer_buffer, buf, todo);
		this_urb->transfer_buffer_length = todo;

		spin_lock_irqsave(&intfdata->susp_lock, flags);
		if (intfdata->suspended) {
			usb_anchor_urb(this_urb, &portdata->delayed);
			spin_unlock_irqrestore(&intfdata->susp_lock, flags);
		} else {
			intfdata->in_flight++;
			spin_unlock_irqrestore(&intfdata->susp_lock, flags);
			err = usb_submit_urb(this_urb, GFP_ATOMIC);
			if (err) {
				dev_dbg(&port->dev,
					"usb_submit_urb %p (write bulk) failed (%d)\n",
					this_urb, err);
				clear_bit(i, &portdata->out_busy);
				spin_lock_irqsave(&intfdata->susp_lock, flags);
				intfdata->in_flight--;
				spin_unlock_irqrestore(&intfdata->susp_lock,
						       flags);
				usb_autopm_put_interface_async(port->serial->interface);
				break;
			}
		}

		portdata->tx_start_time[i] = jiffies;
		buf += todo;
		left -= todo;
	}

	count -= left;
	dev_dbg(&port->dev, "%s: wrote (did %d)\n", __func__, count);
	return count;
}


static void zte_indat_callback(struct urb *urb)
{
	int err;
	int endpoint;
	struct usb_serial_port *port;
	struct tty_struct *tty;
	struct device *dev;
	unsigned char *data = urb->transfer_buffer;
	int status = urb->status;

	endpoint = usb_pipeendpoint(urb->pipe);
	port = urb->context;
	dev = &port->dev;

	if (status) {
		dev_dbg(dev, "%s: nonzero status: %d on endpoint %02x.\n",
			__func__, status, endpoint);
	} else {
		tty = tty_port_tty_get(&port->port);
		if (tty) {
			if (urb->actual_length) {
				tty_insert_flip_string(tty, data,
						urb->actual_length);
				tty_flip_buffer_push(tty);
			} else
				dev_dbg(dev, "%s: empty read urb received\n", __func__);
			tty_kref_put(tty);
		}

		/* Resubmit urb so we continue receiving */
		err = usb_submit_urb(urb, GFP_ATOMIC);
		if (err) {
			if (err != -EPERM) {
				dev_err(dev, "%s: resubmit read urb failed. (%d)\n", __func__, err);
				/* busy also in error unless we are killed */
				usb_mark_last_busy(port->serial->dev);
			}
		} else {
			usb_mark_last_busy(port->serial->dev);
		}
	}
}

static void zte_outdat_callback(struct urb *urb)
{
	struct usb_serial_port *port;
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata;
	int i;

	port = urb->context;
	intfdata = port->serial->private;

	usb_serial_port_softint(port);
	usb_autopm_put_interface_async(port->serial->interface);
	portdata = usb_get_serial_port_data(port);
	spin_lock(&intfdata->susp_lock);
	intfdata->in_flight--;
	spin_unlock(&intfdata->susp_lock);

	for (i = 0; i < N_OUT_URB; ++i) {
		if (portdata->out_urbs[i] == urb) {
			smp_mb__before_clear_bit();
			clear_bit(i, &portdata->out_busy);
			break;
		}
	}
}

int zte_write_room(struct tty_struct *tty)
{
	struct usb_serial_port *port = tty->driver_data;
	struct zte_port_private *portdata;
	int i;
	int data_len = 0;
	struct urb *this_urb;

	portdata = usb_get_serial_port_data(port);

	for (i = 0; i < N_OUT_URB; i++) {
		this_urb = portdata->out_urbs[i];
		if (this_urb && !test_bit(i, &portdata->out_busy))
			data_len += OUT_BUFLEN;
	}

	dev_dbg(&port->dev, "%s: %d\n", __func__, data_len);
	return data_len;
}


int zte_chars_in_buffer(struct tty_struct *tty)
{
	struct usb_serial_port *port = tty->driver_data;
	struct zte_port_private *portdata;
	int i;
	int data_len = 0;
	struct urb *this_urb;

	portdata = usb_get_serial_port_data(port);

	for (i = 0; i < N_OUT_URB; i++) {
		this_urb = portdata->out_urbs[i];
		/* FIXME: This locking is insufficient as this_urb may
		   go unused during the test */
		if (this_urb && test_bit(i, &portdata->out_busy))
			data_len += this_urb->transfer_buffer_length;
	}
	dev_dbg(&port->dev, "%s: %d\n", __func__, data_len);
	return data_len;
}


int zte_open(struct tty_struct *tty, struct usb_serial_port *port)
{
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata;
	struct usb_serial *serial = port->serial;
	int i, err;
	struct urb *urb;

	portdata = usb_get_serial_port_data(port);
	intfdata = serial->private;

	/* Start reading from the IN endpoint */
	for (i = 0; i < N_IN_URB; i++) {
		urb = portdata->in_urbs[i];
		if (!urb)
			continue;
		err = usb_submit_urb(urb, GFP_KERNEL);
		if (err) {
			dev_dbg(&port->dev, "%s: submit urb %d failed (%d) %d\n",
				__func__, i, err, urb->transfer_buffer_length);
		}
	}

	if (intfdata->send_setup)
		intfdata->send_setup(port);

	serial->interface->needs_remote_wakeup = 1;
	spin_lock_irq(&intfdata->susp_lock);
	portdata->opened = 1;
	spin_unlock_irq(&intfdata->susp_lock);
	/* this balances a get in the generic USB serial code */
	usb_autopm_put_interface(serial->interface);

	return 0;
}


void zte_close(struct usb_serial_port *port)
{
	int i;
	struct usb_serial *serial = port->serial;
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata = port->serial->private;

	portdata = usb_get_serial_port_data(port);

	if (serial->dev) {
		/* Stop reading/writing urbs */
		spin_lock_irq(&intfdata->susp_lock);
		portdata->opened = 0;
		spin_unlock_irq(&intfdata->susp_lock);

		for (i = 0; i < N_IN_URB; i++)
			usb_kill_urb(portdata->in_urbs[i]);
		for (i = 0; i < N_OUT_URB; i++)
			usb_kill_urb(portdata->out_urbs[i]);
		/* balancing - important as an error cannot be handled*/
		usb_autopm_get_interface_no_resume(serial->interface);
		serial->interface->needs_remote_wakeup = 0;
	}
}
EXPORT_SYMBOL(zte_close);

/* Helper functions used by zte_setup_urbs */
static struct urb *zte_setup_urb(struct usb_serial_port *port,
				      int endpoint,
				      int dir, void *ctx, char *buf, int len,
				      void (*callback) (struct urb *))
{
	struct usb_serial *serial = port->serial;
	struct urb *urb;

	urb = usb_alloc_urb(0, GFP_KERNEL);	/* No ISO */
	if (urb == NULL) {
		dev_dbg(&serial->interface->dev,
			"%s: alloc for endpoint %d failed.\n", __func__,
			endpoint);
		return NULL;
	}

	/* Fill URB using supplied data. */
	usb_fill_bulk_urb(urb, serial->dev,
			  usb_sndbulkpipe(serial->dev, endpoint) | dir,
			  buf, len, callback, ctx);

	return urb;
}

int zte_port_probe(struct usb_serial_port *port)
{
	struct zte_port_private *portdata;
	struct urb *urb;
	u8 *buffer;
	int err;
	int i;

	portdata = kzalloc(sizeof(*portdata), GFP_KERNEL);
	if (!portdata)
		return -ENOMEM;

	init_usb_anchor(&portdata->delayed);

	for (i = 0; i < N_IN_URB; i++) {
		if (!port->bulk_in_size)
			break;

		buffer = (u8 *)__get_free_page(GFP_KERNEL);
		if (!buffer)
			goto bail_out_error;
		portdata->in_buffer[i] = buffer;

		urb = zte_setup_urb(port, port->bulk_in_endpointAddress,
						USB_DIR_IN, port,
						buffer, IN_BUFLEN,
						zte_indat_callback);
		portdata->in_urbs[i] = urb;
	}

	for (i = 0; i < N_OUT_URB; i++) {
		if (!port->bulk_out_size)
			break;

		buffer = kmalloc(OUT_BUFLEN, GFP_KERNEL);
		if (!buffer)
			goto bail_out_error2;
		portdata->out_buffer[i] = buffer;

		urb = zte_setup_urb(port, port->bulk_out_endpointAddress,
						USB_DIR_OUT, port,
						buffer, OUT_BUFLEN,
						zte_outdat_callback);
		portdata->out_urbs[i] = urb;
	}

	usb_set_serial_port_data(port, portdata);

	if (port->interrupt_in_urb) {
		err = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);
		if (err)
			dev_dbg(&port->dev, "%s: submit irq_in urb failed %d\n",
				__func__, err);
	}

	return 0;

bail_out_error2:
	for (i = 0; i < N_OUT_URB; i++) {
		usb_free_urb(portdata->out_urbs[i]);
		kfree(portdata->out_buffer[i]);
	}
bail_out_error:
	for (i = 0; i < N_IN_URB; i++) {
		usb_free_urb(portdata->in_urbs[i]);
		free_page((unsigned long)portdata->in_buffer[i]);
	}
	kfree(portdata);

	return -ENOMEM;
}


int zte_port_remove(struct usb_serial_port *port)
{
	int i;
	struct zte_port_private *portdata;

	portdata = usb_get_serial_port_data(port);
	usb_set_serial_port_data(port, NULL);

	/* Stop reading/writing urbs and free them */
	for (i = 0; i < N_IN_URB; i++) {
		usb_kill_urb(portdata->in_urbs[i]);
		usb_free_urb(portdata->in_urbs[i]);
		free_page((unsigned long)portdata->in_buffer[i]);
	}
	for (i = 0; i < N_OUT_URB; i++) {
		usb_kill_urb(portdata->out_urbs[i]);
		usb_free_urb(portdata->out_urbs[i]);
		kfree(portdata->out_buffer[i]);
	}

	/* Now free port private data */
	kfree(portdata);
	return 0;
}


#ifdef CONFIG_PM
static void stop_read_write_urbs(struct usb_serial *serial)
{
	int i, j;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;

	/* Stop reading/writing urbs */
	for (i = 0; i < serial->num_ports; ++i) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);
		if (!portdata)
			continue;
		for (j = 0; j < N_IN_URB; j++)
			usb_kill_urb(portdata->in_urbs[j]);
		for (j = 0; j < N_OUT_URB; j++)
			usb_kill_urb(portdata->out_urbs[j]);
	}
}

int zte_suspend(struct usb_serial *serial, pm_message_t message)
{
	struct zte_intf_private *intfdata = serial->private;
	int b;

	if (PMSG_IS_AUTO(message)) {
		spin_lock_irq(&intfdata->susp_lock);
		b = intfdata->in_flight;
		spin_unlock_irq(&intfdata->susp_lock);

		if (b)
			return -EBUSY;
	}

	spin_lock_irq(&intfdata->susp_lock);
	intfdata->suspended = 1;
	spin_unlock_irq(&intfdata->susp_lock);
	stop_read_write_urbs(serial);

	return 0;
}

static void unbusy_queued_urb(struct urb *urb, struct zte_port_private *portdata)
{
	int i;

	for (i = 0; i < N_OUT_URB; i++) {
		if (urb == portdata->out_urbs[i]) {
			clear_bit(i, &portdata->out_busy);
			break;
		}
	}
}

static void play_delayed(struct usb_serial_port *port)
{
	struct zte_intf_private *data;
	struct zte_port_private *portdata;
	struct urb *urb;
	int err;

	portdata = usb_get_serial_port_data(port);
	data = port->serial->private;
	while ((urb = usb_get_from_anchor(&portdata->delayed))) {
		err = usb_submit_urb(urb, GFP_ATOMIC);
		if (!err) {
			data->in_flight++;
		} else {
			/* we have to throw away the rest */
			do {
				unbusy_queued_urb(urb, portdata);
				usb_autopm_put_interface_no_suspend(port->serial->interface);
			} while ((urb = usb_get_from_anchor(&portdata->delayed)));
			break;
		}
	}
}

int zte_resume(struct usb_serial *serial)
{
	int i, j;
	struct usb_serial_port *port;
	struct zte_intf_private *intfdata = serial->private;
	struct zte_port_private *portdata;
	struct urb *urb;
	int err = 0;

	/* get the interrupt URBs resubmitted unconditionally */
	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		if (!port->interrupt_in_urb) {
			dev_dbg(&port->dev, "%s: No interrupt URB for port\n", __func__);
			continue;
		}
		err = usb_submit_urb(port->interrupt_in_urb, GFP_NOIO);
		dev_dbg(&port->dev, "Submitted interrupt URB for port (result %d)\n", err);
		if (err < 0) {
			dev_err(&port->dev, "%s: Error %d for interrupt URB\n",
				__func__, err);
			goto err_out;
		}
	}

	for (i = 0; i < serial->num_ports; i++) {
		/* walk all ports */
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);

		/* skip closed ports */
		spin_lock_irq(&intfdata->susp_lock);
		if (!portdata || !portdata->opened) {
			spin_unlock_irq(&intfdata->susp_lock);
			continue;
		}

		for (j = 0; j < N_IN_URB; j++) {
			urb = portdata->in_urbs[j];
			err = usb_submit_urb(urb, GFP_ATOMIC);
			if (err < 0) {
				dev_err(&port->dev, "%s: Error %d for bulk URB %d\n",
					__func__, err, i);
				spin_unlock_irq(&intfdata->susp_lock);
				goto err_out;
			}
		}
		play_delayed(port);
		spin_unlock_irq(&intfdata->susp_lock);
	}
	spin_lock_irq(&intfdata->susp_lock);
	intfdata->suspended = 0;
	spin_unlock_irq(&intfdata->susp_lock);
err_out:
	return err;
}
#endif
MODULE_AUTHOR(DRIVER_AUTHOR);
MODULE_DESCRIPTION(DRIVER_DESC);
MODULE_LICENSE("GPL");

#elif LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)//use  3.9 .11 source code
#include <linux/kernel.h>
#include <linux/jiffies.h>
#include <linux/errno.h>
#include <linux/tty.h>
#include <linux/tty_flip.h>
#include <linux/slab.h>
#include <linux/module.h>
#include <linux/bitops.h>
#include <linux/usb.h>
#include <linux/usb/serial.h>
#include <linux/serial.h>
/* Function prototypes */
static int  zte_probe(struct usb_serial *serial,
			const struct usb_device_id *id);
static int zte_attach(struct usb_serial *serial);
static void zte_release(struct usb_serial *serial);
static int zte_send_setup(struct usb_serial_port *port);
static void zte_instat_callback(struct urb *urb);
static void zte_dtr_rts(struct usb_serial_port *port, int on);
static int zte_open(struct tty_struct *tty, struct usb_serial_port *port);
static void zte_close(struct usb_serial_port *port);
static int zte_port_probe(struct usb_serial_port *port);
static int zte_port_remove(struct usb_serial_port *port);
static int zte_write_room(struct tty_struct *tty);
static void zte_set_termios(struct tty_struct *tty,
				 struct usb_serial_port *port,
				 struct ktermios *old);
static int zte_tiocmget(struct tty_struct *tty);
static int zte_tiocmset(struct tty_struct *tty,
			     unsigned int set, unsigned int clear);
static int zte_ioctl(struct tty_struct *tty,
			  unsigned int cmd, unsigned long arg);

static int zte_write(struct tty_struct *tty, struct usb_serial_port *port,
			  const unsigned char *buf, int count);
static int zte_chars_in_buffer(struct tty_struct *tty);
#ifdef CONFIG_PM
static int zte_suspend(struct usb_serial *serial, pm_message_t message);
static int zte_resume(struct usb_serial *serial);
#endif

/* Vendor and product IDs */
/* ZTE PRODUCTS */
#define zte_VENDOR_ID				0x19d2

/* some devices interfaces need special handling due to a number of reasons */
enum zte_blacklist_reason {
		zte_BLACKLIST_NONE = 0,
		zte_BLACKLIST_SENDSETUP = 1,
		zte_BLACKLIST_RESERVED_IF = 2
};

#define MAX_BL_NUM  8
struct zte_blacklist_info {
	/* bitfield of interface numbers for zte_BLACKLIST_SENDSETUP */
	const unsigned long sendsetup;
	/* bitfield of interface numbers for zte_BLACKLIST_RESERVED_IF */
	const unsigned long reserved;
};

static const struct zte_blacklist_info four_g_w14_blacklist = {
	.sendsetup = BIT(0) | BIT(1),
};

static const struct zte_blacklist_info alcatel_x200_blacklist = {
	.sendsetup = BIT(0) | BIT(1),
	.reserved = BIT(4),
};

static const struct zte_blacklist_info zte_0037_blacklist = {
	.sendsetup = BIT(0) | BIT(1),
};

static const struct zte_blacklist_info zte_k3765_z_blacklist = {
	.sendsetup = BIT(0) | BIT(1) | BIT(2),
	.reserved = BIT(4),
};

static const struct zte_blacklist_info zte_mc2718_z_blacklist = {
	.sendsetup = BIT(1) | BIT(2) | BIT(3) | BIT(4),
};

static const struct zte_blacklist_info huawei_cdc12_blacklist = {
	.reserved = BIT(1) | BIT(2),
};

static const struct zte_blacklist_info net_intf1_blacklist = {
	.reserved = BIT(1),
};

static const struct zte_blacklist_info net_intf2_blacklist = {
	.reserved = BIT(2),
};

static const struct zte_blacklist_info net_intf3_blacklist = {
	.reserved = BIT(3),
};

static const struct zte_blacklist_info net_intf4_blacklist = {
	.reserved = BIT(4),
};

static const struct zte_blacklist_info net_intf5_blacklist = {
	.reserved = BIT(5),
};

static const struct zte_blacklist_info net_intf6_blacklist = {
	.reserved = BIT(6),
};

static const struct zte_blacklist_info zte_mf626_blacklist = {
	.sendsetup = BIT(0) | BIT(1),
	.reserved = BIT(4),
};

static const struct zte_blacklist_info zte_1255_blacklist = {
	.reserved = BIT(3) | BIT(4),
};

static const struct zte_blacklist_info telit_le920_blacklist = {
	.sendsetup = BIT(0),
	.reserved = BIT(1) | BIT(5),
};

static const struct usb_device_id zte_ids[] = {
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0001, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0002, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0003, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0004, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0005, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0006, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0007, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0008, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0009, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0010, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0011, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0012, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0013, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0014, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0015, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0016, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0017, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0018, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0019, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0020, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0021, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0022, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0023, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0024, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0025, 0xff, 0xff, 0xff) },
    //   { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0026, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0027, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0028, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0029, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0030, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0031, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0032, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0033, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0034, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0035, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0036, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0037, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0038, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0039, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0040, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0041, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0042, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0043, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0044, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0045, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0046, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0047, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0048, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0049, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0050, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0051, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0052, 0xff, 0xff, 0xff) },
    //   { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0053, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0054, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0055, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0056, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0057, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0058, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0059, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0060, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0061, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0062, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0063, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0064, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0065, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0066, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0067, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0068, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0069, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0070, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0071, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0072, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0073, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0074, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0075, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0076, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0077, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0078, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0079, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0080, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0081, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0082, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0083, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0084, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0085, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0086, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0087, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0088, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0089, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0090, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0091, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0092, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0093, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0094, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0095, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0096, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0097, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0098, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0099, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0104, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0105, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0106, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0108, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0117, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0118, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0121, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0122, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0123, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0124, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0125, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0126, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0128, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0130, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0133, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0135, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0136, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0137, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0139, 0xff, 0xff, 0xff) }, 	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0141, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0144, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0145, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0147, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0148, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0151, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0152, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0153, 0xff, 0xff, 0xff) },
    //{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0154, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0155, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0156, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0157, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0158, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0159, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0160, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0161, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0162, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0164, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0165, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0167, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0168, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0170, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0176, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0178, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0189, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0191, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0196, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0197, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0199, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0200, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0201, 0xff, 0xff, 0xff) },		
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0254, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0257, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0265, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0284, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0317, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0330, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0395, 0xff, 0xff, 0xff) },      
 	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0414, 0xff, 0xff, 0xff) },   
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0417, 0xff, 0xff, 0xff) },

    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1008, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1010, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1012, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1018, 0xff, 0xff, 0xff) },		
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1057, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1058, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1059, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1060, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1061, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1062, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1063, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1064, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1065, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1066, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1067, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1068, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1069, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1070, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1071, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1072, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1073, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1074, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1075, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1076, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1077, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1078, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1079, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1080, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1081, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1082, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1083, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1084, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1085, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1086, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1087, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1088, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1089, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1090, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1091, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1092, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1093, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1094, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1095, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1096, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1097, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1098, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1099, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1100, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1101, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1102, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1103, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1104, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1105, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1106, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1107, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1108, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1109, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1110, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1111, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1112, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1113, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1114, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1115, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1116, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1117, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1118, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1119, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1120, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1121, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1122, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1123, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1124, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1125, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1126, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1127, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1128, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1129, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1130, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1131, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1132, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1133, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1134, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1135, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1136, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1137, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1138, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1139, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1140, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1141, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1142, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1143, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1144, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1145, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1146, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1147, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1148, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1149, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1150, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1151, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1152, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1153, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1154, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1155, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1156, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1157, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1158, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1159, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1160, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1161, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1162, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1163, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1164, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1165, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1166, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1167, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1168, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1169, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1170, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1244, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1245, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1246, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1247, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1248, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1249, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1250, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1251, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1252, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1253, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1254, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1255, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1256, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1257, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1258, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1259, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1260, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1261, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1262, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1263, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1264, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1265, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1266, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1267, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1268, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1269, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1270, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1271, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1272, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1273, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1274, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1275, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1276, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1277, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1278, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1279, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1280, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1281, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1282, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1283, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1284, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1285, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1286, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1287, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1288, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1289, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1290, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1291, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1292, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1293, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1294, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1295, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1296, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1297, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1298, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1299, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1300, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1301, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1302, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1303, 0xff, 0xff, 0xff) },	
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1333, 0xff, 0xff, 0xff) },	
	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1401, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1402, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1403, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1404, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1405, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1406, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1407, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1408, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1409, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1410, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1411, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1412, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1413, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1414, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1415, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1416, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1417, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1418, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1419, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1420, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1421, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1422, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1423, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1424, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1425, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1426, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1427, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1428, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1429, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1430, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1431, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1432, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1433, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1434, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1435, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1436, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1437, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1438, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1439, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1440, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1441, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1442, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1443, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1444, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1445, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1446, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1447, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1448, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1449, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1450, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1451, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1452, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1453, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1454, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1455, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1456, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1457, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1458, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1459, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1460, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1461, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1462, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1463, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1464, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1465, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1466, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1467, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1468, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1469, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1470, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1471, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1472, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1473, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1474, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1475, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1476, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1477, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1478, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1479, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1480, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1481, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1482, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1483, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1484, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1485, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1486, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1487, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1488, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1489, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1490, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1491, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1492, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1493, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1494, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1495, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1496, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1497, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1498, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1499, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1500, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1501, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1502, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1503, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1504, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1505, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1506, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1507, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1508, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1509, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1510, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1533, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1534, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1535, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1545, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1546, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1547, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1565, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1566, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1567, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1589, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1590, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1591, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1592, 0xff, 0xff, 0xff) }, 	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1594, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1596, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1598, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1600, 0xff, 0xff, 0xff) },  		
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x2002, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x2003, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0xFFEC, 0xff, 0xff, 0xff) },
    { ZTE_USB_DEVICE_ID_MATCH_INT_CLASS_AND_SUBCLASS_INFO(0x19d2,0xff,0x86) },
    { ZTE_USB_DEVICE_ID_MATCH_INT_CLASS_AND_SUBCLASS_INFO(0x19d2,0xff,0x02) },
    { USB_DEVICE_AND_INTERFACE_INFO(TPLink_VENDOR_ID, 0x7E11, 0xff, 0xff, 0xff) },/*TPLink*/
    { USB_DEVICE_AND_INTERFACE_INFO(QUALCOMM_VENDOR_ID, 0x9001, 0xff, 0xff, 0xff) },/*QUALCOMM_VENDOR_ID*/
    { USB_DEVICE_AND_INTERFACE_INFO(QUALCOMM_VENDOR_ID, 0x9002, 0xff, 0xff, 0xff) },
	{ } /* Terminating entry */
};
MODULE_DEVICE_TABLE(usb, zte_ids);

/* The card has three separate interfaces, which the serial driver
 * recognizes separately, thus num_port=1.
 */

static struct usb_serial_driver zte_1port_device = {
	.driver = {
		.owner =	THIS_MODULE,
		.name =		"zte1",
	},
	.description       = "GSM modem (1-port)",
	.id_table          = zte_ids,
	.num_ports         = 1,
	.probe             = zte_probe,
	.open              = zte_open,
	.close             = zte_close,
	.dtr_rts	   = zte_dtr_rts,
	.write             = zte_write,
	.write_room        = zte_write_room,
	.chars_in_buffer   = zte_chars_in_buffer,
	.set_termios       = zte_set_termios,
	.tiocmget          = zte_tiocmget,
	.tiocmset          = zte_tiocmset,
	.ioctl             = zte_ioctl,
	.attach            = zte_attach,
	.release           = zte_release,
	.port_probe        = zte_port_probe,
	.port_remove	   = zte_port_remove,
	.read_int_callback = zte_instat_callback,
#ifdef CONFIG_PM
	.suspend           = zte_suspend,
	.resume            = zte_resume,
#endif
};

static bool debug;
/* per port private data */

#define N_IN_URB 4
#define N_OUT_URB 4
#define IN_BUFLEN 4096
#define OUT_BUFLEN 4096

struct zte_intf_private {
	spinlock_t susp_lock;
	unsigned int suspended:1;
	int in_flight;
	int (*send_setup) (struct usb_serial_port *port);
	void *private;
};

struct zte_port_private {
	/* Input endpoints and buffer for this port */
	struct urb *in_urbs[N_IN_URB];
	u8 *in_buffer[N_IN_URB];
	/* Output endpoints and buffer for this port */
	struct urb *out_urbs[N_OUT_URB];
	u8 *out_buffer[N_OUT_URB];
	unsigned long out_busy;	/* Bit vector of URBs in use */
	int opened;
	struct usb_anchor delayed;

	/* Settings for the port */
	int rts_state;		/* Handshaking pins (outputs) */
	int dtr_state;
	int cts_state;		/* Handshaking pins (inputs) */
	int dsr_state;
	int dcd_state;
	int ri_state;

	unsigned long tx_start_time[N_OUT_URB];
};

static void zte_dtr_rts(struct usb_serial_port *port, int on)
{
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata;

	intfdata = port->serial->private;

	if (!intfdata->send_setup)
		return;

	portdata = usb_get_serial_port_data(port);
	/* FIXME: locking */
	portdata->rts_state = on;
	portdata->dtr_state = on;

	intfdata->send_setup(port);
}

static void zte_set_termios(struct tty_struct *tty,
			  struct usb_serial_port *port,
			  struct ktermios *old_termios)
{
	struct zte_intf_private *intfdata = port->serial->private;

	/* Doesn't support zte setting */
	tty_termios_copy_hw(&tty->termios, old_termios);

	if (intfdata->send_setup)
		intfdata->send_setup(port);
}

static int zte_tiocmget(struct tty_struct *tty)
{
	struct usb_serial_port *port = tty->driver_data;
	unsigned int value;
	struct zte_port_private *portdata;

	portdata = usb_get_serial_port_data(port);

	value = ((portdata->rts_state) ? TIOCM_RTS : 0) |
	    ((portdata->dtr_state) ? TIOCM_DTR : 0) |
	    ((portdata->cts_state) ? TIOCM_CTS : 0) |
	    ((portdata->dsr_state) ? TIOCM_DSR : 0) |
	    ((portdata->dcd_state) ? TIOCM_CAR : 0) |
	    ((portdata->ri_state) ? TIOCM_RNG : 0);

	return value;
}

static int zte_tiocmset(struct tty_struct *tty,
		      unsigned int set, unsigned int clear)
{
	struct usb_serial_port *port = tty->driver_data;
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata;

	portdata = usb_get_serial_port_data(port);
	intfdata = port->serial->private;

	if (!intfdata->send_setup)
		return -EINVAL;

	/* FIXME: what locks portdata fields ? */
	if (set & TIOCM_RTS)
		portdata->rts_state = 1;
	if (set & TIOCM_DTR)
		portdata->dtr_state = 1;

	if (clear & TIOCM_RTS)
		portdata->rts_state = 0;
	if (clear & TIOCM_DTR)
		portdata->dtr_state = 0;
	return intfdata->send_setup(port);
}

static int get_serial_info(struct usb_serial_port *port,
			   struct serial_struct __user *retinfo)
{
	struct serial_struct tmp;

	if (!retinfo)
		return -EFAULT;

	memset(&tmp, 0, sizeof(tmp));
	tmp.line            = port->serial->minor;
	tmp.port            = port->number;
	tmp.baud_base       = tty_get_baud_rate(port->port.tty);
	tmp.close_delay	    = port->port.close_delay / 10;
	tmp.closing_wait    = port->port.closing_wait == ASYNC_CLOSING_WAIT_NONE ?
				 ASYNC_CLOSING_WAIT_NONE :
				 port->port.closing_wait / 10;

	if (copy_to_user(retinfo, &tmp, sizeof(*retinfo)))
		return -EFAULT;
	return 0;
}

static int set_serial_info(struct usb_serial_port *port,
			   struct serial_struct __user *newinfo)
{
	struct serial_struct new_serial;
	unsigned int closing_wait, close_delay;
	int retval = 0;

	if (copy_from_user(&new_serial, newinfo, sizeof(new_serial)))
		return -EFAULT;

	close_delay = new_serial.close_delay * 10;
	closing_wait = new_serial.closing_wait == ASYNC_CLOSING_WAIT_NONE ?
			ASYNC_CLOSING_WAIT_NONE : new_serial.closing_wait * 10;

	mutex_lock(&port->port.mutex);

	if (!capable(CAP_SYS_ADMIN)) {
		if ((close_delay != port->port.close_delay) ||
		    (closing_wait != port->port.closing_wait))
			retval = -EPERM;
		else
			retval = -EOPNOTSUPP;
	} else {
		port->port.close_delay  = close_delay;
		port->port.closing_wait = closing_wait;
	}

	mutex_unlock(&port->port.mutex);
	return retval;
}

static int zte_ioctl(struct tty_struct *tty,
		   unsigned int cmd, unsigned long arg)
{
	struct usb_serial_port *port = tty->driver_data;

	dev_dbg(&port->dev, "%s cmd 0x%04x\n", __func__, cmd);

	switch (cmd) {
	case TIOCGSERIAL:
		return get_serial_info(port,
				       (struct serial_struct __user *) arg);
	case TIOCSSERIAL:
		return set_serial_info(port,
				       (struct serial_struct __user *) arg);
	default:
		break;
	}

	dev_dbg(&port->dev, "%s arg not supported\n", __func__);

	return -ENOIOCTLCMD;
}

/* Write */
static int zte_write(struct tty_struct *tty, struct usb_serial_port *port,
		   const unsigned char *buf, int count)
{
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata;
	int i;
	int left, todo;
	struct urb *this_urb = NULL;	/* spurious */
	int err;
	unsigned long flags;

	portdata = usb_get_serial_port_data(port);
	intfdata = port->serial->private;

	dev_dbg(&port->dev, "%s: write (%d chars)\n", __func__, count);

	i = 0;
	left = count;
	for (i = 0; left > 0 && i < N_OUT_URB; i++) {
		todo = left;
		if (todo > OUT_BUFLEN)
			todo = OUT_BUFLEN;

		this_urb = portdata->out_urbs[i];
		if (test_and_set_bit(i, &portdata->out_busy)) {
			if (time_before(jiffies,
					portdata->tx_start_time[i] + 10 * HZ))
				continue;
			usb_unlink_urb(this_urb);
			continue;
		}
		dev_dbg(&port->dev, "%s: endpoint %d buf %d\n", __func__,
			usb_pipeendpoint(this_urb->pipe), i);

		err = usb_autopm_get_interface_async(port->serial->interface);
		if (err < 0)
			break;

		/* send the data */
		memcpy(this_urb->transfer_buffer, buf, todo);
		this_urb->transfer_buffer_length = todo;

		spin_lock_irqsave(&intfdata->susp_lock, flags);
		if (intfdata->suspended) {
			usb_anchor_urb(this_urb, &portdata->delayed);
			spin_unlock_irqrestore(&intfdata->susp_lock, flags);
		} else {
			intfdata->in_flight++;
			spin_unlock_irqrestore(&intfdata->susp_lock, flags);
			err = usb_submit_urb(this_urb, GFP_ATOMIC);
			if (err) {
				dev_dbg(&port->dev,
					"usb_submit_urb %p (write bulk) failed (%d)\n",
					this_urb, err);
				clear_bit(i, &portdata->out_busy);
				spin_lock_irqsave(&intfdata->susp_lock, flags);
				intfdata->in_flight--;
				spin_unlock_irqrestore(&intfdata->susp_lock,
						       flags);
				usb_autopm_put_interface_async(port->serial->interface);
				break;
			}
		}

		portdata->tx_start_time[i] = jiffies;
		buf += todo;
		left -= todo;
	}

	count -= left;
	dev_dbg(&port->dev, "%s: wrote (did %d)\n", __func__, count);
	return count;
}

static void zte_indat_callback(struct urb *urb)
{
	int err;
	int endpoint;
	struct usb_serial_port *port;
	struct device *dev;
	unsigned char *data = urb->transfer_buffer;
	int status = urb->status;

	endpoint = usb_pipeendpoint(urb->pipe);
	port = urb->context;
	dev = &port->dev;

	if (status) {
		dev_dbg(dev, "%s: nonzero status: %d on endpoint %02x.\n",
			__func__, status, endpoint);
	} else {
		if (urb->actual_length) {
			tty_insert_flip_string(&port->port, data,
					urb->actual_length);
			tty_flip_buffer_push(&port->port);
		} else
			dev_dbg(dev, "%s: empty read urb received\n", __func__);

		/* Resubmit urb so we continue receiving */
		err = usb_submit_urb(urb, GFP_ATOMIC);
		if (err) {
			if (err != -EPERM) {
				dev_err(dev, "%s: resubmit read urb failed. (%d)\n", __func__, err);
				/* busy also in error unless we are killed */
				usb_mark_last_busy(port->serial->dev);
			}
		} else {
			usb_mark_last_busy(port->serial->dev);
		}
	}
}

static void zte_outdat_callback(struct urb *urb)
{
	struct usb_serial_port *port;
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata;
	int i;

	port = urb->context;
	intfdata = port->serial->private;

	usb_serial_port_softint(port);
	usb_autopm_put_interface_async(port->serial->interface);
	portdata = usb_get_serial_port_data(port);
	spin_lock(&intfdata->susp_lock);
	intfdata->in_flight--;
	spin_unlock(&intfdata->susp_lock);

	for (i = 0; i < N_OUT_URB; ++i) {
		if (portdata->out_urbs[i] == urb) {
			smp_mb__before_clear_bit();
			clear_bit(i, &portdata->out_busy);
			break;
		}
	}
}

static int zte_write_room(struct tty_struct *tty)
{
	struct usb_serial_port *port = tty->driver_data;
	struct zte_port_private *portdata;
	int i;
	int data_len = 0;
	struct urb *this_urb;

	portdata = usb_get_serial_port_data(port);

	for (i = 0; i < N_OUT_URB; i++) {
		this_urb = portdata->out_urbs[i];
		if (this_urb && !test_bit(i, &portdata->out_busy))
			data_len += OUT_BUFLEN;
	}

	dev_dbg(&port->dev, "%s: %d\n", __func__, data_len);
	return data_len;
}

static int zte_chars_in_buffer(struct tty_struct *tty)
{
	struct usb_serial_port *port = tty->driver_data;
	struct zte_port_private *portdata;
	int i;
	int data_len = 0;
	struct urb *this_urb;

	portdata = usb_get_serial_port_data(port);

	for (i = 0; i < N_OUT_URB; i++) {
		this_urb = portdata->out_urbs[i];
		/* FIXME: This locking is insufficient as this_urb may
		   go unused during the test */
		if (this_urb && test_bit(i, &portdata->out_busy))
			data_len += this_urb->transfer_buffer_length;
	}
	dev_dbg(&port->dev, "%s: %d\n", __func__, data_len);
	return data_len;
}

static int zte_open(struct tty_struct *tty, struct usb_serial_port *port)
{
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata;
	struct usb_serial *serial = port->serial;
	int i, err;
	struct urb *urb;

	portdata = usb_get_serial_port_data(port);
	intfdata = serial->private;

	/* Start reading from the IN endpoint */
	for (i = 0; i < N_IN_URB; i++) {
		urb = portdata->in_urbs[i];
		if (!urb)
			continue;
		err = usb_submit_urb(urb, GFP_KERNEL);
		if (err) {
			dev_dbg(&port->dev, "%s: submit urb %d failed (%d) %d\n",
				__func__, i, err, urb->transfer_buffer_length);
		}
	}

	if (intfdata->send_setup)
		intfdata->send_setup(port);

	serial->interface->needs_remote_wakeup = 1;
	spin_lock_irq(&intfdata->susp_lock);
	portdata->opened = 1;
	spin_unlock_irq(&intfdata->susp_lock);
	/* this balances a get in the generic USB serial code */
	usb_autopm_put_interface(serial->interface);

	return 0;
}

static void zte_close(struct usb_serial_port *port)
{
	int i;
	struct usb_serial *serial = port->serial;
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata = port->serial->private;

	portdata = usb_get_serial_port_data(port);

	if (serial->dev) {
		/* Stop reading/writing urbs */
		spin_lock_irq(&intfdata->susp_lock);
		portdata->opened = 0;
		spin_unlock_irq(&intfdata->susp_lock);

		for (i = 0; i < N_IN_URB; i++)
			usb_kill_urb(portdata->in_urbs[i]);
		for (i = 0; i < N_OUT_URB; i++)
			usb_kill_urb(portdata->out_urbs[i]);
		/* balancing - important as an error cannot be handled*/
		usb_autopm_get_interface_no_resume(serial->interface);
		serial->interface->needs_remote_wakeup = 0;
	}
}

/* Helper functions used by zte_setup_urbs */
static struct urb *zte_setup_urb(struct usb_serial_port *port,
				      int endpoint,
				      int dir, void *ctx, char *buf, int len,
				      void (*callback) (struct urb *))
{
	struct usb_serial *serial = port->serial;
	struct urb *urb;

	urb = usb_alloc_urb(0, GFP_KERNEL);	/* No ISO */
	if (urb == NULL) {
		dev_dbg(&serial->interface->dev,
			"%s: alloc for endpoint %d failed.\n", __func__,
			endpoint);
		return NULL;
	}

	/* Fill URB using supplied data. */
	usb_fill_bulk_urb(urb, serial->dev,
			  usb_sndbulkpipe(serial->dev, endpoint) | dir,
			  buf, len, callback, ctx);

	return urb;
}

static int zte_port_probe(struct usb_serial_port *port)
{
	struct zte_port_private *portdata;
	struct urb *urb;
	u8 *buffer;
	int err;
	int i;

	portdata = kzalloc(sizeof(*portdata), GFP_KERNEL);
	if (!portdata)
		return -ENOMEM;

	init_usb_anchor(&portdata->delayed);

	for (i = 0; i < N_IN_URB; i++) {
		if (!port->bulk_in_size)
			break;

		buffer = (u8 *)__get_free_page(GFP_KERNEL);
		if (!buffer)
			goto bail_out_error;
		portdata->in_buffer[i] = buffer;

		urb = zte_setup_urb(port, port->bulk_in_endpointAddress,
						USB_DIR_IN, port,
						buffer, IN_BUFLEN,
						zte_indat_callback);
		portdata->in_urbs[i] = urb;
	}

	for (i = 0; i < N_OUT_URB; i++) {
		if (!port->bulk_out_size)
			break;

		buffer = kmalloc(OUT_BUFLEN, GFP_KERNEL);
		if (!buffer)
			goto bail_out_error2;
		portdata->out_buffer[i] = buffer;

		urb = zte_setup_urb(port, port->bulk_out_endpointAddress,
						USB_DIR_OUT, port,
						buffer, OUT_BUFLEN,
						zte_outdat_callback);
		portdata->out_urbs[i] = urb;
	}

	usb_set_serial_port_data(port, portdata);

	if (port->interrupt_in_urb) {
		err = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);
		if (err)
			dev_dbg(&port->dev, "%s: submit irq_in urb failed %d\n",
				__func__, err);
	}

	return 0;

bail_out_error2:
	for (i = 0; i < N_OUT_URB; i++) {
		usb_free_urb(portdata->out_urbs[i]);
		kfree(portdata->out_buffer[i]);
	}
bail_out_error:
	for (i = 0; i < N_IN_URB; i++) {
		usb_free_urb(portdata->in_urbs[i]);
		free_page((unsigned long)portdata->in_buffer[i]);
	}
	kfree(portdata);

	return -ENOMEM;
}

static int zte_port_remove(struct usb_serial_port *port)
{
	int i;
	struct zte_port_private *portdata;

	portdata = usb_get_serial_port_data(port);
	usb_set_serial_port_data(port, NULL);

	/* Stop reading/writing urbs and free them */
	for (i = 0; i < N_IN_URB; i++) {
		usb_kill_urb(portdata->in_urbs[i]);
		usb_free_urb(portdata->in_urbs[i]);
		free_page((unsigned long)portdata->in_buffer[i]);
	}
	for (i = 0; i < N_OUT_URB; i++) {
		usb_kill_urb(portdata->out_urbs[i]);
		usb_free_urb(portdata->out_urbs[i]);
		kfree(portdata->out_buffer[i]);
	}

	/* Now free port private data */
	kfree(portdata);
	return 0;
}

#ifdef CONFIG_PM
static void stop_read_write_urbs(struct usb_serial *serial)
{
	int i, j;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;

	/* Stop reading/writing urbs */
	for (i = 0; i < serial->num_ports; ++i) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);
		if (!portdata)
			continue;
		for (j = 0; j < N_IN_URB; j++)
			usb_kill_urb(portdata->in_urbs[j]);
		for (j = 0; j < N_OUT_URB; j++)
			usb_kill_urb(portdata->out_urbs[j]);
	}
}

static int zte_suspend(struct usb_serial *serial, pm_message_t message)
{
	struct zte_intf_private *intfdata = serial->private;
	int b;

	if (PMSG_IS_AUTO(message)) {
		spin_lock_irq(&intfdata->susp_lock);
		b = intfdata->in_flight;
		spin_unlock_irq(&intfdata->susp_lock);

		if (b)
			return -EBUSY;
	}

	spin_lock_irq(&intfdata->susp_lock);
	intfdata->suspended = 1;
	spin_unlock_irq(&intfdata->susp_lock);
	stop_read_write_urbs(serial);

	return 0;
}

static void unbusy_queued_urb(struct urb *urb, struct zte_port_private *portdata)
{
	int i;

	for (i = 0; i < N_OUT_URB; i++) {
		if (urb == portdata->out_urbs[i]) {
			clear_bit(i, &portdata->out_busy);
			break;
		}
	}
}

static void play_delayed(struct usb_serial_port *port)
{
	struct zte_intf_private *data;
	struct zte_port_private *portdata;
	struct urb *urb;
	int err;

	portdata = usb_get_serial_port_data(port);
	data = port->serial->private;
	while ((urb = usb_get_from_anchor(&portdata->delayed))) {
		err = usb_submit_urb(urb, GFP_ATOMIC);
		if (!err) {
			data->in_flight++;
		} else {
			/* we have to throw away the rest */
			do {
				unbusy_queued_urb(urb, portdata);
				usb_autopm_put_interface_no_suspend(port->serial->interface);
			} while ((urb = usb_get_from_anchor(&portdata->delayed)));
			break;
		}
	}
}

static int zte_resume(struct usb_serial *serial)
{
	int i, j;
	struct usb_serial_port *port;
	struct zte_intf_private *intfdata = serial->private;
	struct zte_port_private *portdata;
	struct urb *urb;
	int err = 0;

	/* get the interrupt URBs resubmitted unconditionally */
	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		if (!port->interrupt_in_urb) {
			dev_dbg(&port->dev, "%s: No interrupt URB for port\n", __func__);
			continue;
		}
		err = usb_submit_urb(port->interrupt_in_urb, GFP_NOIO);
		dev_dbg(&port->dev, "Submitted interrupt URB for port (result %d)\n", err);
		if (err < 0) {
			dev_err(&port->dev, "%s: Error %d for interrupt URB\n",
				__func__, err);
			goto err_out;
		}
	}

	for (i = 0; i < serial->num_ports; i++) {
		/* walk all ports */
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);

		/* skip closed ports */
		spin_lock_irq(&intfdata->susp_lock);
		if (!portdata || !portdata->opened) {
			spin_unlock_irq(&intfdata->susp_lock);
			continue;
		}

		for (j = 0; j < N_IN_URB; j++) {
			urb = portdata->in_urbs[j];
			err = usb_submit_urb(urb, GFP_ATOMIC);
			if (err < 0) {
				dev_err(&port->dev, "%s: Error %d for bulk URB %d\n",
					__func__, err, i);
				spin_unlock_irq(&intfdata->susp_lock);
				goto err_out;
			}
		}
		play_delayed(port);
		spin_unlock_irq(&intfdata->susp_lock);
	}
	spin_lock_irq(&intfdata->susp_lock);
	intfdata->suspended = 0;
	spin_unlock_irq(&intfdata->susp_lock);
err_out:
	return err;
}
#endif

static struct usb_serial_driver * const serial_drivers[] = {
	&zte_1port_device, NULL
};

struct zte_private {
	u8 bInterfaceNumber;
};

module_usb_serial_driver(serial_drivers, zte_ids);

static bool is_blacklisted(const u8 ifnum, enum zte_blacklist_reason reason,
			   const struct zte_blacklist_info *blacklist)
{
	unsigned long num;
	const unsigned long *intf_list;

	if (blacklist) {
		if (reason == zte_BLACKLIST_SENDSETUP)
			intf_list = &blacklist->sendsetup;
		else if (reason == zte_BLACKLIST_RESERVED_IF)
			intf_list = &blacklist->reserved;
		else {
			BUG_ON(reason);
			return false;
		}

		for_each_set_bit(num, intf_list, MAX_BL_NUM + 1) {
			if (num == ifnum)
				return true;
		}
	}
	return false;
}

static int zte_probe(struct usb_serial *serial,
			const struct usb_device_id *id)
{
	struct usb_interface_descriptor *iface_desc =
				&serial->interface->cur_altsetting->desc;
	//struct usb_device_descriptor *dev_desc = &serial->dev->descriptor;

	/* Never bind to the CD-Rom emulation interface	*/
	if (iface_desc->bInterfaceClass == 0x08)
		return -ENODEV;

	/*
	 * Don't bind reserved interfaces (like network ones) which often have
	 * the same class/subclass/protocol as the serial interfaces.  Look at
	 * the Windows driver .INF files for reserved interface numbers.
	 */
	if (is_blacklisted(
		iface_desc->bInterfaceNumber,
		zte_BLACKLIST_RESERVED_IF,
		(const struct zte_blacklist_info *) id->driver_info))
		return -ENODEV;

	/* Store device id so we can use it during attach. */
	usb_set_serial_data(serial, (void *)id);

	return 0;
}



static int zte_attach(struct usb_serial *serial)
{
	struct usb_interface_descriptor *iface_desc;
	const struct usb_device_id *id;
	struct zte_intf_private *data;
	struct zte_private *priv;

	data = kzalloc(sizeof(struct zte_intf_private), GFP_KERNEL);
	if (!data)
		return -ENOMEM;

	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
	if (!priv) {
		kfree(data);
		return -ENOMEM;
	}

	/* Retrieve device id stored at probe. */
	id = usb_get_serial_data(serial);
	iface_desc = &serial->interface->cur_altsetting->desc;

	priv->bInterfaceNumber = iface_desc->bInterfaceNumber;
	data->private = priv;

	if (!is_blacklisted(iface_desc->bInterfaceNumber,
			zte_BLACKLIST_SENDSETUP,
			(struct zte_blacklist_info *)id->driver_info)) {
		data->send_setup = zte_send_setup;
	}
	spin_lock_init(&data->susp_lock);

	usb_set_serial_data(serial, data);

	return 0;
}

static void zte_release(struct usb_serial *serial)
{
	struct zte_intf_private *intfdata = usb_get_serial_data(serial);
	struct zte_private *priv = intfdata->private;

	kfree(priv);
	kfree(intfdata);
}

static void zte_instat_callback(struct urb *urb)
{
	int err;
	int status = urb->status;
	struct usb_serial_port *port = urb->context;
	struct device *dev = &port->dev;
	struct zte_port_private *portdata =
					usb_get_serial_port_data(port);

	dev_dbg(dev, "%s: urb %p port %p has data %p\n", __func__, urb, port, portdata);

	if (status == 0) {
		struct usb_ctrlrequest *req_pkt =
				(struct usb_ctrlrequest *)urb->transfer_buffer;

		if (!req_pkt) {
			dev_dbg(dev, "%s: NULL req_pkt\n", __func__);
			return;
		}
		if ((req_pkt->bRequestType == 0xA1) &&
				(req_pkt->bRequest == 0x20)) {
			int old_dcd_state;
			unsigned char signals = *((unsigned char *)
					urb->transfer_buffer +
					sizeof(struct usb_ctrlrequest));

			dev_dbg(dev, "%s: signal x%x\n", __func__, signals);

			old_dcd_state = portdata->dcd_state;
			portdata->cts_state = 1;
			portdata->dcd_state = ((signals & 0x01) ? 1 : 0);
			portdata->dsr_state = ((signals & 0x02) ? 1 : 0);
			portdata->ri_state = ((signals & 0x08) ? 1 : 0);

			if (old_dcd_state && !portdata->dcd_state) {
				struct tty_struct *tty =
						tty_port_tty_get(&port->port);
				if (tty && !C_CLOCAL(tty))
					tty_hangup(tty);
				tty_kref_put(tty);
			}
		} else {
			dev_dbg(dev, "%s: type %x req %x\n", __func__,
				req_pkt->bRequestType, req_pkt->bRequest);
		}
	} else
		dev_err(dev, "%s: error %d\n", __func__, status);

	/* Resubmit urb so we continue receiving IRQ data */
	if (status != -ESHUTDOWN && status != -ENOENT) {
		err = usb_submit_urb(urb, GFP_ATOMIC);
		if (err)
			dev_dbg(dev, "%s: resubmit intr urb failed. (%d)\n",
				__func__, err);
	}
}

/** send RTS/DTR state to the port.
 *
 * This is exactly the same as SET_CONTROL_LINE_STATE from the PSTN
 * CDC.
*/
static int zte_send_setup(struct usb_serial_port *port)
{
	struct usb_serial *serial = port->serial;
	struct zte_intf_private *intfdata = usb_get_serial_data(serial);
	struct zte_private *priv = intfdata->private;
	struct zte_port_private *portdata;
	int val = 0;

	portdata = usb_get_serial_port_data(port);

	if (portdata->dtr_state)
		val |= 0x01;
	if (portdata->rts_state)
		val |= 0x02;

	return usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),
				0x22, 0x21, val, priv->bInterfaceNumber, NULL,
				0, USB_CTRL_SET_TIMEOUT);
}

MODULE_AUTHOR(DRIVER_AUTHOR);
MODULE_DESCRIPTION(DRIVER_DESC);
MODULE_VERSION(DRIVER_VERSION);
MODULE_LICENSE("GPL");

module_param(debug, bool, S_IRUGO | S_IWUSR);
MODULE_PARM_DESC(debug, "Debug messages");
#elif LINUX_VERSION_CODE < KERNEL_VERSION(3,12,0)//use  3.11 .8 source code
#include <linux/kernel.h>
#include <linux/jiffies.h>
#include <linux/errno.h>
#include <linux/tty.h>
#include <linux/tty_flip.h>
#include <linux/slab.h>
#include <linux/module.h>
#include <linux/bitops.h>
#include <linux/usb.h>
#include <linux/usb/serial.h>

/* Function prototypes */
static int  zte_probe(struct usb_serial *serial,
			const struct usb_device_id *id);
static int zte_attach(struct usb_serial *serial);
static void zte_release(struct usb_serial *serial);
static int zte_send_setup(struct usb_serial_port *port);
static void zte_instat_callback(struct urb *urb);
static void zte_dtr_rts(struct usb_serial_port *port, int on);
static int zte_open(struct tty_struct *tty, struct usb_serial_port *port);
static void zte_close(struct usb_serial_port *port);
static int zte_port_probe(struct usb_serial_port *port);
static int zte_port_remove(struct usb_serial_port *port);
static int zte_write_room(struct tty_struct *tty);
static void zte_set_termios(struct tty_struct *tty,
				 struct usb_serial_port *port,
				 struct ktermios *old);
static int zte_tiocmget(struct tty_struct *tty);
static int zte_tiocmset(struct tty_struct *tty,
			     unsigned int set, unsigned int clear);
static int zte_ioctl(struct tty_struct *tty,
			  unsigned int cmd, unsigned long arg);

static int zte_write(struct tty_struct *tty, struct usb_serial_port *port,
			  const unsigned char *buf, int count);
static int zte_chars_in_buffer(struct tty_struct *tty);
#ifdef CONFIG_PM
static int zte_suspend(struct usb_serial *serial, pm_message_t message);
static int zte_resume(struct usb_serial *serial);
#endif

/* Vendor and product IDs */
/* ZTE PRODUCTS */
#define zte_VENDOR_ID				0x19d2

/* some devices interfaces need special handling due to a number of reasons */
enum zte_blacklist_reason {
		zte_BLACKLIST_NONE = 0,
		zte_BLACKLIST_SENDSETUP = 1,
		zte_BLACKLIST_RESERVED_IF = 2
};

#define MAX_BL_NUM  8
struct zte_blacklist_info {
	/* bitfield of interface numbers for zte_BLACKLIST_SENDSETUP */
	const unsigned long sendsetup;
	/* bitfield of interface numbers for zte_BLACKLIST_RESERVED_IF */
	const unsigned long reserved;
};

static const struct zte_blacklist_info four_g_w14_blacklist = {
	.sendsetup = BIT(0) | BIT(1),
};

static const struct zte_blacklist_info alcatel_x200_blacklist = {
	.sendsetup = BIT(0) | BIT(1),
	.reserved = BIT(4),
};

static const struct zte_blacklist_info zte_0037_blacklist = {
	.sendsetup = BIT(0) | BIT(1),
};

static const struct zte_blacklist_info zte_k3765_z_blacklist = {
	.sendsetup = BIT(0) | BIT(1) | BIT(2),
	.reserved = BIT(4),
};

static const struct zte_blacklist_info zte_mc2718_z_blacklist = {
	.sendsetup = BIT(1) | BIT(2) | BIT(3) | BIT(4),
};

static const struct zte_blacklist_info huawei_cdc12_blacklist = {
	.reserved = BIT(1) | BIT(2),
};

static const struct zte_blacklist_info net_intf1_blacklist = {
	.reserved = BIT(1),
};

static const struct zte_blacklist_info net_intf2_blacklist = {
	.reserved = BIT(2),
};

static const struct zte_blacklist_info net_intf3_blacklist = {
	.reserved = BIT(3),
};

static const struct zte_blacklist_info net_intf4_blacklist = {
	.reserved = BIT(4),
};

static const struct zte_blacklist_info net_intf5_blacklist = {
	.reserved = BIT(5),
};

static const struct zte_blacklist_info net_intf6_blacklist = {
	.reserved = BIT(6),
};

static const struct zte_blacklist_info zte_mf626_blacklist = {
	.sendsetup = BIT(0) | BIT(1),
	.reserved = BIT(4),
};

static const struct zte_blacklist_info zte_1255_blacklist = {
	.reserved = BIT(3) | BIT(4),
};

static const struct zte_blacklist_info telit_le920_blacklist = {
	.sendsetup = BIT(0),
	.reserved = BIT(1) | BIT(5),
};

static const struct usb_device_id zte_ids[] = {
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0001, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0002, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0003, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0004, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0005, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0006, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0007, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0008, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0009, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0010, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0011, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0012, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0013, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0014, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0015, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0016, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0017, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0018, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0019, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0020, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0021, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0022, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0023, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0024, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0025, 0xff, 0xff, 0xff) },
    //   { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0026, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0027, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0028, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0029, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0030, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0031, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0032, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0033, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0034, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0035, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0036, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0037, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0038, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0039, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0040, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0041, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0042, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0043, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0044, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0045, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0046, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0047, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0048, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0049, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0050, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0051, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0052, 0xff, 0xff, 0xff) },
    //   { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0053, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0054, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0055, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0056, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0057, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0058, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0059, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0060, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0061, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0062, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0063, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0064, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0065, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0066, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0067, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0068, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0069, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0070, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0071, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0072, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0073, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0074, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0075, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0076, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0077, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0078, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0079, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0080, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0081, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0082, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0083, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0084, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0085, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0086, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0087, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0088, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0089, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0090, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0091, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0092, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0093, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0094, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0095, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0096, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0097, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0098, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0099, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0104, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0105, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0106, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0108, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0117, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0118, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0121, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0122, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0123, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0124, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0125, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0126, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0128, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0130, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0133, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0135, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0136, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0137, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0139, 0xff, 0xff, 0xff) }, 	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0141, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0144, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0145, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0147, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0148, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0151, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0152, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0153, 0xff, 0xff, 0xff) },
    //{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0154, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0155, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0156, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0157, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0158, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0159, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0160, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0161, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0162, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0164, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0165, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0167, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0168, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0170, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0176, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0178, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0189, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0191, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0196, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0197, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0199, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0200, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0201, 0xff, 0xff, 0xff) },		
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0254, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0257, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0265, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0284, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0317, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0330, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0395, 0xff, 0xff, 0xff) },      
 	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0414, 0xff, 0xff, 0xff) },   
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0417, 0xff, 0xff, 0xff) },

    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1008, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1010, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1012, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1018, 0xff, 0xff, 0xff) },		
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1057, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1058, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1059, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1060, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1061, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1062, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1063, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1064, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1065, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1066, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1067, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1068, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1069, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1070, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1071, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1072, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1073, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1074, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1075, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1076, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1077, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1078, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1079, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1080, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1081, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1082, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1083, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1084, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1085, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1086, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1087, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1088, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1089, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1090, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1091, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1092, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1093, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1094, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1095, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1096, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1097, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1098, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1099, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1100, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1101, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1102, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1103, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1104, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1105, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1106, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1107, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1108, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1109, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1110, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1111, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1112, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1113, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1114, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1115, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1116, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1117, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1118, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1119, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1120, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1121, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1122, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1123, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1124, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1125, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1126, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1127, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1128, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1129, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1130, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1131, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1132, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1133, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1134, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1135, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1136, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1137, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1138, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1139, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1140, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1141, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1142, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1143, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1144, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1145, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1146, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1147, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1148, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1149, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1150, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1151, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1152, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1153, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1154, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1155, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1156, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1157, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1158, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1159, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1160, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1161, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1162, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1163, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1164, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1165, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1166, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1167, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1168, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1169, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1170, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1244, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1245, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1246, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1247, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1248, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1249, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1250, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1251, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1252, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1253, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1254, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1255, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1256, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1257, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1258, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1259, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1260, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1261, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1262, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1263, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1264, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1265, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1266, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1267, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1268, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1269, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1270, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1271, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1272, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1273, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1274, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1275, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1276, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1277, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1278, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1279, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1280, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1281, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1282, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1283, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1284, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1285, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1286, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1287, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1288, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1289, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1290, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1291, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1292, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1293, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1294, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1295, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1296, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1297, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1298, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1299, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1300, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1301, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1302, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1303, 0xff, 0xff, 0xff) },	
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1333, 0xff, 0xff, 0xff) },	
	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1401, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1402, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1403, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1404, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1405, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1406, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1407, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1408, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1409, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1410, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1411, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1412, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1413, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1414, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1415, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1416, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1417, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1418, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1419, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1420, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1421, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1422, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1423, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1424, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1425, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1426, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1427, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1428, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1429, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1430, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1431, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1432, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1433, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1434, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1435, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1436, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1437, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1438, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1439, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1440, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1441, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1442, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1443, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1444, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1445, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1446, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1447, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1448, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1449, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1450, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1451, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1452, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1453, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1454, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1455, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1456, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1457, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1458, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1459, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1460, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1461, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1462, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1463, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1464, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1465, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1466, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1467, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1468, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1469, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1470, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1471, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1472, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1473, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1474, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1475, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1476, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1477, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1478, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1479, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1480, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1481, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1482, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1483, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1484, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1485, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1486, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1487, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1488, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1489, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1490, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1491, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1492, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1493, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1494, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1495, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1496, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1497, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1498, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1499, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1500, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1501, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1502, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1503, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1504, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1505, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1506, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1507, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1508, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1509, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1510, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1533, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1534, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1535, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1545, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1546, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1547, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1565, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1566, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1567, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1589, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1590, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1591, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1592, 0xff, 0xff, 0xff) }, 	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1594, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1596, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1598, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1600, 0xff, 0xff, 0xff) },  		
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x2002, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x2003, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0xFFEC, 0xff, 0xff, 0xff) },
    { ZTE_USB_DEVICE_ID_MATCH_INT_CLASS_AND_SUBCLASS_INFO(0x19d2,0xff,0x86) },
    { ZTE_USB_DEVICE_ID_MATCH_INT_CLASS_AND_SUBCLASS_INFO(0x19d2,0xff,0x02) },
    { USB_DEVICE_AND_INTERFACE_INFO(TPLink_VENDOR_ID, 0x7E11, 0xff, 0xff, 0xff) },/*TPLink*/
    { USB_DEVICE_AND_INTERFACE_INFO(QUALCOMM_VENDOR_ID, 0x9001, 0xff, 0xff, 0xff) },/*QUALCOMM_VENDOR_ID*/
    { USB_DEVICE_AND_INTERFACE_INFO(QUALCOMM_VENDOR_ID, 0x9002, 0xff, 0xff, 0xff) },
	{ } /* Terminating entry */
};
MODULE_DEVICE_TABLE(usb, zte_ids);

/* The card has three separate interfaces, which the serial driver
 * recognizes separately, thus num_port=1.
 */

static struct usb_serial_driver zte_1port_device = {
	.driver = {
		.owner =	THIS_MODULE,
		.name =		"zte1",
	},
	.description       = "GSM modem (1-port)",
	.id_table          = zte_ids,
	.num_ports         = 1,
	.probe             = zte_probe,
	.open              = zte_open,
	.close             = zte_close,
	.dtr_rts	   = zte_dtr_rts,
	.write             = zte_write,
	.write_room        = zte_write_room,
	.chars_in_buffer   = zte_chars_in_buffer,
	.set_termios       = zte_set_termios,
	.tiocmget          = zte_tiocmget,
	.tiocmset          = zte_tiocmset,
	.ioctl             = zte_ioctl,
	.attach            = zte_attach,
	.release           = zte_release,
	.port_probe        = zte_port_probe,
	.port_remove	   = zte_port_remove,
	.read_int_callback = zte_instat_callback,
#ifdef CONFIG_PM
	.suspend           = zte_suspend,
	.resume            = zte_resume,
#endif
};

static bool debug;
/* per port private data */

#define N_IN_URB 4
#define N_OUT_URB 4
#define IN_BUFLEN 4096
#define OUT_BUFLEN 4096

struct zte_intf_private {
	spinlock_t susp_lock;
	unsigned int suspended:1;
	int in_flight;
	int (*send_setup) (struct usb_serial_port *port);
	void *private;
};

struct zte_port_private {
	/* Input endpoints and buffer for this port */
	struct urb *in_urbs[N_IN_URB];
	u8 *in_buffer[N_IN_URB];
	/* Output endpoints and buffer for this port */
	struct urb *out_urbs[N_OUT_URB];
	u8 *out_buffer[N_OUT_URB];
	unsigned long out_busy;	/* Bit vector of URBs in use */
	int opened;
	struct usb_anchor delayed;

	/* Settings for the port */
	int rts_state;		/* Handshaking pins (outputs) */
	int dtr_state;
	int cts_state;		/* Handshaking pins (inputs) */
	int dsr_state;
	int dcd_state;
	int ri_state;

	unsigned long tx_start_time[N_OUT_URB];
};

static void zte_dtr_rts(struct usb_serial_port *port, int on)
{
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata;

	intfdata = port->serial->private;

	if (!intfdata->send_setup)
		return;

	portdata = usb_get_serial_port_data(port);
	/* FIXME: locking */
	portdata->rts_state = on;
	portdata->dtr_state = on;

	intfdata->send_setup(port);
}

static void zte_set_termios(struct tty_struct *tty,
			  struct usb_serial_port *port,
			  struct ktermios *old_termios)
{
	struct zte_intf_private *intfdata = port->serial->private;

	/* Doesn't support zte setting */
	tty_termios_copy_hw(&tty->termios, old_termios);

	if (intfdata->send_setup)
		intfdata->send_setup(port);
}

static int zte_tiocmget(struct tty_struct *tty)
{
	struct usb_serial_port *port = tty->driver_data;
	unsigned int value;
	struct zte_port_private *portdata;

	portdata = usb_get_serial_port_data(port);

	value = ((portdata->rts_state) ? TIOCM_RTS : 0) |
	    ((portdata->dtr_state) ? TIOCM_DTR : 0) |
	    ((portdata->cts_state) ? TIOCM_CTS : 0) |
	    ((portdata->dsr_state) ? TIOCM_DSR : 0) |
	    ((portdata->dcd_state) ? TIOCM_CAR : 0) |
	    ((portdata->ri_state) ? TIOCM_RNG : 0);

	return value;
}

static int zte_tiocmset(struct tty_struct *tty,
		      unsigned int set, unsigned int clear)
{
	struct usb_serial_port *port = tty->driver_data;
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata;

	portdata = usb_get_serial_port_data(port);
	intfdata = port->serial->private;

	if (!intfdata->send_setup)
		return -EINVAL;

	/* FIXME: what locks portdata fields ? */
	if (set & TIOCM_RTS)
		portdata->rts_state = 1;
	if (set & TIOCM_DTR)
		portdata->dtr_state = 1;

	if (clear & TIOCM_RTS)
		portdata->rts_state = 0;
	if (clear & TIOCM_DTR)
		portdata->dtr_state = 0;
	return intfdata->send_setup(port);
}

static int get_serial_info(struct usb_serial_port *port,
			   struct serial_struct __user *retinfo)
{
	struct serial_struct tmp;

	if (!retinfo)
		return -EFAULT;

	memset(&tmp, 0, sizeof(tmp));
	tmp.line            = port->minor;
	tmp.port            = port->port_number;
	tmp.baud_base       = tty_get_baud_rate(port->port.tty);
	tmp.close_delay	    = port->port.close_delay / 10;
	tmp.closing_wait    = port->port.closing_wait == ASYNC_CLOSING_WAIT_NONE ?
				 ASYNC_CLOSING_WAIT_NONE :
				 port->port.closing_wait / 10;

	if (copy_to_user(retinfo, &tmp, sizeof(*retinfo)))
		return -EFAULT;
	return 0;
}

static int set_serial_info(struct usb_serial_port *port,
			   struct serial_struct __user *newinfo)
{
	struct serial_struct new_serial;
	unsigned int closing_wait, close_delay;
	int retval = 0;

	if (copy_from_user(&new_serial, newinfo, sizeof(new_serial)))
		return -EFAULT;

	close_delay = new_serial.close_delay * 10;
	closing_wait = new_serial.closing_wait == ASYNC_CLOSING_WAIT_NONE ?
			ASYNC_CLOSING_WAIT_NONE : new_serial.closing_wait * 10;

	mutex_lock(&port->port.mutex);

	if (!capable(CAP_SYS_ADMIN)) {
		if ((close_delay != port->port.close_delay) ||
		    (closing_wait != port->port.closing_wait))
			retval = -EPERM;
		else
			retval = -EOPNOTSUPP;
	} else {
		port->port.close_delay  = close_delay;
		port->port.closing_wait = closing_wait;
	}

	mutex_unlock(&port->port.mutex);
	return retval;
}

static int zte_ioctl(struct tty_struct *tty,
		   unsigned int cmd, unsigned long arg)
{
	struct usb_serial_port *port = tty->driver_data;

	dev_dbg(&port->dev, "%s cmd 0x%04x\n", __func__, cmd);

	switch (cmd) {
	case TIOCGSERIAL:
		return get_serial_info(port,
				       (struct serial_struct __user *) arg);
	case TIOCSSERIAL:
		return set_serial_info(port,
				       (struct serial_struct __user *) arg);
	default:
		break;
	}

	dev_dbg(&port->dev, "%s arg not supported\n", __func__);

	return -ENOIOCTLCMD;
}

/* Write */
static int zte_write(struct tty_struct *tty, struct usb_serial_port *port,
		   const unsigned char *buf, int count)
{
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata;
	int i;
	int left, todo;
	struct urb *this_urb = NULL;	/* spurious */
	int err;
	unsigned long flags;

	portdata = usb_get_serial_port_data(port);
	intfdata = port->serial->private;

	dev_dbg(&port->dev, "%s: write (%d chars)\n", __func__, count);

	i = 0;
	left = count;
	for (i = 0; left > 0 && i < N_OUT_URB; i++) {
		todo = left;
		if (todo > OUT_BUFLEN)
			todo = OUT_BUFLEN;

		this_urb = portdata->out_urbs[i];
		if (test_and_set_bit(i, &portdata->out_busy)) {
			if (time_before(jiffies,
					portdata->tx_start_time[i] + 10 * HZ))
				continue;
			usb_unlink_urb(this_urb);
			continue;
		}
		dev_dbg(&port->dev, "%s: endpoint %d buf %d\n", __func__,
			usb_pipeendpoint(this_urb->pipe), i);

		err = usb_autopm_get_interface_async(port->serial->interface);
		if (err < 0)
			break;

		/* send the data */
		memcpy(this_urb->transfer_buffer, buf, todo);
		this_urb->transfer_buffer_length = todo;

		spin_lock_irqsave(&intfdata->susp_lock, flags);
		if (intfdata->suspended) {
			usb_anchor_urb(this_urb, &portdata->delayed);
			spin_unlock_irqrestore(&intfdata->susp_lock, flags);
		} else {
			intfdata->in_flight++;
			spin_unlock_irqrestore(&intfdata->susp_lock, flags);
			err = usb_submit_urb(this_urb, GFP_ATOMIC);
			if (err) {
				dev_dbg(&port->dev,
					"usb_submit_urb %p (write bulk) failed (%d)\n",
					this_urb, err);
				clear_bit(i, &portdata->out_busy);
				spin_lock_irqsave(&intfdata->susp_lock, flags);
				intfdata->in_flight--;
				spin_unlock_irqrestore(&intfdata->susp_lock,
						       flags);
				usb_autopm_put_interface_async(port->serial->interface);
				break;
			}
		}

		portdata->tx_start_time[i] = jiffies;
		buf += todo;
		left -= todo;
	}

	count -= left;
	dev_dbg(&port->dev, "%s: wrote (did %d)\n", __func__, count);
	return count;
}

static void zte_indat_callback(struct urb *urb)
{
	int err;
	int endpoint;
	struct usb_serial_port *port;
	struct device *dev;
	unsigned char *data = urb->transfer_buffer;
	int status = urb->status;

	endpoint = usb_pipeendpoint(urb->pipe);
	port = urb->context;
	dev = &port->dev;

	if (status) {
		dev_dbg(dev, "%s: nonzero status: %d on endpoint %02x.\n",
			__func__, status, endpoint);
	} else {
		if (urb->actual_length) {
			tty_insert_flip_string(&port->port, data,
					urb->actual_length);
			tty_flip_buffer_push(&port->port);
		} else
			dev_dbg(dev, "%s: empty read urb received\n", __func__);
	}
	/* Resubmit urb so we continue receiving */
	err = usb_submit_urb(urb, GFP_ATOMIC);
	if (err) {
		if (err != -EPERM) {
			dev_err(dev, "%s: resubmit read urb failed. (%d)\n",
				__func__, err);
			/* busy also in error unless we are killed */
			usb_mark_last_busy(port->serial->dev);
		}
	} else {
		usb_mark_last_busy(port->serial->dev);
	}
}

static void zte_outdat_callback(struct urb *urb)
{
	struct usb_serial_port *port;
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata;
	int i;

	port = urb->context;
	intfdata = port->serial->private;

	usb_serial_port_softint(port);
	usb_autopm_put_interface_async(port->serial->interface);
	portdata = usb_get_serial_port_data(port);
	spin_lock(&intfdata->susp_lock);
	intfdata->in_flight--;
	spin_unlock(&intfdata->susp_lock);

	for (i = 0; i < N_OUT_URB; ++i) {
		if (portdata->out_urbs[i] == urb) {
			smp_mb__before_clear_bit();
			clear_bit(i, &portdata->out_busy);
			break;
		}
	}
}

static int zte_write_room(struct tty_struct *tty)
{
	struct usb_serial_port *port = tty->driver_data;
	struct zte_port_private *portdata;
	int i;
	int data_len = 0;
	struct urb *this_urb;

	portdata = usb_get_serial_port_data(port);

	for (i = 0; i < N_OUT_URB; i++) {
		this_urb = portdata->out_urbs[i];
		if (this_urb && !test_bit(i, &portdata->out_busy))
			data_len += OUT_BUFLEN;
	}

	dev_dbg(&port->dev, "%s: %d\n", __func__, data_len);
	return data_len;
}

static int zte_chars_in_buffer(struct tty_struct *tty)
{
	struct usb_serial_port *port = tty->driver_data;
	struct zte_port_private *portdata;
	int i;
	int data_len = 0;
	struct urb *this_urb;

	portdata = usb_get_serial_port_data(port);

	for (i = 0; i < N_OUT_URB; i++) {
		this_urb = portdata->out_urbs[i];
		/* FIXME: This locking is insufficient as this_urb may
		   go unused during the test */
		if (this_urb && test_bit(i, &portdata->out_busy))
			data_len += this_urb->transfer_buffer_length;
	}
	dev_dbg(&port->dev, "%s: %d\n", __func__, data_len);
	return data_len;
}

static int zte_open(struct tty_struct *tty, struct usb_serial_port *port)
{
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata;
	struct usb_serial *serial = port->serial;
	int i, err;
	struct urb *urb;

	portdata = usb_get_serial_port_data(port);
	intfdata = serial->private;

	/* Start reading from the IN endpoint */
	for (i = 0; i < N_IN_URB; i++) {
		urb = portdata->in_urbs[i];
		if (!urb)
			continue;
		err = usb_submit_urb(urb, GFP_KERNEL);
		if (err) {
			dev_dbg(&port->dev, "%s: submit urb %d failed (%d) %d\n",
				__func__, i, err, urb->transfer_buffer_length);
		}
	}

	if (intfdata->send_setup)
		intfdata->send_setup(port);

	serial->interface->needs_remote_wakeup = 1;
	spin_lock_irq(&intfdata->susp_lock);
	portdata->opened = 1;
	spin_unlock_irq(&intfdata->susp_lock);
	/* this balances a get in the generic USB serial code */
	usb_autopm_put_interface(serial->interface);

	return 0;
}

static void zte_close(struct usb_serial_port *port)
{
	int i;
	struct usb_serial *serial = port->serial;
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata = port->serial->private;

	portdata = usb_get_serial_port_data(port);

	/* Stop reading/writing urbs */
	spin_lock_irq(&intfdata->susp_lock);
	portdata->opened = 0;
	spin_unlock_irq(&intfdata->susp_lock);

	for (i = 0; i < N_IN_URB; i++)
		usb_kill_urb(portdata->in_urbs[i]);
	for (i = 0; i < N_OUT_URB; i++)
		usb_kill_urb(portdata->out_urbs[i]);

	/* balancing - important as an error cannot be handled*/
	usb_autopm_get_interface_no_resume(serial->interface);
	serial->interface->needs_remote_wakeup = 0;
}

/* Helper functions used by zte_setup_urbs */
static struct urb *zte_setup_urb(struct usb_serial_port *port,
				      int endpoint,
				      int dir, void *ctx, char *buf, int len,
				      void (*callback) (struct urb *))
{
	struct usb_serial *serial = port->serial;
	struct urb *urb;

	urb = usb_alloc_urb(0, GFP_KERNEL);	/* No ISO */
	if (urb == NULL) {
		dev_dbg(&serial->interface->dev,
			"%s: alloc for endpoint %d failed.\n", __func__,
			endpoint);
		return NULL;
	}

	/* Fill URB using supplied data. */
	usb_fill_bulk_urb(urb, serial->dev,
			  usb_sndbulkpipe(serial->dev, endpoint) | dir,
			  buf, len, callback, ctx);

	return urb;
}

static int zte_port_probe(struct usb_serial_port *port)
{
	struct zte_port_private *portdata;
	struct urb *urb;
	u8 *buffer;
	int err;
	int i;

	portdata = kzalloc(sizeof(*portdata), GFP_KERNEL);
	if (!portdata)
		return -ENOMEM;

	init_usb_anchor(&portdata->delayed);

	for (i = 0; i < N_IN_URB; i++) {
		if (!port->bulk_in_size)
			break;

		buffer = (u8 *)__get_free_page(GFP_KERNEL);
		if (!buffer)
			goto bail_out_error;
		portdata->in_buffer[i] = buffer;

		urb = zte_setup_urb(port, port->bulk_in_endpointAddress,
						USB_DIR_IN, port,
						buffer, IN_BUFLEN,
						zte_indat_callback);
		portdata->in_urbs[i] = urb;
	}

	for (i = 0; i < N_OUT_URB; i++) {
		if (!port->bulk_out_size)
			break;

		buffer = kmalloc(OUT_BUFLEN, GFP_KERNEL);
		if (!buffer)
			goto bail_out_error2;
		portdata->out_buffer[i] = buffer;

		urb = zte_setup_urb(port, port->bulk_out_endpointAddress,
						USB_DIR_OUT, port,
						buffer, OUT_BUFLEN,
						zte_outdat_callback);
		portdata->out_urbs[i] = urb;
	}

	usb_set_serial_port_data(port, portdata);

	if (port->interrupt_in_urb) {
		err = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);
		if (err)
			dev_dbg(&port->dev, "%s: submit irq_in urb failed %d\n",
				__func__, err);
	}

	return 0;

bail_out_error2:
	for (i = 0; i < N_OUT_URB; i++) {
		usb_free_urb(portdata->out_urbs[i]);
		kfree(portdata->out_buffer[i]);
	}
bail_out_error:
	for (i = 0; i < N_IN_URB; i++) {
		usb_free_urb(portdata->in_urbs[i]);
		free_page((unsigned long)portdata->in_buffer[i]);
	}
	kfree(portdata);

	return -ENOMEM;
}

static int zte_port_remove(struct usb_serial_port *port)
{
	int i;
	struct zte_port_private *portdata;

	portdata = usb_get_serial_port_data(port);
	usb_set_serial_port_data(port, NULL);

	/* Stop reading/writing urbs and free them */
	for (i = 0; i < N_IN_URB; i++) {
		usb_kill_urb(portdata->in_urbs[i]);
		usb_free_urb(portdata->in_urbs[i]);
		free_page((unsigned long)portdata->in_buffer[i]);
	}
	for (i = 0; i < N_OUT_URB; i++) {
		usb_kill_urb(portdata->out_urbs[i]);
		usb_free_urb(portdata->out_urbs[i]);
		kfree(portdata->out_buffer[i]);
	}

	/* Now free port private data */
	kfree(portdata);
	return 0;
}

#ifdef CONFIG_PM
static void stop_read_write_urbs(struct usb_serial *serial)
{
	int i, j;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;

	/* Stop reading/writing urbs */
	for (i = 0; i < serial->num_ports; ++i) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);
		if (!portdata)
			continue;
		for (j = 0; j < N_IN_URB; j++)
			usb_kill_urb(portdata->in_urbs[j]);
		for (j = 0; j < N_OUT_URB; j++)
			usb_kill_urb(portdata->out_urbs[j]);
	}
}

static int zte_suspend(struct usb_serial *serial, pm_message_t message)
{
	struct zte_intf_private *intfdata = serial->private;
	int b;

	if (PMSG_IS_AUTO(message)) {
		spin_lock_irq(&intfdata->susp_lock);
		b = intfdata->in_flight;
		spin_unlock_irq(&intfdata->susp_lock);

		if (b)
			return -EBUSY;
	}

	spin_lock_irq(&intfdata->susp_lock);
	intfdata->suspended = 1;
	spin_unlock_irq(&intfdata->susp_lock);
	stop_read_write_urbs(serial);

	return 0;
}

static void unbusy_queued_urb(struct urb *urb, struct zte_port_private *portdata)
{
	int i;

	for (i = 0; i < N_OUT_URB; i++) {
		if (urb == portdata->out_urbs[i]) {
			clear_bit(i, &portdata->out_busy);
			break;
		}
	}
}

static void play_delayed(struct usb_serial_port *port)
{
	struct zte_intf_private *data;
	struct zte_port_private *portdata;
	struct urb *urb;
	int err;

	portdata = usb_get_serial_port_data(port);
	data = port->serial->private;
	while ((urb = usb_get_from_anchor(&portdata->delayed))) {
		err = usb_submit_urb(urb, GFP_ATOMIC);
		if (!err) {
			data->in_flight++;
		} else {
			/* we have to throw away the rest */
			do {
				unbusy_queued_urb(urb, portdata);
				usb_autopm_put_interface_no_suspend(port->serial->interface);
			} while ((urb = usb_get_from_anchor(&portdata->delayed)));
			break;
		}
	}
}

static int zte_resume(struct usb_serial *serial)
{
	int i, j;
	struct usb_serial_port *port;
	struct zte_intf_private *intfdata = serial->private;
	struct zte_port_private *portdata;
	struct urb *urb;
	int err = 0;

	/* get the interrupt URBs resubmitted unconditionally */
	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		if (!port->interrupt_in_urb) {
			dev_dbg(&port->dev, "%s: No interrupt URB for port\n", __func__);
			continue;
		}
		err = usb_submit_urb(port->interrupt_in_urb, GFP_NOIO);
		dev_dbg(&port->dev, "Submitted interrupt URB for port (result %d)\n", err);
		if (err < 0) {
			dev_err(&port->dev, "%s: Error %d for interrupt URB\n",
				__func__, err);
			goto err_out;
		}
	}

	for (i = 0; i < serial->num_ports; i++) {
		/* walk all ports */
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);

		/* skip closed ports */
		spin_lock_irq(&intfdata->susp_lock);
		if (!portdata || !portdata->opened) {
			spin_unlock_irq(&intfdata->susp_lock);
			continue;
		}

		for (j = 0; j < N_IN_URB; j++) {
			urb = portdata->in_urbs[j];
			err = usb_submit_urb(urb, GFP_ATOMIC);
			if (err < 0) {
				dev_err(&port->dev, "%s: Error %d for bulk URB %d\n",
					__func__, err, i);
				spin_unlock_irq(&intfdata->susp_lock);
				goto err_out;
			}
		}
		play_delayed(port);
		spin_unlock_irq(&intfdata->susp_lock);
	}
	spin_lock_irq(&intfdata->susp_lock);
	intfdata->suspended = 0;
	spin_unlock_irq(&intfdata->susp_lock);
err_out:
	return err;
}
#endif

static struct usb_serial_driver * const serial_drivers[] = {
	&zte_1port_device, NULL
};

struct zte_private {
	u8 bInterfaceNumber;
};

module_usb_serial_driver(serial_drivers, zte_ids);

static bool is_blacklisted(const u8 ifnum, enum zte_blacklist_reason reason,
			   const struct zte_blacklist_info *blacklist)
{
	unsigned long num;
	const unsigned long *intf_list;

	if (blacklist) {
		if (reason == zte_BLACKLIST_SENDSETUP)
			intf_list = &blacklist->sendsetup;
		else if (reason == zte_BLACKLIST_RESERVED_IF)
			intf_list = &blacklist->reserved;
		else {
			BUG_ON(reason);
			return false;
		}

		for_each_set_bit(num, intf_list, MAX_BL_NUM + 1) {
			if (num == ifnum)
				return true;
		}
	}
	return false;
}

static int zte_probe(struct usb_serial *serial,
			const struct usb_device_id *id)
{
	struct usb_interface_descriptor *iface_desc =
				&serial->interface->cur_altsetting->desc;
	struct usb_device_descriptor *dev_desc = &serial->dev->descriptor;

	/* Never bind to the CD-Rom emulation interface	*/
	if (iface_desc->bInterfaceClass == 0x08)
		return -ENODEV;

	/*
	 * Don't bind reserved interfaces (like network ones) which often have
	 * the same class/subclass/protocol as the serial interfaces.  Look at
	 * the Windows driver .INF files for reserved interface numbers.
	 */
	if (is_blacklisted(
		iface_desc->bInterfaceNumber,
		zte_BLACKLIST_RESERVED_IF,
		(const struct zte_blacklist_info *) id->driver_info))
		return -ENODEV;

	/* Store device id so we can use it during attach. */
	usb_set_serial_data(serial, (void *)id);

	return 0;
}



static int zte_attach(struct usb_serial *serial)
{
	struct usb_interface_descriptor *iface_desc;
	const struct usb_device_id *id;
	struct zte_intf_private *data;
	struct zte_private *priv;

	data = kzalloc(sizeof(struct zte_intf_private), GFP_KERNEL);
	if (!data)
		return -ENOMEM;

	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
	if (!priv) {
		kfree(data);
		return -ENOMEM;
	}

	/* Retrieve device id stored at probe. */
	id = usb_get_serial_data(serial);
	iface_desc = &serial->interface->cur_altsetting->desc;

	priv->bInterfaceNumber = iface_desc->bInterfaceNumber;
	data->private = priv;

	if (!is_blacklisted(iface_desc->bInterfaceNumber,
			zte_BLACKLIST_SENDSETUP,
			(struct zte_blacklist_info *)id->driver_info)) {
		data->send_setup = zte_send_setup;
	}
	spin_lock_init(&data->susp_lock);

	usb_set_serial_data(serial, data);

	return 0;
}

static void zte_release(struct usb_serial *serial)
{
	struct zte_intf_private *intfdata = usb_get_serial_data(serial);
	struct zte_private *priv = intfdata->private;

	kfree(priv);
	kfree(intfdata);
}

static void zte_instat_callback(struct urb *urb)
{
	int err;
	int status = urb->status;
	struct usb_serial_port *port = urb->context;
	struct device *dev = &port->dev;
	struct zte_port_private *portdata =
					usb_get_serial_port_data(port);

	dev_dbg(dev, "%s: urb %p port %p has data %p\n", __func__, urb, port, portdata);

	if (status == 0) {
		struct usb_ctrlrequest *req_pkt =
				(struct usb_ctrlrequest *)urb->transfer_buffer;

		if (!req_pkt) {
			dev_dbg(dev, "%s: NULL req_pkt\n", __func__);
			return;
		}
		if ((req_pkt->bRequestType == 0xA1) &&
				(req_pkt->bRequest == 0x20)) {
			int old_dcd_state;
			unsigned char signals = *((unsigned char *)
					urb->transfer_buffer +
					sizeof(struct usb_ctrlrequest));

			dev_dbg(dev, "%s: signal x%x\n", __func__, signals);

			old_dcd_state = portdata->dcd_state;
			portdata->cts_state = 1;
			portdata->dcd_state = ((signals & 0x01) ? 1 : 0);
			portdata->dsr_state = ((signals & 0x02) ? 1 : 0);
			portdata->ri_state = ((signals & 0x08) ? 1 : 0);

			if (old_dcd_state && !portdata->dcd_state)
				tty_port_tty_hangup(&port->port, true);
		} else {
			dev_dbg(dev, "%s: type %x req %x\n", __func__,
				req_pkt->bRequestType, req_pkt->bRequest);
		}
	} else
		dev_err(dev, "%s: error %d\n", __func__, status);

	/* Resubmit urb so we continue receiving IRQ data */
	if (status != -ESHUTDOWN && status != -ENOENT) {
		err = usb_submit_urb(urb, GFP_ATOMIC);
		if (err)
			dev_dbg(dev, "%s: resubmit intr urb failed. (%d)\n",
				__func__, err);
	}
}

/** send RTS/DTR state to the port.
 *
 * This is exactly the same as SET_CONTROL_LINE_STATE from the PSTN
 * CDC.
*/
static int zte_send_setup(struct usb_serial_port *port)
{
	struct usb_serial *serial = port->serial;
	struct zte_intf_private *intfdata = usb_get_serial_data(serial);
	struct zte_private *priv = intfdata->private;
	struct zte_port_private *portdata;
	int val = 0;

	portdata = usb_get_serial_port_data(port);

	if (portdata->dtr_state)
		val |= 0x01;
	if (portdata->rts_state)
		val |= 0x02;

	return usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),
				0x22, 0x21, val, priv->bInterfaceNumber, NULL,
				0, USB_CTRL_SET_TIMEOUT);
}

MODULE_AUTHOR(DRIVER_AUTHOR);
MODULE_DESCRIPTION(DRIVER_DESC);
MODULE_VERSION(DRIVER_VERSION);
MODULE_LICENSE("GPL");

module_param(debug, bool, S_IRUGO | S_IWUSR);
MODULE_PARM_DESC(debug, "Debug messages");
#else //newer than 3.11
#include <linux/kernel.h>
#include <linux/jiffies.h>
#include <linux/errno.h>
#include <linux/tty.h>
#include <linux/tty_flip.h>
#include <linux/slab.h>
#include <linux/module.h>
#include <linux/bitops.h>
#include <linux/usb.h>
#include <linux/usb/serial.h>

/* Function prototypes */
static int  zte_probe(struct usb_serial *serial,
			const struct usb_device_id *id);
static int zte_attach(struct usb_serial *serial);
static void zte_release(struct usb_serial *serial);
static int zte_send_setup(struct usb_serial_port *port);
static void zte_instat_callback(struct urb *urb);
static void zte_dtr_rts(struct usb_serial_port *port, int on);
static int zte_open(struct tty_struct *tty, struct usb_serial_port *port);
static void zte_close(struct usb_serial_port *port);
static int zte_port_probe(struct usb_serial_port *port);
static int zte_port_remove(struct usb_serial_port *port);
static int zte_write_room(struct tty_struct *tty);
static void zte_set_termios(struct tty_struct *tty,
				 struct usb_serial_port *port,
				 struct ktermios *old);
static int zte_tiocmget(struct tty_struct *tty);
static int zte_tiocmset(struct tty_struct *tty,
			     unsigned int set, unsigned int clear);
static int zte_ioctl(struct tty_struct *tty,
			  unsigned int cmd, unsigned long arg);

static int zte_write(struct tty_struct *tty, struct usb_serial_port *port,
			  const unsigned char *buf, int count);
static int zte_chars_in_buffer(struct tty_struct *tty);
#ifdef CONFIG_PM
static int zte_suspend(struct usb_serial *serial, pm_message_t message);
static int zte_resume(struct usb_serial *serial);
#endif

/* Vendor and product IDs */
/* ZTE PRODUCTS */
#define zte_VENDOR_ID				0x19d2

/* some devices interfaces need special handling due to a number of reasons */
enum zte_blacklist_reason {
		zte_BLACKLIST_NONE = 0,
		zte_BLACKLIST_SENDSETUP = 1,
		zte_BLACKLIST_RESERVED_IF = 2
};

#define MAX_BL_NUM  8
struct zte_blacklist_info {
	/* bitfield of interface numbers for zte_BLACKLIST_SENDSETUP */
	const unsigned long sendsetup;
	/* bitfield of interface numbers for zte_BLACKLIST_RESERVED_IF */
	const unsigned long reserved;
};

static const struct zte_blacklist_info four_g_w14_blacklist = {
	.sendsetup = BIT(0) | BIT(1),
};

static const struct zte_blacklist_info alcatel_x200_blacklist = {
	.sendsetup = BIT(0) | BIT(1),
	.reserved = BIT(4),
};

static const struct zte_blacklist_info zte_0037_blacklist = {
	.sendsetup = BIT(0) | BIT(1),
};

static const struct zte_blacklist_info zte_k3765_z_blacklist = {
	.sendsetup = BIT(0) | BIT(1) | BIT(2),
	.reserved = BIT(4),
};

static const struct zte_blacklist_info zte_mc2718_z_blacklist = {
	.sendsetup = BIT(1) | BIT(2) | BIT(3) | BIT(4),
};

static const struct zte_blacklist_info huawei_cdc12_blacklist = {
	.reserved = BIT(1) | BIT(2),
};

static const struct zte_blacklist_info net_intf1_blacklist = {
	.reserved = BIT(1),
};

static const struct zte_blacklist_info net_intf2_blacklist = {
	.reserved = BIT(2),
};

static const struct zte_blacklist_info net_intf3_blacklist = {
	.reserved = BIT(3),
};

static const struct zte_blacklist_info net_intf4_blacklist = {
	.reserved = BIT(4),
};

static const struct zte_blacklist_info net_intf5_blacklist = {
	.reserved = BIT(5),
};

static const struct zte_blacklist_info net_intf6_blacklist = {
	.reserved = BIT(6),
};

static const struct zte_blacklist_info zte_mf626_blacklist = {
	.sendsetup = BIT(0) | BIT(1),
	.reserved = BIT(4),
};

static const struct zte_blacklist_info zte_1255_blacklist = {
	.reserved = BIT(3) | BIT(4),
};

static const struct zte_blacklist_info telit_le920_blacklist = {
	.sendsetup = BIT(0),
	.reserved = BIT(1) | BIT(5),
};

static const struct usb_device_id zte_ids[] = {
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0001, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0002, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0003, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0004, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0005, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0006, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0007, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0008, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0009, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0010, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0011, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0012, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0013, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0014, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0015, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0016, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0017, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0018, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0019, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0020, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0021, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0022, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0023, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0024, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0025, 0xff, 0xff, 0xff) },
    //   { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0026, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0027, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0028, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0029, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0030, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0031, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0032, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0033, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0034, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0035, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0036, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0037, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0038, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0039, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0040, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0041, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0042, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0043, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0044, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0045, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0046, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0047, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0048, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0049, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0050, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0051, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0052, 0xff, 0xff, 0xff) },
    //   { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0053, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0054, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0055, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0056, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0057, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0058, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0059, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0060, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0061, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0062, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0063, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0064, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0065, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0066, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0067, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0068, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0069, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0070, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0071, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0072, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0073, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0074, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0075, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0076, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0077, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0078, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0079, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0080, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0081, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0082, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0083, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0084, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0085, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0086, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0087, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0088, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0089, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0090, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0091, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0092, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0093, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0094, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0095, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0096, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0097, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0098, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0099, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0104, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0105, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0106, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0108, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0117, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0118, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0121, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0122, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0123, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0124, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0125, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0126, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0128, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0130, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0133, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0135, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0136, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0137, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0139, 0xff, 0xff, 0xff) }, 	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0141, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0144, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0145, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0147, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0148, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0151, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0152, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0153, 0xff, 0xff, 0xff) },
    //{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0154, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0155, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0156, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0157, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0158, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0159, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0160, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0161, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0162, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0164, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0165, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0167, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0168, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0170, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0176, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0178, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0189, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0191, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0196, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0197, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0199, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0200, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0201, 0xff, 0xff, 0xff) },		
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0254, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0257, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0265, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0284, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0317, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0330, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0395, 0xff, 0xff, 0xff) },      
 	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0414, 0xff, 0xff, 0xff) },   
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x0417, 0xff, 0xff, 0xff) },

    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1008, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1010, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1012, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1018, 0xff, 0xff, 0xff) },		
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1057, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1058, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1059, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1060, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1061, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1062, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1063, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1064, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1065, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1066, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1067, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1068, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1069, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1070, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1071, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1072, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1073, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1074, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1075, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1076, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1077, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1078, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1079, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1080, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1081, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1082, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1083, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1084, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1085, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1086, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1087, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1088, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1089, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1090, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1091, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1092, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1093, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1094, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1095, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1096, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1097, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1098, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1099, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1100, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1101, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1102, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1103, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1104, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1105, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1106, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1107, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1108, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1109, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1110, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1111, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1112, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1113, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1114, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1115, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1116, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1117, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1118, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1119, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1120, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1121, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1122, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1123, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1124, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1125, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1126, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1127, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1128, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1129, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1130, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1131, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1132, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1133, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1134, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1135, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1136, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1137, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1138, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1139, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1140, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1141, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1142, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1143, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1144, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1145, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1146, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1147, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1148, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1149, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1150, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1151, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1152, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1153, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1154, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1155, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1156, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1157, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1158, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1159, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1160, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1161, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1162, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1163, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1164, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1165, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1166, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1167, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1168, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1169, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1170, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1244, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1245, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1246, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1247, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1248, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1249, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1250, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1251, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1252, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1253, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1254, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1255, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1256, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1257, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1258, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1259, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1260, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1261, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1262, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1263, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1264, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1265, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1266, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1267, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1268, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1269, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1270, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1271, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1272, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1273, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1274, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1275, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1276, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1277, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1278, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1279, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1280, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1281, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1282, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1283, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1284, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1285, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1286, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1287, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1288, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1289, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1290, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1291, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1292, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1293, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1294, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1295, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1296, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1297, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1298, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1299, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1300, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1301, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1302, 0xff, 0xff, 0xff) },
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1303, 0xff, 0xff, 0xff) },	
	{ USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1333, 0xff, 0xff, 0xff) },	
	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1401, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1402, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1403, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1404, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1405, 0xff, 0xff, 0xff) },	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1406, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1407, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1408, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1409, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1410, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1411, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1412, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1413, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1414, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1415, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1416, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1417, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1418, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1419, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1420, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1421, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1422, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1423, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1424, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1425, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1426, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1427, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1428, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1429, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1430, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1431, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1432, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1433, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1434, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1435, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1436, 0xff, 0xff, 0xff) },   
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1437, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1438, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1439, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1440, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1441, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1442, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1443, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1444, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1445, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1446, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1447, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1448, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1449, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1450, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1451, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1452, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1453, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1454, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1455, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1456, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1457, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1458, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1459, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1460, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1461, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1462, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1463, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1464, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1465, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1466, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1467, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1468, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1469, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1470, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1471, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1472, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1473, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1474, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1475, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1476, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1477, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1478, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1479, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1480, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1481, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1482, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1483, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1484, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1485, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1486, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1487, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1488, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1489, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1490, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1491, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1492, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1493, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1494, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1495, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1496, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1497, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1498, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1499, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1500, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1501, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1502, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1503, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1504, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1505, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1506, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1507, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1508, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1509, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1510, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1533, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1534, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1535, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1545, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1546, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1547, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1565, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1566, 0xff, 0xff, 0xff) },     
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1567, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1589, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1590, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1591, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1592, 0xff, 0xff, 0xff) }, 	
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1594, 0xff, 0xff, 0xff) }, 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1596, 0xff, 0xff, 0xff) },  
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1598, 0xff, 0xff, 0xff) },    
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x1600, 0xff, 0xff, 0xff) },  		
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x2002, 0xff, 0xff, 0xff) },
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0x2003, 0xff, 0xff, 0xff) },	 
    { USB_DEVICE_AND_INTERFACE_INFO(zte_VENDOR_ID, 0xFFEC, 0xff, 0xff, 0xff) },
    { ZTE_USB_DEVICE_ID_MATCH_INT_CLASS_AND_SUBCLASS_INFO(0x19d2,0xff,0x86) },
    { ZTE_USB_DEVICE_ID_MATCH_INT_CLASS_AND_SUBCLASS_INFO(0x19d2,0xff,0x02) },
    { USB_DEVICE_AND_INTERFACE_INFO(TPLink_VENDOR_ID, 0x7E11, 0xff, 0xff, 0xff) },/*TPLink*/
    { USB_DEVICE_AND_INTERFACE_INFO(QUALCOMM_VENDOR_ID, 0x9001, 0xff, 0xff, 0xff) },/*QUALCOMM_VENDOR_ID*/
    { USB_DEVICE_AND_INTERFACE_INFO(QUALCOMM_VENDOR_ID, 0x9002, 0xff, 0xff, 0xff) },
	{ } /* Terminating entry */
};
MODULE_DEVICE_TABLE(usb, zte_ids);

/* The card has three separate interfaces, which the serial driver
 * recognizes separately, thus num_port=1.
 */

static struct usb_serial_driver zte_1port_device = {
	.driver = {
		.owner =	THIS_MODULE,
		.name =		"zte1",
	},
	.description       = "GSM modem (1-port)",
	.id_table          = zte_ids,
	.num_ports         = 1,
	.probe             = zte_probe,
	.open              = zte_open,
	.close             = zte_close,
	.dtr_rts	   = zte_dtr_rts,
	.write             = zte_write,
	.write_room        = zte_write_room,
	.chars_in_buffer   = zte_chars_in_buffer,
	.set_termios       = zte_set_termios,
	.tiocmget          = zte_tiocmget,
	.tiocmset          = zte_tiocmset,
	.ioctl             = zte_ioctl,
	.attach            = zte_attach,
	.release           = zte_release,
	.port_probe        = zte_port_probe,
	.port_remove	   = zte_port_remove,
	.read_int_callback = zte_instat_callback,
#ifdef CONFIG_PM
	.suspend           = zte_suspend,
	.resume            = zte_resume,
#endif
};

static bool debug;
/* per port private data */

#define N_IN_URB 4
#define N_OUT_URB 4
#define IN_BUFLEN 4096
#define OUT_BUFLEN 4096

struct zte_intf_private {
	spinlock_t susp_lock;
	unsigned int suspended:1;
	int in_flight;
	int (*send_setup) (struct usb_serial_port *port);
	void *private;
};

struct zte_port_private {
	/* Input endpoints and buffer for this port */
	struct urb *in_urbs[N_IN_URB];
	u8 *in_buffer[N_IN_URB];
	/* Output endpoints and buffer for this port */
	struct urb *out_urbs[N_OUT_URB];
	u8 *out_buffer[N_OUT_URB];
	unsigned long out_busy;	/* Bit vector of URBs in use */
	int opened;
	struct usb_anchor delayed;

	/* Settings for the port */
	int rts_state;		/* Handshaking pins (outputs) */
	int dtr_state;
	int cts_state;		/* Handshaking pins (inputs) */
	int dsr_state;
	int dcd_state;
	int ri_state;

	unsigned long tx_start_time[N_OUT_URB];
};

static void zte_dtr_rts(struct usb_serial_port *port, int on)
{
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata;

	intfdata = port->serial->private;

	if (!intfdata->send_setup)
		return;

	portdata = usb_get_serial_port_data(port);
	/* FIXME: locking */
	portdata->rts_state = on;
	portdata->dtr_state = on;

	intfdata->send_setup(port);
}

static void zte_set_termios(struct tty_struct *tty,
			  struct usb_serial_port *port,
			  struct ktermios *old_termios)
{
	struct zte_intf_private *intfdata = port->serial->private;

	/* Doesn't support zte setting */
	tty_termios_copy_hw(&tty->termios, old_termios);

	if (intfdata->send_setup)
		intfdata->send_setup(port);
}

static int zte_tiocmget(struct tty_struct *tty)
{
	struct usb_serial_port *port = tty->driver_data;
	unsigned int value;
	struct zte_port_private *portdata;

	portdata = usb_get_serial_port_data(port);

	value = ((portdata->rts_state) ? TIOCM_RTS : 0) |
	    ((portdata->dtr_state) ? TIOCM_DTR : 0) |
	    ((portdata->cts_state) ? TIOCM_CTS : 0) |
	    ((portdata->dsr_state) ? TIOCM_DSR : 0) |
	    ((portdata->dcd_state) ? TIOCM_CAR : 0) |
	    ((portdata->ri_state) ? TIOCM_RNG : 0);

	return value;
}

static int zte_tiocmset(struct tty_struct *tty,
		      unsigned int set, unsigned int clear)
{
	struct usb_serial_port *port = tty->driver_data;
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata;

	portdata = usb_get_serial_port_data(port);
	intfdata = port->serial->private;

	if (!intfdata->send_setup)
		return -EINVAL;

	/* FIXME: what locks portdata fields ? */
	if (set & TIOCM_RTS)
		portdata->rts_state = 1;
	if (set & TIOCM_DTR)
		portdata->dtr_state = 1;

	if (clear & TIOCM_RTS)
		portdata->rts_state = 0;
	if (clear & TIOCM_DTR)
		portdata->dtr_state = 0;
	return intfdata->send_setup(port);
}

static int get_serial_info(struct usb_serial_port *port,
			   struct serial_struct __user *retinfo)
{
	struct serial_struct tmp;

	if (!retinfo)
		return -EFAULT;

	memset(&tmp, 0, sizeof(tmp));
	tmp.line            = port->minor;
	tmp.port            = port->port_number;
	tmp.baud_base       = tty_get_baud_rate(port->port.tty);
	tmp.close_delay	    = port->port.close_delay / 10;
	tmp.closing_wait    = port->port.closing_wait == ASYNC_CLOSING_WAIT_NONE ?
				 ASYNC_CLOSING_WAIT_NONE :
				 port->port.closing_wait / 10;

	if (copy_to_user(retinfo, &tmp, sizeof(*retinfo)))
		return -EFAULT;
	return 0;
}

static int set_serial_info(struct usb_serial_port *port,
			   struct serial_struct __user *newinfo)
{
	struct serial_struct new_serial;
	unsigned int closing_wait, close_delay;
	int retval = 0;

	if (copy_from_user(&new_serial, newinfo, sizeof(new_serial)))
		return -EFAULT;

	close_delay = new_serial.close_delay * 10;
	closing_wait = new_serial.closing_wait == ASYNC_CLOSING_WAIT_NONE ?
			ASYNC_CLOSING_WAIT_NONE : new_serial.closing_wait * 10;

	mutex_lock(&port->port.mutex);

	if (!capable(CAP_SYS_ADMIN)) {
		if ((close_delay != port->port.close_delay) ||
		    (closing_wait != port->port.closing_wait))
			retval = -EPERM;
		else
			retval = -EOPNOTSUPP;
	} else {
		port->port.close_delay  = close_delay;
		port->port.closing_wait = closing_wait;
	}

	mutex_unlock(&port->port.mutex);
	return retval;
}

static int zte_ioctl(struct tty_struct *tty,
		   unsigned int cmd, unsigned long arg)
{
	struct usb_serial_port *port = tty->driver_data;

	dev_dbg(&port->dev, "%s cmd 0x%04x\n", __func__, cmd);

	switch (cmd) {
	case TIOCGSERIAL:
		return get_serial_info(port,
				       (struct serial_struct __user *) arg);
	case TIOCSSERIAL:
		return set_serial_info(port,
				       (struct serial_struct __user *) arg);
	default:
		break;
	}

	dev_dbg(&port->dev, "%s arg not supported\n", __func__);

	return -ENOIOCTLCMD;
}

/* Write */
static int zte_write(struct tty_struct *tty, struct usb_serial_port *port,
		   const unsigned char *buf, int count)
{
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata;
	int i;
	int left, todo;
	struct urb *this_urb = NULL;	/* spurious */
	int err;
	unsigned long flags;

	portdata = usb_get_serial_port_data(port);
	intfdata = port->serial->private;

	dev_dbg(&port->dev, "%s: write (%d chars)\n", __func__, count);

	i = 0;
	left = count;
	for (i = 0; left > 0 && i < N_OUT_URB; i++) {
		todo = left;
		if (todo > OUT_BUFLEN)
			todo = OUT_BUFLEN;

		this_urb = portdata->out_urbs[i];
		if (test_and_set_bit(i, &portdata->out_busy)) {
			if (time_before(jiffies,
					portdata->tx_start_time[i] + 10 * HZ))
				continue;
			usb_unlink_urb(this_urb);
			continue;
		}
		dev_dbg(&port->dev, "%s: endpoint %d buf %d\n", __func__,
			usb_pipeendpoint(this_urb->pipe), i);

		err = usb_autopm_get_interface_async(port->serial->interface);
		if (err < 0)
			break;

		/* send the data */
		memcpy(this_urb->transfer_buffer, buf, todo);
		this_urb->transfer_buffer_length = todo;

		spin_lock_irqsave(&intfdata->susp_lock, flags);
		if (intfdata->suspended) {
			usb_anchor_urb(this_urb, &portdata->delayed);
			spin_unlock_irqrestore(&intfdata->susp_lock, flags);
		} else {
			intfdata->in_flight++;
			spin_unlock_irqrestore(&intfdata->susp_lock, flags);
			err = usb_submit_urb(this_urb, GFP_ATOMIC);
			if (err) {
				dev_dbg(&port->dev,
					"usb_submit_urb %p (write bulk) failed (%d)\n",
					this_urb, err);
				clear_bit(i, &portdata->out_busy);
				spin_lock_irqsave(&intfdata->susp_lock, flags);
				intfdata->in_flight--;
				spin_unlock_irqrestore(&intfdata->susp_lock,
						       flags);
				usb_autopm_put_interface_async(port->serial->interface);
				break;
			}
		}

		portdata->tx_start_time[i] = jiffies;
		buf += todo;
		left -= todo;
	}

	count -= left;
	dev_dbg(&port->dev, "%s: wrote (did %d)\n", __func__, count);
	return count;
}

static void zte_indat_callback(struct urb *urb)
{
	int err;
	int endpoint;
	struct usb_serial_port *port;
	struct device *dev;
	unsigned char *data = urb->transfer_buffer;
	int status = urb->status;

	endpoint = usb_pipeendpoint(urb->pipe);
	port = urb->context;
	dev = &port->dev;

	if (status) {
		dev_dbg(dev, "%s: nonzero status: %d on endpoint %02x.\n",
			__func__, status, endpoint);
	} else {
		if (urb->actual_length) {
			tty_insert_flip_string(&port->port, data,
					urb->actual_length);
			tty_flip_buffer_push(&port->port);
		} else
			dev_dbg(dev, "%s: empty read urb received\n", __func__);
	}
	/* Resubmit urb so we continue receiving */
	err = usb_submit_urb(urb, GFP_ATOMIC);
	if (err) {
		if (err != -EPERM) {
			dev_err(dev, "%s: resubmit read urb failed. (%d)\n",
				__func__, err);
			/* busy also in error unless we are killed */
			usb_mark_last_busy(port->serial->dev);
		}
	} else {
		usb_mark_last_busy(port->serial->dev);
	}
}

static void zte_outdat_callback(struct urb *urb)
{
	struct usb_serial_port *port;
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata;
	int i;

	port = urb->context;
	intfdata = port->serial->private;

	usb_serial_port_softint(port);
	usb_autopm_put_interface_async(port->serial->interface);
	portdata = usb_get_serial_port_data(port);
	spin_lock(&intfdata->susp_lock);
	intfdata->in_flight--;
	spin_unlock(&intfdata->susp_lock);

	for (i = 0; i < N_OUT_URB; ++i) {
		if (portdata->out_urbs[i] == urb) {
			smp_mb__before_clear_bit();
			clear_bit(i, &portdata->out_busy);
			break;
		}
	}
}

static int zte_write_room(struct tty_struct *tty)
{
	struct usb_serial_port *port = tty->driver_data;
	struct zte_port_private *portdata;
	int i;
	int data_len = 0;
	struct urb *this_urb;

	portdata = usb_get_serial_port_data(port);

	for (i = 0; i < N_OUT_URB; i++) {
		this_urb = portdata->out_urbs[i];
		if (this_urb && !test_bit(i, &portdata->out_busy))
			data_len += OUT_BUFLEN;
	}

	dev_dbg(&port->dev, "%s: %d\n", __func__, data_len);
	return data_len;
}

static int zte_chars_in_buffer(struct tty_struct *tty)
{
	struct usb_serial_port *port = tty->driver_data;
	struct zte_port_private *portdata;
	int i;
	int data_len = 0;
	struct urb *this_urb;

	portdata = usb_get_serial_port_data(port);

	for (i = 0; i < N_OUT_URB; i++) {
		this_urb = portdata->out_urbs[i];
		/* FIXME: This locking is insufficient as this_urb may
		   go unused during the test */
		if (this_urb && test_bit(i, &portdata->out_busy))
			data_len += this_urb->transfer_buffer_length;
	}
	dev_dbg(&port->dev, "%s: %d\n", __func__, data_len);
	return data_len;
}

static int zte_open(struct tty_struct *tty, struct usb_serial_port *port)
{
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata;
	struct usb_serial *serial = port->serial;
	int i, err;
	struct urb *urb;

	portdata = usb_get_serial_port_data(port);
	intfdata = serial->private;

	/* Start reading from the IN endpoint */
	for (i = 0; i < N_IN_URB; i++) {
		urb = portdata->in_urbs[i];
		if (!urb)
			continue;
		err = usb_submit_urb(urb, GFP_KERNEL);
		if (err) {
			dev_dbg(&port->dev, "%s: submit urb %d failed (%d) %d\n",
				__func__, i, err, urb->transfer_buffer_length);
		}
	}

	if (intfdata->send_setup)
		intfdata->send_setup(port);

	serial->interface->needs_remote_wakeup = 1;
	spin_lock_irq(&intfdata->susp_lock);
	portdata->opened = 1;
	spin_unlock_irq(&intfdata->susp_lock);
	/* this balances a get in the generic USB serial code */
	usb_autopm_put_interface(serial->interface);

	return 0;
}

static void zte_close(struct usb_serial_port *port)
{
	int i;
	struct usb_serial *serial = port->serial;
	struct zte_port_private *portdata;
	struct zte_intf_private *intfdata = port->serial->private;

	portdata = usb_get_serial_port_data(port);

	/* Stop reading/writing urbs */
	spin_lock_irq(&intfdata->susp_lock);
	portdata->opened = 0;
	spin_unlock_irq(&intfdata->susp_lock);

	for (i = 0; i < N_IN_URB; i++)
		usb_kill_urb(portdata->in_urbs[i]);
	for (i = 0; i < N_OUT_URB; i++)
		usb_kill_urb(portdata->out_urbs[i]);

	/* balancing - important as an error cannot be handled*/
	usb_autopm_get_interface_no_resume(serial->interface);
	serial->interface->needs_remote_wakeup = 0;
}

/* Helper functions used by zte_setup_urbs */
static struct urb *zte_setup_urb(struct usb_serial_port *port,
				      int endpoint,
				      int dir, void *ctx, char *buf, int len,
				      void (*callback) (struct urb *))
{
	struct usb_serial *serial = port->serial;
	struct urb *urb;

	urb = usb_alloc_urb(0, GFP_KERNEL);	/* No ISO */
	if (urb == NULL) {
		dev_dbg(&serial->interface->dev,
			"%s: alloc for endpoint %d failed.\n", __func__,
			endpoint);
		return NULL;
	}

	/* Fill URB using supplied data. */
	usb_fill_bulk_urb(urb, serial->dev,
			  usb_sndbulkpipe(serial->dev, endpoint) | dir,
			  buf, len, callback, ctx);

	return urb;
}

static int zte_port_probe(struct usb_serial_port *port)
{
	struct zte_port_private *portdata;
	struct urb *urb;
	u8 *buffer;
	int err;
	int i;

	portdata = kzalloc(sizeof(*portdata), GFP_KERNEL);
	if (!portdata)
		return -ENOMEM;

	init_usb_anchor(&portdata->delayed);

	for (i = 0; i < N_IN_URB; i++) {
		if (!port->bulk_in_size)
			break;

		buffer = (u8 *)__get_free_page(GFP_KERNEL);
		if (!buffer)
			goto bail_out_error;
		portdata->in_buffer[i] = buffer;

		urb = zte_setup_urb(port, port->bulk_in_endpointAddress,
						USB_DIR_IN, port,
						buffer, IN_BUFLEN,
						zte_indat_callback);
		portdata->in_urbs[i] = urb;
	}

	for (i = 0; i < N_OUT_URB; i++) {
		if (!port->bulk_out_size)
			break;

		buffer = kmalloc(OUT_BUFLEN, GFP_KERNEL);
		if (!buffer)
			goto bail_out_error2;
		portdata->out_buffer[i] = buffer;

		urb = zte_setup_urb(port, port->bulk_out_endpointAddress,
						USB_DIR_OUT, port,
						buffer, OUT_BUFLEN,
						zte_outdat_callback);
		portdata->out_urbs[i] = urb;
	}

	usb_set_serial_port_data(port, portdata);

	if (port->interrupt_in_urb) {
		err = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);
		if (err)
			dev_dbg(&port->dev, "%s: submit irq_in urb failed %d\n",
				__func__, err);
	}

	return 0;

bail_out_error2:
	for (i = 0; i < N_OUT_URB; i++) {
		usb_free_urb(portdata->out_urbs[i]);
		kfree(portdata->out_buffer[i]);
	}
bail_out_error:
	for (i = 0; i < N_IN_URB; i++) {
		usb_free_urb(portdata->in_urbs[i]);
		free_page((unsigned long)portdata->in_buffer[i]);
	}
	kfree(portdata);

	return -ENOMEM;
}

static int zte_port_remove(struct usb_serial_port *port)
{
	int i;
	struct zte_port_private *portdata;

	portdata = usb_get_serial_port_data(port);
	usb_set_serial_port_data(port, NULL);

	/* Stop reading/writing urbs and free them */
	for (i = 0; i < N_IN_URB; i++) {
		usb_kill_urb(portdata->in_urbs[i]);
		usb_free_urb(portdata->in_urbs[i]);
		free_page((unsigned long)portdata->in_buffer[i]);
	}
	for (i = 0; i < N_OUT_URB; i++) {
		usb_kill_urb(portdata->out_urbs[i]);
		usb_free_urb(portdata->out_urbs[i]);
		kfree(portdata->out_buffer[i]);
	}

	/* Now free port private data */
	kfree(portdata);
	return 0;
}

#ifdef CONFIG_PM
static void stop_read_write_urbs(struct usb_serial *serial)
{
	int i, j;
	struct usb_serial_port *port;
	struct zte_port_private *portdata;

	/* Stop reading/writing urbs */
	for (i = 0; i < serial->num_ports; ++i) {
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);
		if (!portdata)
			continue;
		for (j = 0; j < N_IN_URB; j++)
			usb_kill_urb(portdata->in_urbs[j]);
		for (j = 0; j < N_OUT_URB; j++)
			usb_kill_urb(portdata->out_urbs[j]);
	}
}

static int zte_suspend(struct usb_serial *serial, pm_message_t message)
{
	struct zte_intf_private *intfdata = serial->private;
	int b;

	if (PMSG_IS_AUTO(message)) {
		spin_lock_irq(&intfdata->susp_lock);
		b = intfdata->in_flight;
		spin_unlock_irq(&intfdata->susp_lock);

		if (b)
			return -EBUSY;
	}

	spin_lock_irq(&intfdata->susp_lock);
	intfdata->suspended = 1;
	spin_unlock_irq(&intfdata->susp_lock);
	stop_read_write_urbs(serial);

	return 0;
}

static void unbusy_queued_urb(struct urb *urb, struct zte_port_private *portdata)
{
	int i;

	for (i = 0; i < N_OUT_URB; i++) {
		if (urb == portdata->out_urbs[i]) {
			clear_bit(i, &portdata->out_busy);
			break;
		}
	}
}

static void play_delayed(struct usb_serial_port *port)
{
	struct zte_intf_private *data;
	struct zte_port_private *portdata;
	struct urb *urb;
	int err;

	portdata = usb_get_serial_port_data(port);
	data = port->serial->private;
	while ((urb = usb_get_from_anchor(&portdata->delayed))) {
		err = usb_submit_urb(urb, GFP_ATOMIC);
		if (!err) {
			data->in_flight++;
		} else {
			/* we have to throw away the rest */
			do {
				unbusy_queued_urb(urb, portdata);
				usb_autopm_put_interface_no_suspend(port->serial->interface);
			} while ((urb = usb_get_from_anchor(&portdata->delayed)));
			break;
		}
	}
}

static int zte_resume(struct usb_serial *serial)
{
	int i, j;
	struct usb_serial_port *port;
	struct zte_intf_private *intfdata = serial->private;
	struct zte_port_private *portdata;
	struct urb *urb;
	int err = 0;

	/* get the interrupt URBs resubmitted unconditionally */
	for (i = 0; i < serial->num_ports; i++) {
		port = serial->port[i];
		if (!port->interrupt_in_urb) {
			dev_dbg(&port->dev, "%s: No interrupt URB for port\n", __func__);
			continue;
		}
		err = usb_submit_urb(port->interrupt_in_urb, GFP_NOIO);
		dev_dbg(&port->dev, "Submitted interrupt URB for port (result %d)\n", err);
		if (err < 0) {
			dev_err(&port->dev, "%s: Error %d for interrupt URB\n",
				__func__, err);
			goto err_out;
		}
	}

	for (i = 0; i < serial->num_ports; i++) {
		/* walk all ports */
		port = serial->port[i];
		portdata = usb_get_serial_port_data(port);

		/* skip closed ports */
		spin_lock_irq(&intfdata->susp_lock);
		if (!portdata || !portdata->opened) {
			spin_unlock_irq(&intfdata->susp_lock);
			continue;
		}

		for (j = 0; j < N_IN_URB; j++) {
			urb = portdata->in_urbs[j];
			err = usb_submit_urb(urb, GFP_ATOMIC);
			if (err < 0) {
				dev_err(&port->dev, "%s: Error %d for bulk URB %d\n",
					__func__, err, i);
				spin_unlock_irq(&intfdata->susp_lock);
				goto err_out;
			}
		}
		play_delayed(port);
		spin_unlock_irq(&intfdata->susp_lock);
	}
	spin_lock_irq(&intfdata->susp_lock);
	intfdata->suspended = 0;
	spin_unlock_irq(&intfdata->susp_lock);
err_out:
	return err;
}
#endif

static struct usb_serial_driver * const serial_drivers[] = {
	&zte_1port_device, NULL
};

struct zte_private {
	u8 bInterfaceNumber;
};

module_usb_serial_driver(serial_drivers, zte_ids);

static bool is_blacklisted(const u8 ifnum, enum zte_blacklist_reason reason,
			   const struct zte_blacklist_info *blacklist)
{
	unsigned long num;
	const unsigned long *intf_list;

	if (blacklist) {
		if (reason == zte_BLACKLIST_SENDSETUP)
			intf_list = &blacklist->sendsetup;
		else if (reason == zte_BLACKLIST_RESERVED_IF)
			intf_list = &blacklist->reserved;
		else {
			BUG_ON(reason);
			return false;
		}

		for_each_set_bit(num, intf_list, MAX_BL_NUM + 1) {
			if (num == ifnum)
				return true;
		}
	}
	return false;
}

static int zte_probe(struct usb_serial *serial,
			const struct usb_device_id *id)
{
	struct usb_interface_descriptor *iface_desc =
				&serial->interface->cur_altsetting->desc;
	struct usb_device_descriptor *dev_desc = &serial->dev->descriptor;

	/* Never bind to the CD-Rom emulation interface	*/
	if (iface_desc->bInterfaceClass == 0x08)
		return -ENODEV;

	/*
	 * Don't bind reserved interfaces (like network ones) which often have
	 * the same class/subclass/protocol as the serial interfaces.  Look at
	 * the Windows driver .INF files for reserved interface numbers.
	 */
	if (is_blacklisted(
		iface_desc->bInterfaceNumber,
		zte_BLACKLIST_RESERVED_IF,
		(const struct zte_blacklist_info *) id->driver_info))
		return -ENODEV;

	/* Store device id so we can use it during attach. */
	usb_set_serial_data(serial, (void *)id);

	return 0;
}



static int zte_attach(struct usb_serial *serial)
{
	struct usb_interface_descriptor *iface_desc;
	const struct usb_device_id *id;
	struct zte_intf_private *data;
	struct zte_private *priv;

	data = kzalloc(sizeof(struct zte_intf_private), GFP_KERNEL);
	if (!data)
		return -ENOMEM;

	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
	if (!priv) {
		kfree(data);
		return -ENOMEM;
	}

	/* Retrieve device id stored at probe. */
	id = usb_get_serial_data(serial);
	iface_desc = &serial->interface->cur_altsetting->desc;

	priv->bInterfaceNumber = iface_desc->bInterfaceNumber;
	data->private = priv;

	if (!is_blacklisted(iface_desc->bInterfaceNumber,
			zte_BLACKLIST_SENDSETUP,
			(struct zte_blacklist_info *)id->driver_info)) {
		data->send_setup = zte_send_setup;
	}
	spin_lock_init(&data->susp_lock);

	usb_set_serial_data(serial, data);

	return 0;
}

static void zte_release(struct usb_serial *serial)
{
	struct zte_intf_private *intfdata = usb_get_serial_data(serial);
	struct zte_private *priv = intfdata->private;

	kfree(priv);
	kfree(intfdata);
}

static void zte_instat_callback(struct urb *urb)
{
	int err;
	int status = urb->status;
	struct usb_serial_port *port = urb->context;
	struct device *dev = &port->dev;
	struct zte_port_private *portdata =
					usb_get_serial_port_data(port);

	dev_dbg(dev, "%s: urb %p port %p has data %p\n", __func__, urb, port, portdata);

	if (status == 0) {
		struct usb_ctrlrequest *req_pkt =
				(struct usb_ctrlrequest *)urb->transfer_buffer;

		if (!req_pkt) {
			dev_dbg(dev, "%s: NULL req_pkt\n", __func__);
			return;
		}
		if ((req_pkt->bRequestType == 0xA1) &&
				(req_pkt->bRequest == 0x20)) {
			int old_dcd_state;
			unsigned char signals = *((unsigned char *)
					urb->transfer_buffer +
					sizeof(struct usb_ctrlrequest));

			dev_dbg(dev, "%s: signal x%x\n", __func__, signals);

			old_dcd_state = portdata->dcd_state;
			portdata->cts_state = 1;
			portdata->dcd_state = ((signals & 0x01) ? 1 : 0);
			portdata->dsr_state = ((signals & 0x02) ? 1 : 0);
			portdata->ri_state = ((signals & 0x08) ? 1 : 0);

			if (old_dcd_state && !portdata->dcd_state)
				tty_port_tty_hangup(&port->port, true);
		} else {
			dev_dbg(dev, "%s: type %x req %x\n", __func__,
				req_pkt->bRequestType, req_pkt->bRequest);
		}
	} else
		dev_err(dev, "%s: error %d\n", __func__, status);

	/* Resubmit urb so we continue receiving IRQ data */
	if (status != -ESHUTDOWN && status != -ENOENT) {
		err = usb_submit_urb(urb, GFP_ATOMIC);
		if (err)
			dev_dbg(dev, "%s: resubmit intr urb failed. (%d)\n",
				__func__, err);
	}
}

/** send RTS/DTR state to the port.
 *
 * This is exactly the same as SET_CONTROL_LINE_STATE from the PSTN
 * CDC.
*/
static int zte_send_setup(struct usb_serial_port *port)
{
	struct usb_serial *serial = port->serial;
	struct zte_intf_private *intfdata = usb_get_serial_data(serial);
	struct zte_private *priv = intfdata->private;
	struct zte_port_private *portdata;
	int val = 0;

	portdata = usb_get_serial_port_data(port);

	if (portdata->dtr_state)
		val |= 0x01;
	if (portdata->rts_state)
		val |= 0x02;

	return usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),
				0x22, 0x21, val, priv->bInterfaceNumber, NULL,
				0, USB_CTRL_SET_TIMEOUT);
}

MODULE_AUTHOR(DRIVER_AUTHOR);
MODULE_DESCRIPTION(DRIVER_DESC);
MODULE_VERSION(DRIVER_VERSION);
MODULE_LICENSE("GPL");

module_param(debug, bool, S_IRUGO | S_IWUSR);
MODULE_PARM_DESC(debug, "Debug messages");


#endif
//#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)//use 2.6.31 sourcecode
//#else
//#endif
